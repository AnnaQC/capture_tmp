window.jsonParse=function(){var r="(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)",k='(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';k='(?:"'+k+'*")';var s=new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|"+r+"|"+k+")","g"),t=new RegExp("\\\\(?:([^u])|u(.{4}))","g"),u={'"':'"',"/":"/","\\":"\\",b:"\u0008",f:"\u000c",n:"\n",r:"\r",t:"\t"};function v(h,j,e){return j?u[j]:String.fromCharCode(parseInt(e,16))}var w=new String(""),x=Object.hasOwnProperty;return function(h,
j){h=h.match(s);var e,c=h[0],l=false;if("{"===c)e={};else if("["===c)e=[];else{e=[];l=true}for(var b,d=[e],m=1-l,y=h.length;m<y;++m){c=h[m];var a;switch(c.charCodeAt(0)){default:a=d[0];a[b||a.length]=+c;b=void 0;break;case 34:c=c.substring(1,c.length-1);if(c.indexOf("\\")!==-1)c=c.replace(t,v);a=d[0];if(!b)if(a instanceof Array)b=a.length;else{b=c||w;break}a[b]=c;b=void 0;break;case 91:a=d[0];d.unshift(a[b||a.length]=[]);b=void 0;break;case 93:d.shift();break;case 102:a=d[0];a[b||a.length]=false;
b=void 0;break;case 110:a=d[0];a[b||a.length]=null;b=void 0;break;case 116:a=d[0];a[b||a.length]=true;b=void 0;break;case 123:a=d[0];d.unshift(a[b||a.length]={});b=void 0;break;case 125:d.shift();break}}if(l){if(d.length!==1)throw new Error;e=e[0]}else if(d.length)throw new Error;if(j){var p=function(n,o){var f=n[o];if(f&&typeof f==="object"){var i=null;for(var g in f)if(x.call(f,g)&&f!==n){var q=p(f,g);if(q!==void 0)f[g]=q;else{i||(i=[]);i.push(g)}}if(i)for(g=i.length;--g>=0;)delete f[i[g]]}return j.call(n,
o,f)};e=p({"":e},"")}return e}}();

'use strict';

/* global AccountEngine: false */
/* global html: false */
/* global salesforce: false */
/* global angular: false */
/* global Pace: false */

var AccountController = function ($scope, $location, mySharedService, $timeout, docSize, environmentUtility, captureService, parsingService, debugUtility, registrationService, chromeUtility,
    exportWrapperService,
    shieldService, storeService, storageService, userInfoStore, totangoService, dialogs, patternStore, contactUtility, bgService, settingsUtility) {


    var debug = 'account.ui.js->'; //debug = false;

    //var log = function () {
    //    console.log('log');
    //    if (debug) {
    //        //if (!text) { text = ''; }
    //        var args = Array.slice(arguments);
    //        console.log(debug, args);
    //    }
    //};

    var getVersion = function () {
        var manifestData = chrome.app.getDetails();
        if (debug) { console.log('Version', manifestData.version); }
        return manifestData.version;
    };

    var showLoader = function () {
        try {
            Pace.restart();
        } catch (e) {

        }
    };

    $scope.registered = false;
    $scope.loggedin = false;
    $scope.signStatus = '';
    $scope.regStatus = '';
    //$scope.shieldStatus = 'Unknown';
    $scope.refreshingAccount = false;

    $scope.tab1 = null; //'signin';
    $scope.tab2 = null;

    docSize.setWidth(600);
    //docSize.setHeight(690);
    //docSize.setSize(600, 500);

    $scope.license = {
        date: null, subscribed: false, subStatus: 'No license', exp: null,
        limits: [],
        pageTokens: 0, listTokens: 0, companyTokens: 0, contactTokens: -1
    };
    $scope.account = { token: null, sitekey: null, uid: null, auth: null, settings: { autoCapture: false, autoCaptureDomains: [] } };
    $scope.profile = {};
    $scope.runtime = { sfurl: null, contactsCount: 0, source: 'page' };

    $scope.editingTargets = false; // controls whethter the list of targets is open or closed

    environmentUtility.onLoaded(function () {
        $scope.isLocal = environmentUtility.isRelease('local');
        $scope.isAlpha = environmentUtility.isRelease('alpha');
        $scope.isBeta = environmentUtility.isRelease('beta');
        $scope.isProduction = environmentUtility.isRelease('production');
    });

    //debugUtility.addLoggingProperties($scope);
    //$scope.logLevel = $scope.LOG_LEVEL_ALL;

    $scope.$on('handleBroadcast', function () {

        var msg = mySharedService.message;
        //if (debug) { console.log(debug + 'Broadcast received', msg); }
        if (msg === 'login') {
            $scope.signin(true);
        } else if (msg === 'tab:contact') {
            $scope.showTab('contact');
            try {
                $scope.reloadPatterns();
            } catch (e) {
                console.error('Reload Patterns > ', e.message);
            }
        }
        else if (msg === 'captureNow') {
            $scope.patternCapture();
        }
        else if (msg.indexOf('runtime:') === 0) {
            if (debug) { console.log('runtime broadcast', msg); }
            var pp = msg.split(':', 3);
            if (pp.length === 3) {
                $scope.runtime[pp[1]] = pp[2];
            }
        }
        else if (msg.indexOf('contactTokensLeft:') === 0) {
            console.log('TOKENS LEFT', msg);
            $scope.license.contactTokens = parseInt(msg.substring(msg.indexOf(':') + 1));
            //chrome.storage.sync.set({ 'license': $scope.license }, function () {
            //    console.log('TOKENS LEFT SAVED', $scope.license.contactTokens);
            //});

            chromeUtility.setField('license', $scope.license,

                function () {
                    console.log('TOKENS LEFT SAVED', $scope.license.contactTokens);
                },

                function (error) {
                    console.error('**** TOKENS LEFT NOT SAVED', $scope.license.contactTokens, error);
                }
            );
        }
    });

    $scope.refresh = function () {
        if (!$scope.$$phase) { $scope.$apply(); }
    };

    var playCaptureAudio = function () {
        try {
            //if ($scope.settings.mute1) {
            //    return;
            //}
            var audio = document.getElementById('capture-audio');
            audio.play();
        } catch (e) {
            console.error('Play Audio > ', e.message);
        }
    };

    $scope.clickToCapture = function (clickEvent) {
        try {
            if ($scope.runtime.source === 'clipboard') {
                $scope.captureClipboard(clickEvent);
            } else if ($scope.runtime.source === 'selection') {
                playCaptureAudio();
                fallbackCapture({ selection: true });
            } else {
                playCaptureAudio();
                $scope.patternCapture(clickEvent);
            }
        } catch (e) {
            console.error('Click to Capture > ', e.message);
        }
    };

    $scope.clickToCapturePage = function (clickEvent) {
        try {
            $scope.runtime.source = 'page';
            $scope.clickToCapture(clickEvent);
        } catch (e) {
            console.error('Click to Capture > ', e.message);
        }
    };

    $scope.clickToCaptureSelection = function (clickEvent) {
        try {
            $scope.runtime.source = 'selection';
            $scope.clickToCapture(clickEvent);
        } catch (e) {
            console.error('Click to Capture > ', e.message);
        }
    };

    $scope.clickToCaptureClipboard = function (clickEvent) {
        try {
            $scope.runtime.source = 'clipboard';
            $scope.clickToCapture(clickEvent);
        } catch (e) {
            console.error('Click to Capture > ', e.message);
        }
    };

    $scope.captureClipboard = function () {
        const functionName = 'Capture Clipboard';

        try {

            //var input = $('#capturePasteArea');
            //input.val('');
            //input.show();
            //input.focus();
            //document.execCommand('paste');
            //var clipboardData = input.val();
            //var htmlFormatting = undefined;
            //input.hide();
            //console.log(functionName, 'Clipboard > ', clipboardData);

            //if (!clipboardData || clipboardData.length === 0) {
            //    dialogs.alert.show('Clipboard is empty');
            //    return;
            //}

            //dialogs.busy.show('Capturing contacts...').cancel(function () { });

            //captureService.manualCapture(clipboardData, (htmlFormatting ? 'text/html' : undefined),
            //           function (contacts) {
            //               dialogs.busy.hide();
            //               contactUtility.addContacts(contacts, null, false, { method: 'CaptureService' });
            //               if (!$scope.$$phase) { $scope.$apply(); }
            //           },
            //           function (error) {
            //               dialogs.busy.hide();
            //               dialogs.alert.show(error);
            //               console.log(error);
            //           }
            //       );


            dialogs.capture.clipboard.show()
                .confirm(function (response) {
                    var clipboardData = response.data;
                    if (!clipboardData || clipboardData.length === 0) {
                        dialogs.alert.show('Clipboard is empty');
                        return;
                    }
                    var htmlFormatting = response.htmlFormatting;
                    playCaptureAudio();
                    dialogs.busy.show('Capturing contacts...').cancel(function () { });
                    captureService.manualCapture(clipboardData, (htmlFormatting ? 'text/html' : undefined),
                        function (contacts) {
                            dialogs.busy.hide();
                            contactUtility.addContacts(contacts, null, false, { method: 'CaptureService' });
                            if (!$scope.$$phase) { $scope.$apply(); }
                        },
                        function (error) {
                            dialogs.busy.hide();
                            dialogs.alert.show(error);
                            console.log(error);
                        }
                    );
                });

        } catch (e) {
            console.error(functionName, e.message);
        }

    };

    $scope.editPatterns = function () {
        $location.path('/patterns');
    };

    $scope.registration = function () {
        showLoader();
        $location.path('/register');
    };

    $scope.showSettings = function () {
        showLoader();
        $timeout(function () {
            mySharedService.broadcast('licenseType:' + $scope.license.licenseType);
        }, 1000);
        $location.path('/settings');
    };

    $scope.subscription = function () {
        showLoader();
        if (debug) { console.log(debug + 'go to subscription'); }
        //$scope.showTab('moremenu', 'status');
        $location.path('/subscription');
    };

    $scope.signin = function () {
        //$location.path('/signin');
        if (debug) { console.log(debug + 'signing in'); }


        var keys = ['profile']; // for new way

        var oldWayToNewWay = function (profile) {

            if (debug) { console.log(debug + 'old Way To New Way'); }

            var o = {};
            o.profile = profile;

            storageService.set(o,

                // storage service success
                function () {
                    if (debug) { console.log(debug + 'profile saved (BROADLOOK STORAGE)', profile); }

                },

                // storage service failed
                function () {
                    if (debug) { console.log(debug + 'profile not saved (BROADLOOK STORAGE)', profile); }

                }

                );
        };

        var oldWay = function () {

            if (debug) { console.log(debug + 'old way'); }

            chromeUtility.getField('profile', function (profile) {
                if (debug) { console.log(debug + 'profile loaded', profile); }
                $scope.profile = profile;
                $scope.loggedin = true;
                $scope.signStatus = 'Logged in as ' + $scope.profile.email;
                //oldWayToNewWay(profile);
                checkRegistration();
                $scope.refresh();
            }, function () {
                if (debug) { console.log(debug + 'profile not loaded'); }
                checkRegistration();
                $scope.refresh();
            }
            );

        };

        oldWay();
        /*return;
        
        // new way

        if (debug) { console.log(debug + 'new way'); }

        storageService.get(keys,

            // profile loaded from storage service
            function (values) {
                if (debug) { console.log(debug + 'profile loaded (BROADLOOK STORAGE)', values); }
                var profile = values.profile;

                if (!profile) {
                    if (debug) { console.log(debug + 'empty profile (BROADLOOK STORAGE)'); }
                    oldWay();
                    return;
                }

                if (debug) { console.log(debug + 'profile loaded', profile); }
                $scope.profile = profile;
                $scope.loggedin = true;
                $scope.signStatus = 'Logged in as ' + $scope.profile.email;
                //oldWayToNewWay(profile);
                checkRegistration();
                $scope.refresh();

            },

            // profile not loaded from storage service
            function (error) {
                if (debug) { console.log(debug + 'profile not loaded  (BROADLOOK STORAGE)'); }

                oldWay();

            });*/
    };

    $scope.signout = function () {

        if (debug) { console.log('signout'); }

        mySharedService.broadcast('logout');

        chrome.identity.removeCachedAuthToken(
              { 'token': $scope.account.token },
              function () {
                  $scope.signStatus = 'Signed out';
                  $scope.regStatus = '';
                  $scope.registered = false;
                  $scope.loggedin = false;
                  $scope.account.token = null;
                  $scope.account.sitekey = null;
                  $scope.account.uid = null;
                  $scope.account.auth = null;
                  if (!$scope.$$phase) { $scope.$apply(); }
              });

    };

    $scope.unregister = function () {
        if (debug) { console.log('unregister'); }
        $scope.registered = false;
    };

    $scope.register = function () {
        $location.path('/register');
    };

    var applySettings = function (settings) {

        var resetMaps = function (settings) {
            console.log('************** reset maps ***************');
            // init objects
            if (!settings.targetMap || Array.isArray(settings.targetMap))
            { settings.targetMap = {}; }
            if (!settings.targetMap[settings.target])
            { settings.targetMap[settings.target] = { entities: [] }; }

            var exportService = getExportService();
            if (!exportService) { return; }

            if (typeof exportService.getDefaultExportMaps !== 'function') {
                console.log('not supported: getDefaultExportMaps');
                return;
            }

            exportService.getDefaultExportMaps(function (maps) {
                console.log('*********** got default maps ************************', maps);
                $scope.account.settings.targetMap[settings.target].entities = maps; // update scope settings
                mySharedService.broadcast('settings:', $scope.account.settings); // re-broadcast
                $scope.saveSettings();
            });

        };


        $scope.account.settings = settingsUtility.readSettings(settings, $scope.profile.target);
        $scope.saveSettings();

        // Check SF so the maps are not corrupted
        if ($scope.account.settings.target === 'sf') {
            if (!$scope.account.settings.targetMap || !$scope.account.settings.targetMap[settings.target] || !$scope.account.settings.targetMap[settings.target].entities) {
                resetMaps($scope.account.settings);
            }
        }

        if (debug) { console.log(debug + 'settings loaded', angular.copy($scope.account.settings)); }

        mySharedService.broadcast('settings:', $scope.account.settings);

        var scheme = userInfoStore.getShieldScheme();

        if (typeof scheme === 'undefined') {
            console.log('ERROR! No Shield scheme found in local cache!');
            $scope.checkNormalizationStatus();
        } else {
            //console.log('SUCCESS! Shield scheme found in local cache!');
            //$scope.shieldStatus = 'ON';
        }

        $scope.loadCachedLicense();

        $scope.refresh();
    };




    var loadSettingsFromBroadlookStorage = function (callback) {

        storageService.get(

                    ['settings'],

                    function (value) {
                        try {
                            if (debug) {
                                console.log(debug + 'loaded settings (from Broadlook storage):', angular.copy(value), ' current:', angular.copy($scope.account.settings));
                            }

                            if (value && value.settings) {
                                value.settings.managed = value.settings_managed === true;
                                if (debug) { console.log(debug + 'managed?', value.settings_managed); }
                            }

                            applySettings(value.settings);

                            bgService.setValue('settings', $scope.account.settings);

                        } catch (e) {
                            console.log('ERROR in checkRegistration.storageService.get.success', e.message);
                        }

                        try { callback(); } catch (e) { }

                    },

                    function (error) {
                        console.log('ERROR!', error);
                        dialogs.alert.show(error);

                        try { callback(); } catch (e) { }
                    }

                    );
    };

    var processInitialInstall = function () {

        console.log(debug + '*** Initial install mode');

        loadSettingsFromBroadlookStorage(function () {

            if ($scope.account.settings && $scope.account.settings.setupCompleted) {
                console.log(debug + '*** Initial install completed');
                bgService.setValue('firstInstall', false);
                return;
            } else {

                console.log(debug + '*** Initial install not completed', angular.copy($scope.account.settings));
                try {

                    $timeout(function () {

                        bgService.setValue('firstInstall', false);

                        dialogs.confirm
                            .show('Welcome to Capture! Let\'s set it up. ')
                            .confirm(
                                function () {
                                    console.log(debug + '*** Launching Settings Wizard');
                                    $timeout(function () {
                                        $scope.showSettings();
                                    }, 1000);
                                }
                            )
                            .cancel(
                                function () {
                                    console.log(debug + '*** Settings Wizard cancelled');
                                    $timeout(function () {
                                        dialogs.alert.show('You can change default settings anytime by going into the top-right menu.');
                                        bgService.setValue('firstInstall', false);
                                    }, 500);
                                }
                            );

                        //dialogs.confirm
                        //            .show('Welcome to Capture! Click OK to set it up.')
                        //            .confirm(
                        //                function () {
                        //                    console.log(debug + '*** Launching wizard');
                        //                    $scope.openGuide();

                        //                    $timeout(function () {
                        //                        console.log(debug + '*** Closing window');
                        //                        window.close();
                        //                        //    reloadPatterns();
                        //                    }, 1000);
                        //                }
                        //            )
                        //            .cancel(
                        //                function () {
                        //                    console.log(debug + '*** Wizard cancelled');
                        //                    $timeout(function () {
                        //                        //    patternCapture(patterns);

                        //                        dialogs.alert.show('You can use Getting Started link in Capture menu to run the initial setup wizard anytime.');

                        //                        bgService.setValue('firstInstall', false);

                        //                    }, 500);
                        //                }
                        //            );

                    }, 2000);

                } catch (e) {
                    console.log(debug + '*** ERROR in dialog', e.message);
                }

            }

        });




    };

    var checkRegistration = function () {
        const functionName = 'Check Registration';
        if (debug) { console.log(debug + 'checkRegistration'); }

        if (registrationService.isRegistered()) {

            $scope.registered = true;
            $scope.regStatus = 'Registered';

            //if (!$scope.isProduction) {

            var firstInstall = bgService.getValue('firstInstall');

            console.log(debug + '*** firstInstall', firstInstall);

            if (firstInstall === true) { // Initial install mode!
                processInitialInstall();
                return;
            }

            //}

            var s = bgService.getValue('settings');

            //console.log(debug + '*** settings', s);

            if (s && s.targetMap) {
                if (debug) {
                    console.log(debug + 'loaded settings (from background storage):', angular.copy(s), ' current:', angular.copy($scope.account.settings));
                }
                applySettings(s);
            } else {
                loadSettingsFromBroadlookStorage();
            }

        } else {

            $location.path('/register');

            //registrationService.me({ email: $scope.profile.email }, function (response) {

            //    $scope.profile.company = response.company;
            //    $scope.profile.title = response.title;
            //    $scope.profile.phone = response.phone;

            //    $location.path('/register');
            //}, function (msg) {
            //    $location.path('/register');
            //});

        }
    };




    // Loads a license from Google Storage
    $scope.loadCachedLicense = function () {

        if (debug) { console.log(debug + 'loadCachedLicense'); }

        //chrome.storage.sync.get
        chromeUtility.getField('license', function (license) {

            var daysLoaded = -1;

            if (license) {
                // restore date
                if (license.dateMS) {
                    license.date = new Date();
                    license.date.setTime(license.dateMS);
                    daysLoaded = contactUtility.daysBetween(new Date(), license.date, true);
                }
                // restore exp
                if (license.expMS) {
                    license.exp = new Date();
                    license.exp.setTime(license.expMS);
                }
                // restore next
                if (license.nextMS) {
                    license.next = new Date();
                    license.next.setTime(license.nextMS);
                }
                // restore last
                if (license.lastMS) {
                    license.last = new Date();
                    license.last.setTime(license.lastMS);
                }
            }

            if (debug) { console.log(debug + 'license', license, 'days loaded', daysLoaded); }

            if (license && daysLoaded >= 0 && daysLoaded <= 1) {
                $scope.license = license;
                $scope.global.license = $scope.license;
                if (debug) { console.log(debug + 'use license from storage'); }
                $scope.applyLicense();
            }
            else {
                if (debug) { console.log(debug + 'user license was not found in storage or expired, get new one', $scope.account, daysLoaded); }
                $scope.refreshAccount();
            }
        });

    };

    $scope.applyLicense = function () {

        if ($scope.license.subscribed) {
            mySharedService.broadcast('pageTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.pageTokens));
            mySharedService.broadcast('listTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.listTokens));
            mySharedService.broadcast('companyTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.companyTokens));
            if ($scope.license.licenseType === 'Bulk')
            { mySharedService.broadcast('contactTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.limited.current)); }
            else
            { mySharedService.broadcast('contactTokens:' + (!$scope.license.subscribed ? 0 : ($scope.license.full.current || $scope.license.contactTokens))); }
            mySharedService.broadcast('licenseType:' + $scope.license.licenseType);
            console.log('Broadcast > License Type > ', $scope.license.licenseType);

            if (!$scope.$$phase) { $scope.$apply(); }
        }
        else {
            $scope.subscription();
            $scope.openStore();
        }
    };

    $scope.showTab = function (tab1) {

        if (debug) { console.log('showing tab', tab1); }

        if (tab1 !== null) { $scope.tab1 = tab1; }

        if ($scope.tab1 === 'searchmenu')
        { mySharedService.broadcast('search:show'); }
        else
        { mySharedService.broadcast('search:hide'); }

        if ($scope.tab1 === 'contact')
        { mySharedService.broadcast('contact:show'); }
        else
        { mySharedService.broadcast('contact:hide'); }

        if (!$scope.$$phase) { $scope.$apply(); }
    };

    $scope.refreshAccount = function () {

        registrationService.getLimits(function (license) {

            $scope.license = angular.copy(license);
            $scope.global.license = $scope.license;
            console.log('updated license', $scope.license);

            saveLicense();

            totangoService.sendStatus($scope.license.licenseType);

            $scope.applyLicense();

        }, function (error) {
            dialogs.alert.show(error || 'Cannot retrieve data. Please try again later. Error code: A-590.');
        });
    };

    var saveLicense = function () {
        //chrome.storage.sync.set({ 'license': $scope.license }, function () {
        chromeUtility.setField('license', $scope.license,

            function () {
                //NOTE: Dates(=objects) will be lost, that why we need ...MS properties
                if (debug) { console.log('license was saved to storage'); }
            },

            function (error) {
                console.log('ERROR: license was not saved to storage', error);
            }

        );
    };

    $scope.openStore = function () {
        storeService.open();
    };

    var getExportService = function () {
        var exportService = exportWrapperService.getService($scope.account.settings.target);
        if (debug) { console.log(debug + 'exportService', exportService); }
        return exportService;
    };

    $scope.openTargetLoginPage = function () {
        try {
            if (debug) { console.log(debug + 'openTargetLoginPage'); }
            var exportService = getExportService();
            exportService.login(null, null, false);
        } catch (e) {
            dialogs.alert.show(e.message);
        }
    };

    $scope.targetName = '';

    $scope.$watch('account.settings.target', function () {
        if (debug) { console.log(debug + 'WATCH: account.settings.target = ', $scope.account.settings.target); }
        $scope.targetName = '';
        try {
            $scope.targetName = getExportService().getName();
        } catch (e) { }
    });

    $scope.saveSettings = function () { // doNotSwitch, doNotBroadcast) {

        if (debug) { console.log(debug + 'Saving settings...', angular.copy($scope.account)); }

        $scope.editingTargets = false;

        //var notify = function () {

        //    if (!doNotSwitch) {
        //        $scope.showTab('searchmenu');
        //    }
        //    if (!doNotBroadcast) {
        //        mySharedService.broadcast('settings:', $scope.account.settings);
        //    }

        //};

        var o = { settings: $scope.account.settings };
        storageService.set(o,
            function () {

            }, function (error) {

            });

        /*chromeUtility.setField('account', $scope.account,

            // success
            function () {

                if (debug) { console.log('Settings were saved successfully.'); }

                notify();

            },

            // error
            function (error) {

                console.log('ERROR! Settings were not saved.', error);
                notify();

                if (error === 'QUOTA_BYTES_PER_ITEM quota exceeded') { //"QUOTA_BYTES_PER_ITEM quota exceeded"

                    console.log('**** QUOTA_BYTES_PER_ITEM quota exceeded error');

                    try {
                        // Compact settings
                        delete $scope.account.exportLimit;
                        delete $scope.account.exportCount;
                        delete $scope.account.last;
                        delete $scope.account.next;
                        delete $scope.account.exp;
                        delete $scope.account.date;
                    } catch (e) {
                        console.log('**** COMPACT error', e.message);
                    }

                    // Try to save again
                    //chrome.storage.sync.set({ 'account': $scope.account }, function () {
                    chromeUtility.setField('account', $scope.account,

                        // saved
                        function () {
                            if (debug) { console.log('Settings (compacted) were saved successfully.'); }
                        },

                        // not saved
                        function (error) {
                            console.log('ERROR! Settings were not saved again.', error, angular.copy($scope.account));
                        }

                    );
                }

            }

        );*/
    };

    $scope.quickCapture = function () {
        if (debug) { console.log('quickCapture'); }

        dialogs.busy.show('Capturing contacts...').cancel(function () { });
        captureService.autoCapture({}, function (contacts) {
            dialogs.busy.hide();
            if (contacts.length > 0) {
                contactUtility.addContacts(contacts, null, false);
                totangoService.sendEvent('capture', contacts.length);
            }
            if (!$scope.$$phase) { $scope.$apply(); }
        }, function (error) {
            dialogs.busy.hide();
            dialogs.alert.show(error);
            console.log(error);
        });


    };

    var fallbackCapture = function (options) {

        captureService.autoCapture(options, function (contacts) {
            dialogs.busy.hide();
            if (contacts.length > 0) {
                contactUtility.addContacts(contacts, null, false, { method: 'InternalParser' });
                totangoService.sendEvent('capture', contacts.length);
            }
            if (!$scope.$$phase) { $scope.$apply(); }
        }, function (error) {
            dialogs.busy.hide();
            dialogs.alert.show(error);
            console.log(error);
        });

    };

    var patternCapture = function (options) {

        dialogs.busy.show('Capturing contacts...');

        options = options || {};

        captureService.patternCapture(options, function (contacts) {


            var finish = function () {
                if (debug) { console.log('Capture completed'); }
                dialogs.busy.hide();
                if (contacts.length > 0) {
                    contactUtility.addContacts(contacts, null, false, { method: 'PatternEngine' });
                    totangoService.sendEvent('capture', contacts.length);
                }
                else {
                    fallbackCapture();
                }
                if (!$scope.$$phase) { $scope.$apply(); }
            };

            if (contacts.length !== 1) {
                finish();
            }
            else {
                finish();
            }

        }, function (error) {

            if (error === 'No pattern exists for this site.') {
                fallbackCapture();
            }
            else {
                dialogs.busy.hide();
                dialogs.alert.show(error);
                console.log(error);
            }
        });
    };

    $scope.patternCapture = function (clickEvent, options) {

        options = options || {};

        console.log('LICENSE', $scope.license);

        if (!$scope.license.subscribed) {
            dialogs.alert.show($scope.license.subStatus);
            return;
        }

        if (clickEvent && clickEvent.ctrlKey) {
            $scope.quickCapture();
            return;
        }

        var reloadPatterns = function () {

            var allPatterns = [];
            var last = false;

            var getPatternsCallback = function (patterns) {
                allPatterns = allPatterns.concat(patterns);
                if (last) {
                    patternStore.setPatterns(allPatterns);
                    options.patterns = allPatterns;
                    patternCapture(options);
                }
            };

            var sources = patternStore.getSources();

            if (!sources) {
                sources = patternStore.getDefaultSources();
                patternStore.setSources(sources);
            }

            var lastIndex = sources.length - 1;
            for (var index in sources) {
                last = parseInt(index) === lastIndex;
                patternStore.getFactoryPatterns(sources[index], getPatternsCallback);
            }
        };

        var isValidPattern = function (pattern) {

            if (!pattern)
            { return false; }

            var v = pattern.SchemaVersion;
            if (!v || !(v.length >= 2 && v[0] === '1' && v[1] === '.' && v[2] === '0'))
            { return false; }

            return true;
        };

        if (debug) { console.log('Pattern capture (new)'); }
        patternStore.getPatterns(function (patterns, ts) {

            var daysOld = 0;
            if (ts > 0) {
                var date1 = new Date();
                var date2 = ts;
                var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                daysOld = Math.ceil(timeDiff / (1000 * 3600 * 24));
            }

            if (!patterns) {
                patterns = [];
            }

            console.log('getPatterns', patterns.length, ts, daysOld);

            if (patterns.length > 0) {

                var invalidCount = 0;

                angular.forEach(patterns, function (pattern, index) {
                    if (!isValidPattern(pattern))
                    { invalidCount++; }
                });

                if (invalidCount > 0) {
                    if (invalidCount === patterns.length) {
                        reloadPatterns();
                        return;
                    }
                }
            }

            if (patterns.length === 0 || !ts || daysOld > 7) {

                dialogs.progress.hide();

                $timeout(function () {
                    reloadPatterns();
                }, 500);

                /*if (patterns.length > 0) {

                    $timeout(function () {
                        dialogs.confirm
                            .show('Patterns may be outdated. Load updated patterns?')
                            .confirm(
                                function () {
                                    $timeout(function () {
                                        reloadPatterns();
                                    }, 500);
                                }
                            )
                            .cancel(
                                function () {
                                    $timeout(function () {
                                        options.patterns = patterns;
                                        patternCapture(options);
                                    }, 500);
                                }
                            );
                    }, 500);

                } else {
                    //msg = 'No patterns exist. Load most common patterns?';

                    $timeout(function () {
                        reloadPatterns();
                    }, 500);

                }*/

            } else {
                options.patterns = patterns;
                patternCapture(options);
            }
        }, function (error) {
            dialogs.alert.show('An error occurred retrieving your patterns');
        });
    };


    $scope.checkNormalizationStatus = function () {

        if (debug) { console.log(debug + 'checkNormalizationStatus'); }

        shieldService.getNormalizationScheme(function (scheme) {
            if (debug) { console.log(debug + 'SCHEME', scheme); }
            userInfoStore.setShieldScheme(scheme);
        }, function (error) {
            console.log('ERROR in getNormalizationScheme', error);
        });

    };

    $scope.openPage = function (url) {

        var props = { url: url };
        var callback = function () { };
        var f = function (tabs) {
            if (!tabs || tabs.length === 0)
            { chrome.tabs.create(props, callback); }
            else
            { chrome.tabs.update(tabs[0].id, props, callback); }
        };

        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT }, f);
    };

    $scope.showUsage = function (usageType, usagePeriodFrom, usgaePeriodTo) {

        var url = '';

        //url = endpoints.accountService();

        $scope.openPage(url);
    };

    $scope.version = getVersion();

    $scope.global.version = $scope.version;

    $scope.openGuide = function () {

        // remove settings to force a reload
        bgService.setValue('settings', null);

        //$scope.openPage('http://localhost:7500/build/ContactCloud/#/login');
        $scope.openPage('https://account-staging.broadlook.com/CCF/ContactCloud/#/start');

    };

    $scope.hideMessage = function (messageId) {
        var i = $scope.license.messages.length;
        while (i--) {
            if ($scope.license.messages[i].id === messageId) {
                $scope.license.messages[i].hidden = true;
                saveLicense();
                break;
            }
        }
    };

    $scope.showMessages = function () {
        var i = $scope.license.messages.length;
        while (i--) {
            $scope.license.messages[i].hidden = false;
        }
        saveLicense();
    };

    $scope.reloadPatterns = function () {

        var getPatternsCallback = function (patterns, ts) {

            var daysOld = 0;
            if (ts > 0) {
                var date1 = new Date();
                var date2 = ts;
                var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                daysOld = Math.ceil(timeDiff / (1000 * 3600 * 24));
            }

            if (!patterns) {
                patterns = [];
            }

            console.log('Patterns > ', patterns.length, ' > TS > ',  ts, ' > Days Old > ', daysOld);

            if (patterns.length === 0 || !ts || daysOld > 3) {

                var allPatterns = [];

                var getPatternsCallback = function (patterns) {
                    allPatterns = allPatterns.concat(patterns);
                    patternStore.setPatterns(allPatterns);
                };

                var sources = patternStore.getSources();

                if (!sources) {
                    sources = patternStore.getDefaultSources();
                    patternStore.setSources(sources);
                }

                for (var index in sources) {
                    patternStore.getFactoryPatterns(sources[index], getPatternsCallback);
                }

            }
        };

        patternStore.getPatterns(getPatternsCallback);
      
    };

    /*
    var port = null;
    var init = function () {
        if(debug) { console.log('************** INIT *******************');}
        try {

            //port = chrome.runtime.connect();

            //console.log('************** SEND *******************');
            //port.postMessage({ App: angular.module('captureApp') });

        } catch (e) {
            console.log('************** ERROR *******************', e.message);
        }
    };

    init();
    */

};

'use strict';

/* global angular: false */
/* global salesforce: false */
/* jshint scripturl:true */
/* jshint bitwise:false */
/* global Pace:false */


//angular.module('captureApp')
//.controller('ContactController', ['$scope', 'jQuery', 'lodash', 'mySharedService', 'X2JS', '$timeout', '$location', '$anchorScroll', 'linkedinService', 'debugUtility', 'captureService', 'userInfoStore', 'multimerge.service', 'docSize', 'salesforce', 'dynamicsCrm', 'totangoService', 'contactUtility', 'dialogs', 'researchService', 'storageService', 'lookupService', 'bgService',
//ContactController.$inject = ['$scope', 'jQuery', 'lodash', 'mySharedService', 'X2JS', '$timeout', '$location', '$anchorScroll', 'linkedinService', 'debugUtility', 'captureService', 'userInfoStore', 'multimerge.service', 'docSize', 'salesforce', 'dynamicsCrm', 'totangoService', 'contactUtility', 'dialogs', 'researchService', 'storageService', 'lookupService', 'bgService'];
function ContactController($scope,
                           $q,
                           $,
                           _,
                           mySharedService,
                           X2JS,
                           $timeout,
                           $location,
                           $anchorScroll,
                           linkedinService,
                           debugUtility, captureService, userInfoStore, multimerge, docSize,
                           exportWrapperService,
                           totangoService, contactUtility, dialogs, researchService,
                           storageService, lookupService, limitService,
                           bgService, endpoints, environmentUtility,
                           shieldService,
                           broadlookExportService, chromeUtility, driveService, modals, storeService
                           ) {

    var debug = 'contact.ui.js->';
    //var debug = false;
    const consolePrefix = 'Capture > ';

    var composeErrorMessage = function (e, source) {

        var errorMessage = 'Unknown error';

        if (typeof e === 'string' && e.length > 0) {
            errorMessage = e;
        } else if (e && e.message && typeof e.message === 'string' && e.message.length > 0) {
            errorMessage = e.message;
        }

        var sourceName = (typeof source === 'string' && source.length > 0) ? (source + ' > ') : '';

        return consolePrefix + sourceName + errorMessage;
    };

    var showLoader = function () {
        try {
            Pace.restart();
        } catch (e) {

        }
    };

    $scope.saveError = null;

    $scope.filterText = '';
    $scope.filteredCount = 0;

    $scope.researchMode = researchService.modes.full;

    $scope.loading = false;
    $scope.showCompany = false;
    $scope.reload = false;
    $scope.canSee = false;
    $scope.tokens = 0;
    $scope.settings = {};
    $scope.targetConnected = false;
    $scope.runtime = {
        export: { active: false, done: 0, total: 0, progress: 0 },
        research: { active: false, done: 0, total: 0, progress: 0 },
        search: { active: false, done: 0, total: 0, progress: 0 }
    };
    //$scope.runtime = {
    //    export: { active: true, done: 5, total: 10, progress: 50 },
    //    research: { active: true, done: 9, total: 10, progress: 90 },
    //    search: { active: true, done: 1, total: 10, progress: 10 }
    //};

    function testLog(message) {
        return function (data) {
            console.log(message, data);
        };
    }


    var showError = function (error) {
        const functionName = 'Show Error';
        try {

            if (typeof error !== 'string') {
                console.error(consolePrefix + functionName + ' > Object as error message? ', error);
                if (error.message) {
                    error = error.message;
                }
            }

            if (error && error === 'Current user does not belong to an organization') {
                return;
            }

            dialogs.alert.show(error);

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.exportContacts = function (contacts) {
        //record in contact.links 
        //mergeDups(contact, record._type, record._id)
        if (!contacts || contacts.length === 0) {
            return;
        }
        var targets = angular.copy($scope.export.targets);
        targets.push({ label: 'CSV File', target: 'csv' });
        $q.when(targets)
            .then(modals.exportTargetSelector({ title: 'Export As' }))
            .then(function (target) {
                console.log('Export > ', target);
                $scope.save(contacts, target);
            });

    };

    var simplifyCurrency = function (value) {
        // $4999999 = $4,999,999 =$5M
        // $1000000 = $1,000,000 = $1M
        //if (!value) { return ''; }
        //value = value.trim();
        //if (value.indexOf('$') === 0) {
        //    value = value.substring(1);
        //}
        //var correction = 1;
        //if (value.indexOf('B') === (value.length - 1)) {
        //    value = value.substring(0, value.length - 1);
        //    correction = 1000000000;
        //}
        //if (value.indexOf('M') === (value.length - 1)) {
        //    value = value.substring(0, value.length - 1);
        //    correction = 1000000;
        //}
        //if (value.indexOf('K') === (value.length - 1)) {
        //    value = value.substring(0, value.length - 1);
        //    correction = 1000;
        //}
        //var num = parseInt(value);
        //console.warn(value, ' => ', num);
        //if (value[value.length - 1] === '9') {
        //    num++;
        //}
        //num *= correction;
        var num = contactUtility.parseCurrency(value);
        //if (num >= 1000000000) {
        //    num = Math.round(num / 1000000000);
        //    return '$' + num + 'B';
        //} else if (num >= 1000000) {
        //    num = Math.round(num / 1000000);
        //    return '$' + num + 'M';
        //} else if (num >= 1000) {
        //    num = Math.round(num / 1000);
        //    return '$' + num + 'K';
        //} else {
        //    return '$' + value;
        //}
        var str = contactUtility.formatCurrency(num);
        return str;

    };

    $scope.formatRevenue = function (revenue) {
        const functionName = 'Show Error';
        try {
            //$1000000 - $4999999
            if (revenue) {
                var separator = ' to ';
                if (revenue.indexOf(separator) < 0) {
                    separator = ' - ';
                }
                if (revenue.indexOf(separator) > 0) {
                    var low = revenue.substring(0, revenue.indexOf(separator));
                    var high = revenue.substring(revenue.indexOf(separator) + 3);
                    //console.log('Read revenue as [' + low + '] to [' + high + ']');
                    var numlow = contactUtility.parseCurrency(low);
                    var numhigh = contactUtility.parseCurrency(high);
                    numhigh = contactUtility.fixHighRange(numhigh, numlow);
                    low = contactUtility.formatCurrency(numlow);
                    high = contactUtility.formatCurrency(numhigh);
                    if (numlow >= 0 && numhigh > 0) {
                        revenue = low + ' to ' + high;
                    } else if (numhigh > 0) {
                        revenue = 'Over ' + high;
                    } else if (numlow > 0) {
                        revenue = 'Over ' + low;
                    }
                }
            }
        } catch (e) {
            console.error(composeErrorMessage(e, functionName), revenue);
        }
        return revenue;
    };

    $scope.select = function (contacts, preserveSelection, selectionValue) {
        const functionName = 'Select';
        try {
            if (debug) { console.log(consolePrefix + functionName, contacts); }

            // Clear selection
            if (!preserveSelection) {
                angular.forEach($scope.getDisplayedContacts(), function (contact) {
                    contact._selected = false;
                });
            }

            // New selection
            angular.forEach(contacts, function (contact, index) {
                angular.forEach($scope.getDisplayedContacts(), function (contact2) {
                    if (contact2.id === contact.id) {

                        if (typeof selectionValue !== 'undefined') {

                            if (selectionValue && selectionValue.invert) {
                                contact2._selected = !contact2._selected;
                            } else if (selectionValue && selectionValue.field) {
                                contact2._selected = contact2[selectionValue.field];
                            } else {
                                contact2._selected = selectionValue;
                            }

                        } else {
                            contact2._selected = true;
                        }

                        //contact2._selected = typeof selectionValue !== 'undefined' ? selectionValue : true;

                        // Do not select those that are in progress (?)
                        if (contact2._selected && contact._researchJobId) {
                            contact2._selected = false;
                        }
                    }
                });
            });

            $scope.saveHistory();

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.getResearchingCount = function () {
        var count = 0;
        angular.forEach($scope.contacts, function (contact) {
            if (contact._researchJobId) { count++; }
        });
        return count;
    };

    $scope.getSearchingCount = function () {
        var count = 0;
        angular.forEach($scope.contacts, function (contact) {
            if (contact._searching) { count++; }
        });
        return count;
    };

    $scope.getSavingCount = function () {
        var count = 0;
        angular.forEach($scope.contacts, function (contact) {
            if (contact._saving) { count++; }
        });
        return count;
    };

    $scope.getSelectionCount = function () {
        var count = 0;
        angular.forEach($scope.getDisplayedContacts(), function (contact) {
            if (contact._selected) { count++; }
        });
        return count;
    };

    $scope.hasSelectedContacts = function () {
        var cc = $scope.getDisplayedContacts();
        var i = cc.length;
        while (i--) {
            if (cc[i]._selected) { return true; }
            return false;
        }
    };

    $scope.getSelectedContacts = function () {
        var selected = [];
        angular.forEach($scope.getDisplayedContacts(), function (contact) {
            if (contact._selected) { selected.push(contact); }
        });
        return selected;
    };

    $scope.getDisplayedContacts = function () {
        // Updated to return all contacts from current list, not just from current page
        ////var temp = [];
        ////var i = $scope.pageOfFilteredContacts.length;
        ////while (i--) {
        ////    var c = $scope.pageOfFilteredContacts[i];
        ////    if (!c._hidden) {
        ////        temp.splice(0, 0, c);
        ////    }
        ////}
        ////return temp;
        //return $scope.pageOfFilteredContacts;
        return $scope.filteredContacts;
    };

    $scope.getExportTargetName = function (target) {
        const functionName = 'Get Export Target Name';
        try {
            var service = exportWrapperService.getService(target);
            if (!service) {
                return '';
            }

            var name = service.getName();
            return name;

        } catch (e) {
            console.error(composeErrorMessage(e, functionName), ' > Target > ', target);
            return null;
        }
    };

    $scope.openLink = function (url, currentTab) {
        const functionName = 'Open Page';
        try {
            if (debug) { console.log(consolePrefix + functionName + ' > Url > ', url, ' > Current Tab > ', currentTab); }

            if (url.indexOf('://') < 0)
            { url = 'https://' + url; }

            //if (currentTab) {
            //    window.location.href = url;
            //} else {
            //    window.open(url, '_new');
            //}
            chromeUtility.openLink(url, currentTab);

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.makeURL = function (link, http) {
        const functionName = 'Get URL';
        try {

            if (!link) { return link; }

            if (link.indexOf('://') < 0) {
                if (http) {
                    link = 'http://' + link;
                } else {
                    link = 'https://' + link;
                }
            }

            return link;

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.makeMapURL = function (contact) {
        const functionName = 'Get Map URL';
        try {

            var a = contactUtility.composeFullAddress(contact, ' ');
            var link = 'http://maps.google.com/?q=' + a;
            //console.log(functionName, link);
            return link;

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.showMap = function (contact) {
        const functionName = 'Show Map';
        try {

            var a = contactUtility.composeFullAddress(contact, ' ');
            var link = 'http://maps.google.com/?q=' + a;

            $scope.openLink(link);

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.export = {
        name: '',
        _exportService: null,
        targets: [],
        getExportService: function () {
            return $scope.export._exportService;
        },
        setExportService: function () {

            var target = $scope.settings.target;

            if (debug) { console.log(debug + 'Set export service as', target, 'settings=', angular.copy($scope.settings)); }

            $scope.export.name = '';
            $scope.export.targets = [];
            $scope.export._exportService = exportWrapperService.getService(target);

            if ($scope.export._exportService) {

                $scope.export.name = $scope.export._exportService.getName();

                if (target === 'ms') {
                    try {
                        if ($scope.settings.targetUrl) {
                            // old way
                            $scope.export._exportService.init({ url: $scope.settings.targetUrl });
                        }
                    } catch (e) {
                        console.log('*** ERROR in exportService.init.ms.oldWay', $scope.settings.targetUrl, e.message);
                    }
                }

                try {
                    $scope.export._exportService.init($scope.settings.targetParams[target]);
                } catch (e) {
                    console.log('*** ERROR in exportService.init', target, e.message);
                }

                try {

                    var map = null;
                    if ($scope.settings.targetMap) {
                        map = $scope.settings.targetMap[target];
                    }
                    if (map && map.entities && map.entities.length > 0) {
                        for (var i = 0; i < map.entities.length; i++) {
                            $scope.export.targets.push({ label: $scope.export.name + ' ' + map.entities[i].label, target: map.entities[i].name });
                        }
                    } else {
                        if (target === 'ms') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Lead', target: 'lead' });
                            $scope.export.targets.push({ label: $scope.export.name + ' Contact', target: 'contact' });
                        } else if (target === 'sf') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Lead', target: 'lead' });
                            $scope.export.targets.push({ label: $scope.export.name + ' Contact', target: 'contact' });
                        } else if (target === 'sl') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Contact', target: 'contact' });
                        } else if (target === 'pc') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Candidate', target: 'contact' });
                        } else if (target === 'pp') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Contact', target: 'contact' });
                        } else if (target === 'zh') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Lead', target: 'lead' });
                            $scope.export.targets.push({ label: $scope.export.name + ' Contact', target: 'contact' });
                        } else if (target === 'mk') {
                            $scope.export.targets.push({ label: $scope.export.name + ' Contact', target: 'contact' });
                        }


                    }

                } catch (e) {
                    console.log('*** ERROR in exportService.targets', target, e.message);
                }

                $scope.export._exportService.isLoggedIn(function () {
                    mySharedService.broadcast('runtime:loggedin:1');
                    $scope.targetConnected = true;
                }, function () {
                    mySharedService.broadcast('runtime:loggedin:');
                    $scope.targetConnected = false;
                });
            }
        }

    };

    $scope.max = 1000;
    $scope.limitreached = false;
    $scope.saveTimeout = null;
    $scope.saveMarkTimeout = null;

    $scope.markAll = 'All';
    $scope.markDefault = 'Default';
    $scope.markNew = '';
    $scope.activeMark = $scope.markAll;
    $scope.marks = [$scope.markDefault];

    $scope.company = {
        show: false,
        name: 'test'
    }; // Optional, Profiler only

    $scope._contacts = [];

    $scope.contacts =
        function () {
            var cc = bgService.getValue('contacts');
            if (typeof cc === 'undefined') {
                bgService.setValue('contacts', $scope._contacts);
            } else { $scope._contacts = cc; }
            return $scope._contacts;
        };

    //debugUtility.addLoggingProperties($scope);
    //$scope.logLevel = $scope.LOG_LEVEL_ALL;

    //var consolelog = function (msg, value) {
    //    //var args = Array.prototype.slice.call(arguments);
    //    //args = args.slice(1);

    //    if (debug) { console.log(msg, value); }
    //}

    $scope.lastCaptureState = { show: false };
    $scope.hideState = function () {
        $scope.lastCaptureState.show = false;
    };

    $scope.refresh = function () {
        if (!$scope.$$phase) { $scope.$apply(); }
    };

    //$scope.$on('$destroy', function () {
    //    $scope._contacts = null;
    //    $(window).off('resize.Viewport');
    //});

    $scope.$on('handleBroadcast', function () {

        var msg = mySharedService.message;

        //console.log('broadcast received', angular.copy(msg));

        if (msg.indexOf('sitekey:') === 0) {
            //$scope.sitekey = msg.substring(8);
            //$scope.loadHistory();
        }
        else if (msg.indexOf('crmid:') === 0) {
            //$scope.crmid = msg.substring(6);
        }
        else if (msg.indexOf('uid:') === 0) {
            //$scope.uid = msg.substring(4);
        }
        else if (msg.indexOf('schema:') === 0) {
            //$scope.schema = msg.substring(7);
        }
        else if (msg.indexOf('contact:') === 0) {

            if (msg.indexOf(':hide') > 0)
            { $scope.canSee = false; }
            else if (msg.indexOf(':show') > 0)
            { $scope.canSee = true; }

        }
        else if (msg.indexOf('contactTokens:') === 0) {
            $scope.tokens = msg.substring(msg.indexOf(':') + 1);
        }
        else if (msg.indexOf('licenseType:') === 0) {
            var licenseType = msg.substring(msg.indexOf(':') + 1);
            if (licenseType === 'Bulk')
            { $scope.researchMode = researchService.modes.limited; }
            else
            { $scope.researchMode = researchService.modes.full; }
        }
        else if (msg === 'settings:') {
            $scope.settings = angular.copy(mySharedService.params);
            $scope.export.setExportService();
        }
        else if (msg === 'login') {

        }
        else if (msg === 'logout') {
            $scope.canSee = false;
        }
    });

    $scope.getSocialVenu = function (url) {
        return contactUtility.parseSocialVenu(url);
    };

    $scope.getSocialVenueClassName = function (venue) {
        const functionName = 'Get Social Venue';
        try {
            var venueName = contactUtility.parseSocialVenu(venue.website);
            return venueName;
        } catch (e) {
            console.error(composeErrorMessage(e, functionName), ' > Venue > ', venue);
            return null;
        }
    };

    $scope.$on('handleContactsBroadcast', function () {

        if (debug) { console.log('handleContactsBroadcast received', mySharedService); }

        $scope.reload = mySharedService.flags && mySharedService.flags.reload;
        if (!$scope.$$phase) { $scope.$apply(); }

        if (!mySharedService.flags.append || !$scope.contacts)
        { $scope.contacts = []; }

        if (debug) { console.log('Action:addContacts Caller:handleContactsBroadcast'); }
        $scope.addContacts(mySharedService.contacts, mySharedService.flags.company);

    });

    $scope.addContacts = function (newContacts, company, silent, details, successCallback, failCallback) {

        if (debug) { console.log(debug + 'addContacts', newContacts, company, silent); }

        var completed = false;
        //var loadingVisible = false;
        //var loadingPromise = null;

        //if (!silent) {
        //    loadingPromise = $timeout(function () {
        //        if (!completed) {
        //            //dialogs.busy.show('Loading...');
        //            loadingVisible = true;
        //        }
        //    }, 500);
        //}

        if (silent) { mySharedService.broadcast('tab:contact'); }

        var i;
        var skippedContacts = [];
        var state = { incoming: newContacts.length, added: 0, excluded: 0, merged: 0, overlimit: 0, noname: 0 };

        if (details)
        { state.method = details.method; }

        if (!newContacts) { newContacts = []; }

        i = newContacts.length;
        while (i--) {
            if (!newContacts[i].last || !newContacts[i].first) {
                skippedContacts.push(angular.copy(newContacts[i]));
                newContacts.splice(i, 1);
                state.noname++;
            } else {
                contactUtility.sortVenues(newContacts[i]);
            }
        }

        //check excluded & dedupe incoming
        //if (debug) { console.log(debug + 'silent', silent); }
        if (!silent) {
            i = newContacts.length;
            //if (debug) { console.log(debug + 'i=', angular.copy(i)); }
            while (i--) {
                var cnt = newContacts[i];
                //if (debug) { console.log(debug + 'check', angular.copy(cnt)); }

                var skip = $scope.shouldExclude(cnt);
                if (skip) {
                    if (debug) { console.log(debug + 'skip', angular.copy(cnt)); }
                    skippedContacts.push(angular.copy(cnt));
                    newContacts.splice(i, 1);
                    state.excluded++;
                }
                else {
                    var dup = $scope.duplicateByName(cnt, newContacts, i);
                    if (dup) {
                        if (debug) { console.log(debug + 'dup', angular.copy(cnt)); }
                        skippedContacts.push(angular.copy(cnt));
                        $scope.merge(dup, cnt);
                        newContacts.splice(i, 1);
                        state.merged++;
                    }
                }
            }

        }

        if (debug) {
            if (skippedContacts.length > 0)
            { console.log(debug + 'skipped->noNameOrExcludedOrDuplicate', skippedContacts); }
        }

        var getNewId = function () {
            var max = 0;
            if ($scope.contacts) {
                var i = $scope.contacts.length;
                while (i--)
                { if (max < $scope.contacts[i].id) { max = $scope.contacts[i].id; } }
            }
            return max + 1;
        };

        var focusOn = null;
        var focusOnID = null;
        var manuallyFilledWebsite = false;

        var addContactsInternal = function (allowDups) {

            if (debug) { console.log(debug + 'addContacts->add', angular.copy(newContacts)); }

            //un-new
            var i = $scope.contacts.length;
            while (i--)
            { $scope.contacts[i]._new = false; }

            $scope.limitreached = $scope.contacts >= $scope.max;
            var first = true;

            var selectedMark = $scope.activeMark;
            if (selectedMark === $scope.markAll) { selectedMark = $scope.markDefault; }

            var nextIndex = 0;
            var contactsToResearch = [];
            var contactsToLookupWebsite = [];

            angular.forEach(newContacts, function (cnt, i) {

                if (!cnt.id)
                { cnt.id = getNewId(); }

                if (!cnt.mark) { cnt.mark = selectedMark; }

                contactUtility.sortVenues(cnt);

                var dup = false;

                if (!(silent || allowDups))
                { dup = $scope.duplicateOf(cnt); }

                if (dup) {
                    $scope.merge(dup, cnt);
                    cnt = dup;
                    cnt._collapsed = false; // Expand dup
                    state.merged++;
                }
                else {

                    if ($scope.contacts.length >= $scope.max) {
                        $scope.limitreached = true;
                        skippedContacts.push(angular.copy(cnt));
                        cnt = null;
                        state.overlimit++;
                    }
                    else { $scope.contacts.splice(nextIndex, 0, cnt); nextIndex++; state.added++; }
                }

                if (first && cnt) {
                    focusOn = cnt.id;
                    //var z = $scope.contacts.length;
                    //while (z--) { if ($scope.contacts[z].id === cnt.id) { focusOn = z; focusOnID = cnt.id; break; } }

                    //search for dups - the first one only
                    if (!silent) {
                        $timeout(function () {
                            console.warn('Searching fo dups');
                            $scope.findDups([cnt]);
                        }, 1000);
                    }

                    first = false;
                }

                if (cnt) {
                    if (cnt._researchJobId === 0)
                    { contactsToResearch.push(cnt); }
                    else if (cnt._researchJobId) {
                        getResearchStatusCount++;
                        getResearchStatus(cnt);
                    } else {
                        contactsToLookupWebsite.push(cnt);
                    }
                }

            });

            if (contactsToResearch.length > 0) {
                $timeout(function () {
                    $scope.researchContacts(contactsToResearch, true);
                }, 3000);
            }

            if (!silent && !manuallyFilledWebsite && contactsToLookupWebsite.length > 0) {
                $timeout(function () {
                    fillWebsites(contactsToLookupWebsite);
                }, 3000);
            }

            $scope.showMark($scope.activeMark);

            finish();
        };

        var focus = function () {
            if (debug) { console.log('Focus on > ID > ', focusOn); }
            if (focusOn !== null) {

                var pageIndex = getPageIndex(focusOn);
                if (pageIndex < 0) {
                    console.warn('Cannot focus');
                    return;
                }

                $scope.setCurrentPage(pageIndex);

                $timeout(function () {
                    //var adjustment = -300;
                    //while (focusOn >= 0) {
                    var element = document.getElementById('contact_id_' + focusOn);
                    if (element) {
                        if (debug) { console.log(debug + 'Scroll To ID > ', focusOn, ' Offset > ', element.offsetTop); }
                        document.getElementById('scrollArea').scrollTop = element.offsetTop;
                        //window.scrollTo(0, element.offsetTop + adjustment);
                        focusOn = -1;
                        //} else {
                        // html is not updated yet -> scroll to the last visible
                        //focusOn--;
                        //adjustment = 400;
                        //if (debug) { console.log(debug + 'addContacts->scrollTo->adjusted', focusOn); }
                    }
                    //}
                }, 2000);
            }

        };

        var finish = function (cancelled) {

            $scope.updateMarks();

            if (!silent)
            { $scope.saveHistory(); }

            mySharedService.broadcast('runtime:contactsCount:' + $scope.contacts.length);

            if (debug) { console.log(debug + 'addContacts->finish', state); }

            if (!cancelled && (!silent || state.added < state.incoming)) {
                $scope.lastCaptureState.state = state;
                $scope.lastCaptureState.show = true;

                $timeout(function () {
                    $scope.hideState();
                }, 10000);
            }
            else { $scope.lastCaptureState.show = false; }

            completed = true;
            if (!silent) {

                //if (loadingPromise) {
                //    $timeout.cancel(loadingPromise);
                //    loadingPromise = null;
                //    loadingVisible = true;
                //}

                //if (loadingVisible) {
                //    dialogs.busy.hide();
                //}

                if (($scope.contacts.length - state.added) < 3) {
                    // No scrolling bug remedy:
                    // Refresh page if there were less than two cards
                    $scope.pageOfFilteredContacts = [];

                    var currentMark = $scope.activeMark;

                    $timeout(function () {
                        console.log('******** REFRESH LIST ', currentMark);
                        $scope.showMark(currentMark);
                    }, 500);
                }

                $scope.refresh();
            }

            $timeout(function () {
                if (debug) { console.log(debug + 'focus timeout'); }
                focus();
            }, 500);

            if (!cancelled) {
                try { successCallback(); } catch (e) { }
            } else {
                try { failCallback(); } catch (e) { }
            }

        };

        var getAllCompanyNames = function (contacts) {
            var companies = [];

            var i = 0;
            while (i < contacts.length) {
                var comp = contacts[i].company;
                if (comp)
                { companies.push(comp); }
                i++;
            }

            return companies;
        };

        var getDistinctItems = function (allItems) {
            var items = [];
            var i = 0;
            while (i < allItems.length) {
                var item = allItems[i];
                if (item && items.indexOf(item) < 0)
                { items.push(item); }
                i++;
            }
            return items;
        };

        var getMostCommon = function (allItems) {

            var frequencies = {};
            var maxFrequency = 0;
            var minFrequency = 0.51 * allItems.length; //0.25;
            var mostCommonItem = '';

            var i = allItems.length;
            while (i--) {
                var item = allItems[i];
                if (item) {
                    if (!frequencies[item]) { frequencies[item] = 1; }
                    else { frequencies[item] = parseInt(frequencies[item]) + 1; }
                    if (maxFrequency < parseInt(frequencies[item]) && minFrequency <= parseInt(frequencies[item])) {
                        maxFrequency = parseInt(frequencies[item]);
                        mostCommonItem = item;
                    }
                }
            }


            return mostCommonItem;
        };

        var getAllCompanyUrls = function (contacts) {
            var domains = [];
            if (contacts) {
                var i = 0;
                while (i < contacts.length) {
                    var www = contacts[i].website || contacts[i].sourceurl;
                    if (www) {
                        var domain = contactUtility.getDomain(www);
                        if (domain) {
                            if (!contactUtility.isBlacklistedDomain(domain) && contactUtility.isAboutPage(www))
                            { domains.push(domain); }
                        }
                    }
                    i++;
                }
            }
            return domains;
        };


        var companyNames = getAllCompanyNames(newContacts);
        var companyName = getMostCommon(companyNames);
        companyNames = getDistinctItems(companyNames);

        var companyUrls = getAllCompanyUrls(newContacts);
        var companyURL = getMostCommon(companyUrls);
        companyUrls = getDistinctItems(companyUrls);

        //if (debug) { console.log(debug + 'getCompanyNamesAndUrls', companyNames, companyName, companyUrls, companyURL); }

        var showDialog2 = function () {

            var newList = '<New List>';
            var marks = angular.copy($scope.marks);
            marks.push(newList);
            marks.unshift($scope.markDefault);
            var selectedMark = $scope.activeMark;
            if (selectedMark === $scope.markAll) { selectedMark = $scope.markDefault; }
            var sameCompany = companyName !== '' || companyURL !== '';

            dialogs.capture.list
                .show({
                    //message: '' + newContacts.length + ' contacts were captured!  Select target list:',
                    message: '' + newContacts.length + ' contacts were found!',
                    options: marks,
                    selected: selectedMark,
                    sameCompany: sameCompany,
                    companyName: companyName,
                    companyNames: companyNames,
                    companyURL: companyURL
                })
                .cancel(function () {
                    finish(true);
                })
                .ok(function (response) { // list
                    var list = response.option;

                    //  If user asked for data override, do it here
                    if (response.companyName || response.companyURL) {
                        var override = contactUtility.createNewContact();
                        override.company = response.companyName;
                        override.website = response.companyURL;
                        contactUtility.applyOverrides(newContacts, override);
                    }

                    if (debug) { console.log(debug + 'setList->' + list); }
                    var i = newContacts.length;
                    while (i--) {
                        newContacts[i].mark = list;
                    }
                    $scope.activeMark = list;

                    if (response.companyName && response.companyURL) {
                        if (debug) { console.log(debug + 'log->' + response.companyName + '<==>' + response.companyURL); }
                        manuallyFilledWebsite = true;
                        lookupService.logCompanyWebsite(response.companyName, response.companyURL);
                    }

                    if (debug) { console.log(debug + 'addContacts'); }
                    addContactsInternal(!response.mergeDups);

                });
        };

        var showDialog = function () {
            if (debug) { console.log(debug + 'showDialog'); }

            //if (loadingPromise) {
            //    $timeout.cancel(loadingPromise);
            //    loadingPromise = null;
            //}

            //if (loadingVisible) {
            //    dialogs.busy.hide();
            //}

            //dialogs.busy.hide();
            $timeout(function () { showDialog2(); }, 900);
        };

        if (newContacts.length === 1 || silent) {
            if (!silent) {
                var index = newContacts.length;
                while (index--) {
                    if (!silent || !newContacts[index].mark) { newContacts[index].mark = $scope.activeMark; }
                    if (newContacts[index].mark === $scope.markAll) { newContacts[index].mark = $scope.markDefault; }
                }
            }
            var allowDups1 = false || silent;
            addContactsInternal(allowDups1);
        }
        else if (newContacts.length > 1) {

            if (companyURL) {

                var companyNameBackup = companyName;
                if (debug) { console.log(debug + 'getCompanyNames->' + companyURL); }

                lookupService.lookupCompanyName(companyURL, function (lookupResult) {
                    if (lookupResult && lookupResult.results && lookupResult.results.length > 0) {
                        companyName = lookupResult.results[0].Name;
                        companyNames = [];
                        angular.forEach(lookupResult.results, function (result, index) {
                            companyNames.push(result.Name);
                        });
                    }
                    showDialog();
                },
                    showDialog
                );
            }
            else { showDialog(); }
        } else {
            finish();
            //completed = true;
        }

    };

    $scope.shouldExclude = function (cnt) {

        var xx, l, x, k,
            skip = false;

        if ($scope.settings) {
            if ($scope.settings.exclusions) {

                //if (debug) console.log('Exclusions are ON');

                if ($scope.settings.excludedNames) {
                    xx = $scope.settings.excludedNames.split(',');
                    k = xx.length;
                    while (k--) {
                        x = (xx[k] === null ? '' : xx[k]).trim().toLowerCase();
                        if (!x) { continue; }
                        if (cnt.last && cnt.last.toLowerCase() === x) {
                            if (debug) { console.log('exclusion by last name', x); }
                            skip = true; break;
                        }
                        if (cnt.first && cnt.first.toLowerCase() === x) {
                            if (debug) { console.log('exclusion by first name', x); }
                            skip = true; break;
                        }
                    }
                }

                if ($scope.settings.excludedEmails) {
                    xx = $scope.settings.excludedEmails.split(',');
                    k = xx.length;
                    while (k--) {
                        x = (xx[k] === null ? '' : xx[k]).trim().toLowerCase();
                        if (!x) { continue; }
                        if (cnt.email && cnt.email.toLowerCase().indexOf(x) >= 0) {
                            if (debug) { console.log('exclusion by email', x); }

                            skip = true; break;
                        }
                    }
                }

                if ($scope.settings.excludedPhones) {
                    xx = $scope.settings.excludedPhones.split(',');
                    k = xx.length;
                    while (k--) {
                        x = (xx[k] === null ? '' : xx[k]).trim().toLowerCase().replace(/[^0-9]/gi, '');
                        if (!x) { continue; }
                        if (cnt.phone && cnt.phone.toLowerCase().replace(/[^0-9]/gi, '').indexOf(x) >= 0) {
                            if (debug) { console.log('exclusion by phone', x); }
                            skip = true; break;
                        }
                        if (cnt.phone2 && cnt.phone2.toLowerCase().replace(/[^0-9]/gi, '').indexOf(x) >= 0) {
                            if (debug) { console.log('exclusion by phone2', x); }
                            skip = true; break;
                        }
                    }
                }

                if ($scope.settings.excludedCompanies) {
                    xx = $scope.settings.excludedCompanies.split(',');
                    k = xx.length;
                    while (k--) {
                        x = (xx[k] === null ? '' : xx[k]).trim().toLowerCase().replace(/[^0-9a-z]/gi, '');
                        if (!x) { continue; }
                        if (cnt.company && cnt.company.toLowerCase().replace(/[^0-9a-z]/gi, '').indexOf(x) >= 0) {
                            if (debug) { console.log('exclusion by company', x); }
                            skip = true; break;
                        }
                    }
                }

            }
            else {
                //if (debug) console.log('Exclusions are OFF');
            }
        }
        else {
            if (debug) { console.log('NO Settings!'); }
        }

        return skip;
    };

    $scope.duplicateOf = function (candidate) {

        return contactUtility.duplicateOf(candidate, $scope.contacts);

        //var i, j, contact,
        //    p1, p2, s1, s2,
        //    dup = null;

        //var testUrls = function (url1, url2) {

        //    // For known sites with individual profiles
        //    if (linkedinService.isIndividualProfile(url1) && linkedinService.isIndividualProfile(candidate.sourceurl)) {

        //        p1 = url1.indexOf('.com');
        //        p2 = url2.indexOf('.com');

        //        if (p1 > 0 && p2 > 0) {

        //            s1 = url1.substring(p1);
        //            s2 = url2.substring(p2);

        //            if (s1.length > 9 && s1 === s2)
        //            { return true; }

        //        } else {

        //            s1 = url1;
        //            s2 = url2;

        //            if (s1.length > 9 && s2.length > 9 && (s1.indexOf(s2) >= 0 || s2.indexOf(s1) >= 0))
        //            { return true; }

        //        }

        //    }

        //    return false;
        //};

        //for (i = 0; i < $scope.contacts.length; i++) {

        //    contact = $scope.contacts[i];

        //    if (contact.id > 0 && contact.id === candidate.id) { continue; }

        //    if (contact.last && contact.first && candidate.last && candidate.first) {

        //        if (candidate.last === contact.last && contactUtility.isTheSameFirstName(candidate.first, contact.first)) {

        //            if ((candidate.email && candidate.email === contact.email) ||
        //                (candidate.email2 && candidate.email2 === contact.email) ||
        //                (candidate.email && candidate.email === contact.email2) ||
        //                (candidate.email2 && candidate.email2 === contact.email2) ||
        //                (candidate.phone && candidate.phone === contact.phone) ||
        //                (candidate.phone2 && candidate.phone2 === contact.phone) ||
        //                (candidate.phone && candidate.phone === contact.phone2) ||
        //                (candidate.phone2 && candidate.phone2 === contact.phone2) ||
        //                (candidate.website && candidate.website === contact.website) ||
        //                (candidate.company && candidate.company === contact.company) ||
        //                (candidate.title && candidate.title === contact.title) ||
        //                (!(candidate.email || candidate.email2 || candidate.phone || candidate.phone2 || candidate.website || candidate.company || candidate.title))
        //                ) {

        //                dup = contact;
        //                if(debug) { console.log('dup! (1)', $.extend({}, contact), $.extend({}, candidate)); }
        //                break;
        //            }
        //        }
        //    }

        //    if (!dup && ((contact.sourceurl || contact.venues) && (candidate.sourceurl || candidate.venues))) {

        //        var l1 = [];
        //        var l2 = [];

        //        if (contact.sourceurl) { l1.push(contact.sourceurl); }
        //        if (contact.venues) {
        //            j = contact.venues.length;
        //            while (j--)
        //            { l1.push(contact.venues[j].website); }
        //        }

        //        if (candidate.sourceurl) { l2.push(candidate.sourceurl); }
        //        if (candidate.venues) {
        //            j = candidate.venues.length;
        //            while (j--)
        //            { l2.push(candidate.venues[j].website); }
        //        }

        //        for (var i1 = 0; i1 < l1.length; i1++) {
        //            for (var i2 = 0; i2 < l2.length; i2++) {
        //                if (testUrls(l1[i1], l2[i2])) {
        //                    dup = contact;
        //                    if(debug) { console.log('dup! (2)', $.extend({}, contact), $.extend({}, candidate)); }
        //                    break;
        //                }
        //            }
        //            if (dup)
        //            { break; }
        //        }

        //    }

        //}

        //return dup;
    };

    $scope.duplicateByName = function (candidate, contacts, index) {

        var i, contact, dup = null;

        for (i = 0; i < contacts.length; i++) {

            if (i === index) { continue; }

            contact = contacts[i];

            if (contact.id > 0 && contact.id === candidate.id) { continue; }

            if (contact.last && contact.first && candidate.last && candidate.first) {

                if (candidate.last === contact.last && contactUtility.isTheSameFirstName(candidate.first, contact.first)) {
                    dup = contact;
                    //console.log('dup! (1)', $.extend({}, contact), $.extend({}, candidate));
                    break;
                }
            }
        }

        return dup;
    };

    $scope.merge = function (survivor, merged) {

        //if (debug) { console.log('merging', angular.copy(survivor), angular.copy(merged)); }

        if (merged.last) { survivor.last = merged.last; }
        if (merged.middle) { survivor.middle = merged.middle; }
        if (merged.first) { survivor.first = merged.first; }

        if (merged.phone) { survivor.phone = merged.phone; }
        if (merged.phone2) { survivor.phone2 = merged.phone2; }

        if (merged.jobtitle) { survivor.jobtitle = merged.jobtitle; }
        if (merged.email) { survivor.email = merged.email; }
        if (merged.email2) { survivor.email2 = merged.email2; }
        if (merged.bio) { survivor.bio = merged.bio; }
        if (merged.experience) { survivor.experience = merged.experience; }
        if (merged.education) { survivor.education = merged.education; }
        if (merged.company) { survivor.company = merged.company; }
        if (merged.website) { survivor.website = merged.website; }

        if (merged.state && survivor.state && merged.state !== survivor.state) {
            survivor.address1 = '';
            survivor.address2 = '';
            survivor.city = '';
            survivor.zip = '';
            survivor.state = '';
            survivor.country = '';
        }

        if (merged.address1) { survivor.address1 = merged.address1; }
        if (merged.address2) { survivor.address2 = merged.address2; }
        if (merged.city) { survivor.city = merged.city; }
        if (merged.zip) { survivor.zip = merged.zip; }
        if (merged.state) { survivor.state = merged.state; }
        if (merged.country) { survivor.country = merged.country; }

        if (merged.flags) { survivor.flags = merged.flags; }
        if (merged.mark) { survivor.mark = merged.mark; }
        if (merged.emailver) { survivor.emailver = merged.emailver; }
        if (merged.emailver2) { survivor.emailver2 = merged.emailver2; }
        if (merged.email2ver) { survivor.email2ver = merged.email2ver; }
        if (merged.email2ver2) { survivor.email2ver2 = merged.email2ver2; }

        if (merged.venues) {
            for (var vi = 0; vi < merged.venues.length; vi++)
            { $scope.addVenue(survivor, merged.venues[vi]); }
        }

        survivor._diveable = merged._diveable;

        survivor._searched = false;
        survivor._new = true;

        //if (merged._researchJob) { survivor._researchJob = merged._researchJob; }
        if (merged._researchJobId) { survivor._researchJobId = merged._researchJobId; }

        //if (debug) { console.log('merged', survivor); }

        //$scope.updateMarks();

        //console.log('dup mark=', survivor.mark, ' active mark=', $scope.activeMark);
        if (survivor.mark !== $scope.activeMark && $scope.activeMark !== $scope.markAll) { $scope.showMark($scope.markAll); }

    };

    $scope.saveMark = function () {

        clearTimeout($scope.saveMarkTimeout);

        $scope.saveMarkTimeout = setTimeout(function () {

            var o = {};
            o.mark = $scope.activeMark;

            if (debug) { console.log(debug + 'saving active mark', $scope.activeMark); }

            var alreadySaved = false;
            if (bgService) {
                var oldValue = bgService.getValue('mark');
                alreadySaved = oldValue === o.mark;
                bgService.setValue('mark', $scope.activeMark);
            }

            if (!alreadySaved)
            { storageService.set(o, function () { }, function (error) { console.log('mark was not saved', error); }); }

        }, 200);

    };

    $scope.saveHistory = function (callback) {

        clearTimeout($scope.saveTimeout);

        var o = {};

        var i = $scope.max;
        while (i--) {
            o[i] = null;
        }

        i = $scope.contacts.length;
        o.count = i;
        o.mark = $scope.activeMark;
        o.marks = $scope.marks;

        bgService.setValue('count', o.count);
        bgService.setValue('mark', o.mark);
        bgService.setValue('marks', o.marks);

        $scope.saveTimeout = setTimeout(function () {

            if (debug) { console.log(debug + 'saving history'); }

            while (i--) {

                o[i] = angular.copy($scope.contacts[i]);

                if (!o[i].c || typeof o[i].c.getTime === 'undefined') {
                    o[i].c = new Date();
                }


                // encode date to MS
                o[i].c2 = o[i].c.getTime();
                delete o[i]._searching;
                delete o[i]._saving;
                delete o[i]._editing;
                delete o[i]._enhancing;
                delete o[i]._createdon;
                delete o[i]._createdonMS;
                delete o[i].c;

                for (var prop in o[i]) {
                    if (o[i][prop] === null || o[i][prop] === '') {
                        delete o[i][prop];
                    }
                }

                bgService.setValue(i, o[i]);
            }

            //limit is 102,400
            if (debug) { console.log('saving bytes ', JSON.stringify(o).length); }

            console.log('****** saving to storage');

            storageService.set(o, function () {
                if (debug) { console.log('saved to storage'); }
                $scope.saveError = false;
                if (callback) { callback(); }
            }, function (error) {
                console.log('ERROR: not saved to storage', error);
                if (error) { $scope.saveError = error.message; }
                if (!$scope.saveError) { $scope.saveError = 'Broadlook Storage is not accessible.'; }
                if (!$scope.$$phase) { $scope.$apply(); }
                if (callback) { callback(); }
            });


        }, 200); // wait .2 sec


    };

    var pageData = null;

    $scope.loadHistory = function (callback) {

        if (debug) { console.log('load history'); }

        $scope.loading = true;
        $scope.contacts = [];



        var oldWay = function () {

            //chrome.storage.sync.get(['count', 'mark', 'marks'], function (value) {
            chromeUtility.getField(['count', 'mark', 'marks'], function (value) {

                if (debug) { console.log('loaded from Google storage', value); }

                var c = value.count;
                var m = value.mark;
                if (debug) { console.log('count of loaded contacts=', c, 'active mark=', m); }

                if (m)
                { $scope.showMark(m); }

                if (value.marks)
                { $scope.marks = value.marks; }

                $scope.updateMarks();

                var i = c;
                var keys = []; while (i--) { keys.push('' + i); }

                //chrome.storage.sync.get(keys, function (values) {
                chromeUtility.getField(keys, function (values) {
                    if (debug) { console.log('loaded contacts (from Google storage)'); }
                    var i = c;
                    var cc = [];
                    while (i--) {
                        if (values[i]) {

                            if (values[i].c2) { // restore date time
                                values[i].c = (new Date()).setTime(values[i].c2);
                            }

                            cc.unshift(values[i]);
                        }
                    }

                    if (debug) { console.log('Action:addContacts Caller:loadHistory'); }
                    $scope.addContacts(cc, null, true, { method: 'GoogleStorage' });

                });

            });
        };


        var loadPageData = function () {

            pageData = bgService.getValue('pageData');
            var errorMessage = null;
            //if (debug) { console.log(debug + 'BG page data', angular.copy(pageData)); }

            var finish = function () {
                dialogs.busy.hide();
                if (errorMessage) {
                    $timeout(function () {
                        dialogs.alert.show(errorMessage);
                    }, 500);
                }
                $scope.loading = false;
                $scope.refresh();
                restorePosition();
                initPositionChangeWatcher();
            };
            var cleanBadge = function () {
                pageData = [];
                bgService.setValue('pageData', pageData);
                chrome.browserAction.setBadgeText({ text: '' });
                if (debug) { console.log(debug + 'Badge cleaned'); }
                finish();
            };

            if (pageData && pageData.length > 0) {

                if (debug) { console.log(debug + 'Loaded new contacts (from background page)', angular.copy(pageData)); }

                // Show progress
                //dialogs.busy.show('Loading new contacts...');
                $scope.refresh();

                var loadNewContacts = function () {

                    var i = 0;
                    var addedContacts = [];

                    var patternCaptureSuccess = function (contacts) {

                        if (debug) { console.log(debug + 'patternCaptureSuccess', angular.copy(i)); }
                        addedContacts = addedContacts.concat(contacts);
                        if (i < (pageData.length - 1)) {
                            return;
                        }

                        if (debug) {
                            console.log(debug + 'patternCaptureSuccess->last', angular.copy(addedContacts), angular.copy(i));
                        }

                        $timeout(function () {
                            console.log('Adding new contacts');

                            $scope.addContacts(addedContacts, null, false, { method: 'PatternEngine' },

                                // success callback
                                function () {
                                    console.log('New contacts added successfully');
                                    cleanBadge();
                                },

                                //cancel callback
                                function () {
                                    console.log('***** New contacts were discarded (Cancelled by user) ******');
                                    cleanBadge();
                                }

                            ); // not silent! -> oterwise dups are going in

                        }, 500);

                    };

                    var patternCaptureFail = function (error) {
                        console.log('ERROR in patternCaptureFail', error);
                        errorMessage = error || errorMessage;
                        if (i < (pageData.length - 1)) {
                            return;
                        }
                        cleanBadge();
                    };

                    for (i = 0; i < pageData.length; i++) {
                        var data = angular.copy(pageData[i].data);
                        var sourceUrl = angular.copy(pageData[i].sourceUrl);
                        if (debug) { console.log(debug + 'Adding a contact from BG page', data, sourceUrl); }
                        captureService.patternCapture({ patterns: null, precapturedData: data, sourceUrl: sourceUrl }, patternCaptureSuccess, patternCaptureFail);
                    }
                    //patternCaptureSuccess([]);
                };

                $timeout(loadNewContacts, 1000);

            } else { finish(); }

        };

        var loadContacts = function (count) {

            if (debug) { console.log('Loading contacts (from background page)', count); }

            var values1 = [];

            var keys = [];
            var i;

            for (i = 0; i < count; i++) {
                keys.push('' + i);
            }

            for (i = 0; i < count; i++) {
                var cnt1 = bgService.getValue(i);
                if (typeof cnt1 === 'undefined') {
                    break;
                }
                values1.push(cnt1);
            }

            var processValues = function (values) {

                var cc = [];

                var allIds = {};
                var i = count;

                while (i--) {
                    if (values[i]) {

                        if (values[i].c2) { // restore date time
                            values[i].c = (new Date()).setTime(values[i].c2);
                        }

                        if (!values[i].id || allIds[values[i].id]) {

                            var newId = 1;

                            // find next avail Id
                            while (typeof allIds[newId] !== 'undefined') { newId++; }

                            values[i].id = newId;
                        }

                        allIds[values[i].id] = true;

                        cc.unshift(values[i]);
                    }
                }

                if (debug) { console.log('Adding contacts', cc.length); }

                $scope.addContacts(cc, null, true, { method: 'BroadlookStorage' }); // silent - just loading existing contacts

                $timeout(function () {
                    loadPageData();
                }, 1000);
            };

            if (debug) { console.log('Loaded contacts (from background page)', values1.length); }

            if (values1.length === count) {

                processValues(values1);

            }
            else {

                if (debug) { console.log('Loading contacts (from Broadlook storage)'); }
                storageService.get(
                     keys,
                     function (values) {
                         if (debug) { console.log('Loaded contacts (from Broadlook storage)'); }

                         // Save to background
                         for (var i = 0; i < count; i++) {
                             bgService.setValue(i, values[i]);
                         }
                         if (debug) { console.log('Saved contacts (to background page)', count); }

                         processValues(values);
                     },
                     function (error) {
                         $scope.loading = false;
                         dialogs.alert.show(error || 'Capture server is not availaible. Please try again later. Error code: C-1209.');
                     });
            }
        };

        var process = function (count, mark, marks) {

            if (debug) { console.log('Setting active mark as ', mark); }

            if (mark)
            { $scope.showMark(mark); }

            if (marks)
            { $scope.marks = marks; }

            $scope.updateMarks();

            loadContacts(count);
        };

        if (debug) { console.log('Loading marks (from background page)'); }

        var count1 = bgService.getValue('count');
        var mark1 = bgService.getValue('mark');
        var marks1 = bgService.getValue('marks');

        if (debug) { console.log('Loaded marks (from background page)', count1, mark1, marks1); }

        if (typeof count1 !== 'undefined' && typeof mark1 !== 'undefined' && typeof marks1 !== 'undefined') {
            process(count1, mark1, marks1);
        }
        else {
            if (debug) { console.log('Loading marks (from Broadlook storage)'); }
            storageService.get(
                ['count', 'mark', 'marks'],
                function (value) {
                    if (debug) { console.log('Loaded marks (from Broadlook storage)', value); }

                    if (!value || value === null || value === [] || value.count === null || value.count === '') {
                        oldWay();
                        return;
                    }

                    var count = value.count;
                    var mark = value.mark;
                    var marks = value.marks;

                    bgService.setValue('count', count);
                    bgService.setValue('mark', mark);
                    bgService.setValue('marks', marks);

                    if (debug) { console.log('processing storage data'); }
                    process(count, mark, marks);

                },
                function (error) {
                    $scope.loading = false;
                    console.log('ERROR: not loaded from storage', error);
                    dialogs.alert.show(error);
                }
            );
        }


    };

    var getMap = function (entityName) {
        var exportService = $scope.export.getExportService();

        if (exportService && typeof exportService.getInterfaceVersion === 'function' && exportService.getInterfaceVersion() === 2) {

            var maps = $scope.settings.targetMap ? $scope.settings.targetMap[$scope.settings.target] : null;

            if (maps) {

                var entityIndex = maps.entities.length;
                while (entityIndex--) {
                    if (maps.entities[entityIndex].name === entityName) {
                        var map = maps.entities[entityIndex].map;
                        return map;
                    }
                }

                if (entityIndex < 0) {
                    console.error('ERROR: Entity was not found', entityName, maps);
                    //$scope.showError('Export target is not configured. Please check your settings.');
                }

            }
        }
        return null;
    };


    var saveAsCsv = function (list) {

        var downloadCallback = function (content) {

            chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
                function (tabs) {
                    if (!tabs || tabs.length === 0) { return; }

                    // Old way:
                    //chrome.tabs.sendRequest(tabs[0].id, { method: 'downloadCSVFile', content: content, filename: 'export.csv' }, function (response) { });

                    // New way:
                    var blob = new Blob([content], { type: 'text/csv;charset=UTF-8' });
                    chrome.downloads.download({
                        url: window.URL.createObjectURL(blob),
                        filename: 'CaptureExport.csv',
                        saveAs: true
                    });

                    angular.forEach(list, function (contact) {
                        contact._saved = true;
                    });

                    $scope.saveHistory();

                });
        };

        var errorCallback = function (error) {
            console.log('ERROR in saveAsCsv', error);
            dialogs.alert.show(error);
        };

        var saveListAsCsv = function () {
            $timeout(function () {
                broadlookExportService.saveAsCsv(list, downloadCallback, errorCallback);
            }, 100);
        };

        $timeout(function () {
            if (list.length === 1)
            { saveListAsCsv(); }
            else
            { dialogs.confirm.show('Save ' + list.length + ' Cards to CSV?').confirm(saveListAsCsv); }
        }, 100);

    };

    var saveToCrm = function (list, target) {
        const functionName = 'Save To CRM';

        var countSaved = function (list) {

            var processedCount = 0;

            angular.forEach(list, function (value, index) {
                if (value._saved)
                { processedCount++; }
            });

            return processedCount;
        };

        var ending = list.length === 1 ? '' : 's';
        var processedCount = countSaved(list);
        var exportService;
        var createOptions = { mappedProperties: [], map: null };

        var handleError = function (error) {
            console.log('handleError', error);
            dialogs.busy.hide();
            hideActionProgress('export');
            if (error) {
                $timeout(function () {
                    dialogs.alert.show(error.message || error);
                }, 500);
            }

            unmarkAsSaving();
        };

        var checkDuplicates = function (data) {
            console.log('checkDuplicates');
            var deferred = $q.defer();
            var haveDups = 0;

            dialogs.busy.hide();

            var i = 0;
            while (i < data.list.length) {
                if (data.list[i].links && data.list[i].links.length > 0)
                { haveDups++; }
                i++;
            }

            if (haveDups > 0) {
                $timeout(function () {
                    dialogs.confirm.show('There are potential duplicates in ' + $scope.export.name + '. Save anyway?')
                        .confirm(function () {
                            deferred.resolve(data);
                        })
                        .cancel(function () {
                            deferred.reject();
                        })
                    ;
                }, 500);
            }
            else {
                deferred.resolve(data);
            }
            return deferred.promise;
        };

        var findDuplicates = function (data) {
            console.log('findDuplicates');
            var deferred = $q.defer();

            var notSearched = [];

            var i = 0;
            while (i < data.list.length) {
                if (!data.list[i]._searched)
                { notSearched.push(data.list[i]); }
                i++;
            }

            if (notSearched.length === 0) {
                deferred.resolve(data);
            } else {
                if (debug) { console.log(debug + 'notSearched', notSearched); }

                if (notSearched.length > 0) {
                    dialogs.busy.hide();
                    $timeout(function () {
                        dialogs.busy.show('Checking for duplicates...');
                    }, 500);
                }

                $scope.findDups(notSearched, function () {
                    deferred.resolve(data);
                });
            }

            return deferred.promise;
        };

        var resolveLookup = function (data, lookup) {
            console.log('resolveLookup', lookup);
            var deferred = $q.defer();


            var defaultValue = '';

            // get default value
            if (lookup.appProperty) {
                var i = 0;
                while (i < data.list.length) {
                    if (data.list[i][lookup.appProperty]) {
                        defaultValue = data.list[i][lookup.appProperty];
                        break;
                    }
                    i++;
                }
            }

            if (lookup.defaultValue) {
                defaultValue = lookup.defaultValue;
            }

            var processLookup = function (value) {

                console.log('Selected Lookup value: ', value);

                lookup.value = value;
                data.resolvedLookups.push(lookup);

                if (lookup.value.id === null && lookup.value.newName) {
                    // New 
                } else if (lookup.value.id) {
                    createOptions.mappedProperties.push({ name: lookup.crmProperty, value: lookup.value.id, label: lookup.value.label });
                }

                deferred.resolve(data);

            };

            if (lookup.hidden && defaultValue) {
                processLookup(defaultValue);
            } else {
                $timeout(function () {
                    dialogs.lookup.show({ lookup: lookup, value: defaultValue, exportService: exportService })
                        .select(processLookup)
                        .cancel(function () {
                            deferred.reject();
                        });
                }, 500);

            }

            return deferred.promise;
        };

        //var resolveLookupFactory = function (data, lookup) {
        //    console.log('resolveLookupFactory');
        //    return function () {
        //        return resolveLookup(data, lookup).then(function () {
        //            console.log('resolveLookupFactory-then', lookup);
        //        });
        //    };
        //};

        // [ Multiple contacts-to-multiple accounts 

        var askLogin = function (data) {

            var onConfirm = function () {

                if ($scope.settings.target === 'sf' || $scope.settings.target === 'js') {
                    $scope.openLink('https://login.salesforce.com');
                }
                else {

                    data.exportService.login(function () {
                        console.log('SUCCESS in exportService.login');
                        //$timeout(function () {
                        //    deferred.resolve(data);
                        //}, 500);
                    }, function (error) {
                        console.log('ERROR in exportService.login', error);
                        //deferred.reject(error || 'Cannot login');
                    });

                }
            };

            $timeout(function () {
                dialogs.confirm.show('Please login to ' + $scope.export.name + '!').confirm(onConfirm);
            }, 500);
        };

        var selectSameCompanyContact = function (contact, company, website) {
            const functionName = 'Select Same Company Contacts';
            var result = false;
            try {
                if (debug) { console.log(consolePrefix + functionName, contact, company, website); }

                if (company && contactUtility.stripCompanyName(contact.company) === company) {
                    result = true;
                } else if (website) {
                    var www = contactUtility.getDomain(contact.website || '');
                    if (www === website) {
                        result = true;
                    }
                } else if (!contact.company && !contact.website) {
                    result = true;
                }

                if (debug) { console.log(consolePrefix + functionName + ' > Result > ', result); }

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
            }
            return result;
        };

        var displayLookup = function (data, lookup) {
            console.log('resolveLookup Lookup', lookup);
            console.log('resolveLookup Data', data);
            var deferred = $q.defer();


            var website = '';
            var defaultValue = '';

            // get default value
            if (lookup.appProperty) {
                var i = 0;
                while (i < data.list.length) {
                    var value = data.list[i][lookup.appProperty];
                    if (value) {

                        if (lookup.appProperty === 'company') {
                            value = contactUtility.stripCompanyName(value);
                        }

                        defaultValue = value;
                        break;
                    }
                    i++;
                }

                if (lookup.appProperty === 'company') {
                    i = 0;
                    while (i < data.list.length) {
                        // Get website for selected company. However it could be different contact.
                        if (defaultValue === contactUtility.stripCompanyName(data.list[i].company)) {
                            var www = contactUtility.getDomain(data.list[i].website || '');
                            if (www) {
                                website = www;
                                break;
                            }
                        }
                        i++;
                    }
                }
            }

            if (lookup.defaultValue) {
                defaultValue = lookup.defaultValue;
            }

            var processLookup = function (value) {

                console.log('Selected Lookup value: ', value);

                lookup.value = value;
                data.resolvedLookups.push(lookup);
                //console.log('PUSHED LOOKUPS TO RESOLVE');
                console.log(data.resolvedLookups);

                if (lookup.value.id === null && lookup.value.newName) {
                    // New 
                } else if (lookup.value.id) {
                    //console.log(' 11111111111111111 LOOK UP VALUE HAS AN ID 111111111111111111111111');
                    //console.log(lookup.value.id);
                    createOptions.mappedProperties.push({ name: lookup.crmProperty, value: lookup.value.id, label: lookup.value.label });
                }

                deferred.resolve(data);

            };

            if (lookup.hidden && defaultValue) {
                processLookup(defaultValue);
            } else {
                $timeout(function () {

                    //var service = {

                    //    findRecord: function (recordType, query, fields, successCallback, failureCallback) {

                    //        if (debug) { console.log(consolePrefix + functionName + ' > Find Record', recordType, angular.copy(query), fields); }

                    //        var companyName = query.company;

                    //        if (!companyName) {
                    //            successCallback([]);
                    //            return;
                    //        }

                    //        lookupService.lookupCompanyWebsite(
                    //                  companyName,
                    //                  function (rr) {

                    //                      var results = [];

                    //                      // Filter out outliers
                    //                      var i, r, max = 0, min = 0;
                    //                      for (i = 0; i < rr.results.length; i++) {
                    //                          r = rr.results[i];
                    //                          max = r.rank > max ? r.rank : max;
                    //                          min = r.rank < min || min === 0 ? r.rank : min;
                    //                      }

                    //                      var threshold = 0.75 * max;

                    //                      for (i = 0; i < rr.results.length; i++) {
                    //                          r = rr.results[i];
                    //                          if (r.rank >= threshold) {
                    //                              results.push(r);
                    //                          }
                    //                      }

                    //                      successCallback(results);
                    //                  },
                    //                  function (error) { failureCallback(error); }
                    //               );

                    //        return [];

                    //        //var options1 = {
                    //        //    RecordType: recordType,
                    //        //    Query: query,
                    //        //    Fields: fields
                    //        //};

                    //        //$scope.executeRequestAsync(options1, 'Export_FindRecord')
                    //        //.then(function (result) {
                    //        //    if (debug) { console.log(consolePrefix + functionName + ' > Export > Find Record', result); }
                    //        //    try { successCallback(result); } catch (e) { }
                    //        //})
                    //        //.catch(function (error) {
                    //        //    console.error(composeErrorMessage(error, functionName + ' > Export > Find Record'));

                    //        //    if (error && error.indexOf('expired') > 0) {
                    //        //        exportService.logout(true);
                    //        //        data.targetConnected = false;
                    //        //        askLogin(data);
                    //        //    }

                    //        //    try { failureCallback(error); } catch (e) { }
                    //        //});

                    //    },

                    //    getFields: function (entityType, successCallback, failureCallback) {

                    //        if (debug) { console.warn(consolePrefix + functionName + ' > Get Fields', entityType); }

                    //        //var options1 = {
                    //        //    EntityType: entityType
                    //        //};

                    //        //$scope.executeRequestAsync(options1, 'Export_GetFields')
                    //        //.then(function (result) {
                    //        //    if (debug) { console.log(consolePrefix + functionName + ' > Export > Get Fields', result); }
                    //        //    try { successCallback(result); } catch (e) { }
                    //        //})
                    //        //.catch(function (error) {
                    //        //    console.error(composeErrorMessage(error, functionName + ' > Export > Get Fields'));
                    //        //    try { failureCallback(error); } catch (e) { }
                    //        //});
                    //    },

                    //    //toLookupObject: function (value, type) {
                    //       // return exportService.toLookupObject(value, type);
                    //    //}

                    //    toLookupObject: function (value, type) {
                    //        if (debug) { console.log(value); }
                    //        var lookupObject = {};
                    //        lookupObject.label = value.website + ' (' + (value.name || '') + ') ';
                    //        lookupObject.link = value.website;
                    //        lookupObject.id = value.website;
                    //        return lookupObject;
                    //    }

                    //};

                    // website is a hack for account lookup (by name or website)
                    dialogs.lookup.show({ lookup: lookup, value: defaultValue, website: website, exportService: exportService }) // exportService: exportService
                        .select(processLookup)
                        .cancel(function () {
                            console.log('Dialog canceled by user');
                            deferred.reject();
                        });
                }, 500);

            }

            return deferred.promise;
        };

        var createNextGroupAsync = function (groups, contacts) {
            const functionName = 'Create Next Group';
            var deferred = $q.defer();
            var result = null;
            try {
                if (debug) { console.log(functionName + ' > Current Groups > ', angular.copy(groups), ' > Contacts > ', contacts); }
                angular.forEach(contacts, function (contact, contactIndex) {

                    if (result) { return; }

                    var isInGroup = false;

                    angular.forEach(groups, function (group, groupIndex) {
                        angular.forEach(group.contacts, function (contact2, contact2Index) {
                            if (contact2.id === contact.id) {
                                isInGroup = true;
                            }
                        });
                    });

                    if (isInGroup) { return; }

                    // get company and website

                    var company = contactUtility.stripCompanyName(contact.company);
                    var website = contactUtility.getDomain(contact.website || '');

                    // If no company name, skip if others have it
                    if (!company) {
                        var skip = false;
                        angular.forEach(contacts, function (contact2) {
                            if (contactUtility.stripCompanyName(contact2.company)) {
                                skip = true;
                            }
                        });
                        if (skip) { return; }
                    }

                    if (!website) {
                        // Try to find website in different contact from the same company
                        angular.forEach(contacts, function (contact2, contact2Index) {
                            if (company === contactUtility.stripCompanyName(contact2.company)) {
                                website = contactUtility.getDomain(contact2.website || '');
                            }
                        });
                    }

                    result = { company: company, website: website, contacts: [] };

                    if (debug) { console.log(functionName + ' > Result > ', result); }

                    $timeout(function () { deferred.resolve(result); }, 1);

                });

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
                $timeout(function () { deferred.reject(e.message); }, 1);
            }
            return deferred.promise;
        };

        var displayAccountLookupDialogAsync = function (data, lookup, defaultValue, website, group) {
            const functionName = 'Display Account Lookup Dialog';
            var deferred = $q.defer();
            try {
                if (debug) { console.log(functionName); }

                var processLookup = function (value) {

                    console.log(functionName + ' > Selected Account > ', value);

                    group.action = value;

                    //lookup.value = value;
                    //data.resolvedLookups.push(lookup);

                    //if (lookup.value.id === null && lookup.value.newName) {
                    //    // New account
                    //} else if (lookup.value.id) {
                    //    // Existing account
                    //    // TODO: make it contact-specific, not global
                    //    createOptions.mappedProperties.push({ name: lookup.crmProperty, value: lookup.value.id, label: lookup.value.label });
                    //}

                    deferred.resolve(data);
                };

                //var service = {

                //    findRecord: function (recordType, query, fields, successCallback, failureCallback) {

                //        if (debug) { console.log(consolePrefix + functionName + ' > Find Record', recordType, angular.copy(query), fields); }

                //        try {                          

                //            exportService.findRecord(recordType, query, fields, successCallback, failureCallback);

                //        } catch (e) {
                //            console.error(composeErrorMessage(e, functionName));
                //            try { failureCallback(e.message); } catch (e) { }
                //        }

                //        //var companyName = query.company;

                //        //if (!companyName) {
                //        //    successCallback([]);
                //        //    return;
                //        //}

                //        //lookupService.lookupCompanyWebsite(
                //        //          companyName,
                //        //          function (rr) {

                //        //              var results = [];

                //        //              // Filter out outliers
                //        //              var i, r, max = 0, min = 0;
                //        //              for (i = 0; i < rr.results.length; i++) {
                //        //                  r = rr.results[i];
                //        //                  max = r.rank > max ? r.rank : max;
                //        //                  min = r.rank < min || min === 0 ? r.rank : min;
                //        //              }

                //        //              var threshold = 0.75 * max;

                //        //              for (i = 0; i < rr.results.length; i++) {
                //        //                  r = rr.results[i];
                //        //                  if (r.rank >= threshold) {
                //        //                      results.push(r);
                //        //                  }
                //        //              }

                //        //              successCallback(results);
                //        //          },
                //        //          function (error) { failureCallback(error); }
                //        //       );

                //        //return [];

                //        //var options1 = {
                //        //    RecordType: recordType,
                //        //    Query: query,
                //        //    Fields: fields
                //        //};

                //        //$scope.executeRequestAsync(options1, 'Export_FindRecord')
                //        //.then(function (result) {
                //        //    if (debug) { console.log(consolePrefix + functionName + ' > Export > Find Record', result); }
                //        //    try { successCallback(result); } catch (e) { }
                //        //})
                //        //.catch(function (error) {
                //        //    console.error(composeErrorMessage(error, functionName + ' > Export > Find Record'));
                //        //    try { failureCallback(error); } catch (e) { }
                //        //});

                //    },

                //    getFields: function (entityType, successCallback, failureCallback) {

                //        if (debug) { console.warn(consolePrefix + functionName + ' > Get Fields', entityType); }

                //        //var options1 = {
                //        //    EntityType: entityType
                //        //};

                //        //$scope.executeRequestAsync(options1, 'Export_GetFields')
                //        //.then(function (result) {
                //        //    if (debug) { console.log(consolePrefix + functionName + ' > Export > Get Fields', result); }
                //        //    try { successCallback(result); } catch (e) { }
                //        //})
                //        //.catch(function (error) {
                //        //    console.error(composeErrorMessage(error, functionName + ' > Export > Get Fields'));
                //        //    try { failureCallback(error); } catch (e) { }
                //        //});
                //    },

                //    //toLookupObject: function (value, type) {
                //    //    return exportService.toLookupObject(value, type);
                //    //}

                //    toLookupObject: function (value, type) {
                //        if (debug) { console.log(value); }
                //        var lookupObject = {};
                //        lookupObject.label = value.website + ' (' + (value.name || '') + ') ';
                //        lookupObject.link = value.website;
                //        lookupObject.id = value.website;
                //        return lookupObject;
                //    }

                //};

                // website is a hack for account lookup (by name or website)
                dialogs.lookup.show({ lookup: lookup, value: defaultValue || website, website: website, exportService: exportService })
                    .select(processLookup)
                    .cancel(function () {
                        console.log('Dialog canceled by user');
                        deferred.reject();
                    });

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
            }
            return deferred.promise;
        };

        var displaySelectContactsDialogAsync = function (contacts, company, website) {
            const functionName = 'Display Select Contacts Dialog';
            var deferred = $q.defer();
            try {
                if (debug) { console.log(functionName); }

                var items = [];
                angular.forEach(contacts, function (contact, index) {
                    var item = {
                        selected: selectSameCompanyContact(contact, company, website),
                        label: (contact.first + ' ' + (contact.middle || '')).trim() + ' ' + contact.last + ' (' + (contact.company || '') + ')',
                        value: index
                    };
                    items.push(item);
                });

                // Single contact shortcut
                if (items.length === 1 && items[0].selected) {
                    $timeout(function () { deferred.resolve(items); }, 1);
                    return deferred.promise;
                }

                var dialogData = {
                    message: 'Contacts for this Account',
                    description: '',
                    items: items
                };

                dialogs.select.show(dialogData)
                   .select(function (result) {
                       if (debug) { console.log(functionName + ' > Result > ', result); }
                       deferred.resolve(result);
                   })
                   .cancel(function () {
                       console.error(composeErrorMessage('Dialog canceled', functionName));
                       deferred.reject();
                   });

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
            }
            return deferred.promise;
        };

        var displayCompanyLookup = function (data, lookup) {
            const functionName = 'Display Company Lookup';

            var deferred = $q.defer();
            try {

                if (debug) { console.log(functionName, data, lookup); }

                var contacts = angular.copy(data.list);
                var groups = [];
                var chain = $q.when();
                var errorMessage = null;
                var done = false;

                angular.forEach(data.list, function (contact, contactIndex) {

                    if (contacts.length === 0) { return; }

                    chain = chain
                        .then(function () {
                            if (errorMessage) { return; } // Loop exit
                            if (debug) { console.log(functionName + ' > Find Next Group'); }
                            return createNextGroupAsync(groups, contacts);
                        })
                        .then(function (group) {
                            if (errorMessage) { return; } // Loop exit
                            if (debug) { console.log(functionName + ' > Next Group > ', group); }
                            if (!group) { throw 'DONE'; }
                            groups.push(group);
                            return displayAccountLookupDialogAsync(data, lookup, group.company, group.website, group);
                        })
                        .then(function (data) {
                            if (errorMessage) { return; } // Loop exit
                            var group = groups[groups.length - 1];
                            if (debug) { console.log(functionName + ' > Select Contacts for Group > ', group); }
                            return displaySelectContactsDialogAsync(contacts, group.company, group.website);
                        })
                        .then(function (selectedContacts) {
                            if (errorMessage) { return; } // Loop exit
                            if (debug) { console.log(functionName + ' > Selected Contacts > ', selectedContacts); }
                            var group = groups[groups.length - 1];
                            var i = selectedContacts.length;
                            while (i--) {
                                var selectedContact = selectedContacts[i];
                                if (selectedContact.selected) {
                                    var index1 = selectedContact.value;
                                    var contact2 = contacts[index1];
                                    group.contacts.push(contact2);
                                    contacts.splice(index1, 1);

                                    if (group.action.id) {
                                        // Link to existing account
                                        createOptions.contactSpecific = createOptions.contactSpecific || {};
                                        createOptions.contactSpecific[contact2.id] = createOptions.contactSpecific[contact2.id] || {};
                                        createOptions.contactSpecific[contact2.id].mappedProperties = createOptions.contactSpecific[contact2.id].mappedProperties || [];
                                        createOptions.contactSpecific[contact2.id].mappedProperties.push({
                                            name: lookup.crmProperty,
                                            value: group.action.id,
                                            label: group.action.label
                                        });
                                    }
                                }
                            }

                        })
                        .catch(function (error) {
                            if (error === 'DONE') {
                                done = true;
                                return;
                            }
                            console.error(functionName + ' > Error > ' + error);
                            errorMessage = error || 'Error';
                        })
                        .finally(function () {
                            console.log(functionName + ' > Finally ');

                            if (errorMessage) {
                                deferred.reject();
                            } else {
                                if (contacts.length === 0) {
                                    done = true;
                                    lookup.value = groups;
                                    data.resolvedLookups.push(lookup);
                                }
                                if (done) {
                                    deferred.resolve(data);
                                }
                            }

                        });

                });

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
                $timeout(function () { deferred.reject(e.message); }, 1);
            }

            return deferred.promise;
        };

        var displayLookups = function (data) {
            const functionName = 'Execute Lookups';
            var deferred = $q.defer();
            try {

                console.log(functionName, data);

                var lookups = data.exportService.getRequiredLookups(data.target, createOptions.map);

                console.log(functionName + ' > Lookups > ', lookups);

                data.resolvedLookups = [];

                if (Array.isArray(lookups) && lookups.length > 0) {

                    var chain = $q.when();
                    var counter = 0;
                    var hasError = false;

                    lookups.forEach(function (lookup) {

                        console.log(functionName + ' > Next Lookup > ', lookup);

                        if (hasError) {
                            console.error(functionName + ' > Has error');
                            return;
                        }

                        chain = chain
                            .then(
                                function () {
                                    console.log(functionName + ' > Has error ?', hasError);
                                    if (!hasError) {
                                        if (lookup.appProperty === 'company') {
                                            return displayCompanyLookup(data, lookup).then(function () {
                                                console.log(functionName + ' > Resolved company lookup', angular.copy(lookup));
                                            });
                                        } else {
                                            return displayLookup(data, lookup).then(function () {
                                                console.log(functionName + ' > Resolved lookup', angular.copy(lookup));
                                            });
                                        }
                                    }
                                }
                            )
                            .catch(function (error) {
                                console.error(functionName + ' > Catch Error > ' + counter + '/' + lookups.length, ' > Error >', error);
                                hasError = true;
                                deferred.reject();
                            })
                            .finally(function () {
                                console.log(functionName + ' > Finally ' + counter + '/' + lookups.length, ' > Has Error >', hasError);
                                if (hasError) {
                                    deferred.reject();
                                } else {
                                    counter++;
                                    if (lookups.length === counter) { // last one
                                        deferred.resolve(data);
                                    }
                                }
                            });
                    });

                } else {
                    console.log(functionName + ' > No lookups');
                    $timeout(function () { deferred.resolve(data); }, 1);
                }

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
                $timeout(function () { deferred.reject(e.message); }, 1);
            }

            return deferred.promise;
        };

        // Multiple contacts-to-multiple accounts ]

        var resolveLookups = function (data) {
            console.log('resolveLookups');
            var deferred = $q.defer();

            var lookups = data.exportService.getRequiredLookups(data.target, createOptions.map);

            data.resolvedLookups = [];

            if (Array.isArray(lookups) && lookups.length > 0) {
                console.log('resolveLookups-start');
                var chain = $q.when();
                var counter = 0;
                var hasError = false;
                lookups.forEach(function (lookup) {
                    console.log('resolveLookups-next');
                    if (hasError) {
                        return;
                    }
                    chain = chain
                        //.then(resolveLookupFactory(data, lookup))
                        .then(
                            function () {
                                console.log('Has error ?', hasError);
                                if (!hasError) {
                                    return resolveLookup(data, lookup).then(function () {
                                        console.log('Resolved lookup', angular.copy(lookup));
                                    });
                                }
                            }
                        )
                        .catch(function () {
                            console.log('resolveLookups-catch ' + counter + '/' + lookups.length);
                            hasError = true;
                            deferred.reject();
                        })
                        .finally(function () {
                            console.log('resolveLookups-finally', counter, hasError);
                            if (hasError) {
                                deferred.reject();
                            } else {
                                counter++;
                                console.log('resolveLookups-finally ' + counter + '/' + lookups.length);
                                if (lookups.length === counter) { // last one
                                    deferred.resolve(data);
                                }
                            }
                        });
                });
                //return chain;
                console.log('resolveLookups-end');
                //deferred.resolve(data);
            } else {
                deferred.resolve(data);
            }

            return deferred.promise;
        };

        var validateRecord = function (data) {
            console.log('validateRecord');
            var deferred = $q.defer();

            var errors = [];

            if (typeof data.exportService.validateRecord === 'function') {
                errors = data.exportService.validateRecord(data.target, data.contact);
                console.log('errors', errors);
            } else {
                console.log('validateRecord is not implemented');
            }

            if (errors.length === 0) {
                deferred.resolve(data);
            } else {
                var error = errors.join('\n');
                deferred.reject(error);
            }

            return deferred.promise;
        };

        var reportExport = function (data) {
            const functionName = 'Report Export';
            console.log(functionName);
            var deferred = $q.defer();

            totangoService.sendEvent('export');

            // report back
            limitService.useExport(1, function () {
                if (debug) {
                    console.log(functionName + ' > Success');
                }
                deferred.resolve(data);
            }, function (msg) {
                console.error(functionName, msg);
                deferred.reject(msg);
            });

            return deferred.promise;
        };

        var resolveNewRecordLookup = function (resolveActions, lookup, record, newRecordId) {
            const functionName = 'Resolve Lookup As New Record';
            try {
                console.log(functionName, angular.copy(lookup));

                var newName = lookup.value.newName;
                var crmPropertyName = lookup.crmProperty;

                //var newRecordId = data.newRecordId;
                var action = lookup.resolve;

                if (!action) {
                    console.error(functionName + 'No Resolve Action specified');
                    //throw { message: 'Cannot create related record. Please check export map in Settings.' };
                    return;
                }

                var actionCreate = function (callback) {
                    const functionName = 'Action Create Related Record';
                    try {

                        var param = {
                            record: record,
                            newName: newName,
                            crmProperty: crmPropertyName,
                            map: crmPropertyName === 'AccountId' ? getMap('Account') : null
                        };

                        console.log(functionName + ' > Params > ', angular.copy(param));

                        exportService.resolveLookup(
                            action,
                            param,
                            newRecordId,
                            function (a, b) {
                                console.log(functionName + ' > Success > Link > ', a, ' > ID > ', b);
                                try { callback(a, b); } catch (e) { }
                            },
                            function (error) {
                                console.error(composeErrorMessage(error, functionName));
                                try { callback(); } catch (e) { }
                            }
                        );

                        //var args = {
                        //    ActionId: action,
                        //    LookupId: param,
                        //    ObjectId: newRecordId
                        //};

                        //$scope.executeRequestAsync(args, 'Export_ResolveLookup')
                        // .then(function (result) {
                        //     console.log(functionName + 'Success > ', result);
                        //     //console.log(functionName + 'Success > Link > ', link, ' > ID > ', id);
                        //     try { callback(); } catch (e) { }
                        // })
                        // .catch(function (error) {
                        //     console.error(composeErrorMessage(error, functionName));
                        //     try { callback(); } catch (e) { }
                        // });

                    } catch (e) {
                        console.error(composeErrorMessage(e, functionName));
                        try { callback(); } catch (e) { }
                    }
                };

                resolveActions.push(actionCreate);
            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
            }
        };

        var resolvePreLookups = function (data) {
            const functionName = 'Resolve Pre Lookups';
            var deferred = $q.defer();
            try {

                // A case: Create new account and assign multiple contacts to it.

                var resolvedLookups = data.resolvedLookups;
                if (debug) { console.log(functionName, ' > Record > ', angular.copy(data.contact), ' > Lookups > ', angular.copy(resolvedLookups)); }

                if (!resolvedLookups) {
                    deferred.resolve(data);
                    return deferred.promise;
                }

                // var names = [];
                var actions = [];
                var record = angular.copy(data.contact);
                var newRecordId = null; //data.newRecordId   
                var last = false;

                var findGroup = function (lookup, record) {
                    var group = null;
                    var groups = lookup.value;

                    angular.forEach(groups, function (group2) {
                        angular.forEach(group2.contacts, function (contactInGroup) {
                            if (contactInGroup.id === record.id) {
                                group = group2;
                            }
                        });
                    });

                    console.log(functionName + 'Group > ', angular.copy(group));

                    return group;
                };

                //var actionsLeft;
                //var respond = function () {
                //    actionsLeft--;
                //    if (actionsLeft <= 0) {
                //        deferred.resolve(data);
                //    }
                //};

                var lookupsToResolve = [];

                var resolveGroupLookup = function (lookup, record) {

                    console.log(functionName + ' > Resolving Group Lookup > ', angular.copy(lookup.value));

                    // Find current group/record
                    var group = findGroup(lookup, record);

                    // Already resolved this group?
                    if (group === null) {
                        console.log(functionName + ' > This group is already resolved');
                        return;
                    }

                    // Make new lookup object (for this record only)
                    var lookup2 = angular.copy(lookup);
                    lookup2.value = group.action;

                    if (lookup2.value.id === null && lookup2.value.newName) {
                        // compile a list of actions to resolve
                        resolveNewRecordLookup(actions, lookup2, record, newRecordId);
                        lookupsToResolve.push(lookup);
                    }
                };

                var resolveAllActions = function () {
                    //actionsLeft = actions.length;
                    console.log(functionName + ' > Resolve All Actions > Actions Count > ', actions.length);

                    var group = null;
                    var crmProperty = null;

                    var resolveActionCallback = function (relatedRecordLink, relatedRecordId) {
                        console.log(functionName + ' > Action Callback');

                        console.log(functionName + ' > Related Record Was Created > Link > ', relatedRecordLink, ' > ID > ', relatedRecordId);

                        if (relatedRecordLink || relatedRecordId) {

                            // Convert all other Create actions to Link (same account/group)

                            var convertedContacts = [];

                            console.log(functionName + ' > Converting all actions in this group to use just-created record > ', angular.copy(group));

                            angular.forEach(group.contacts, function (groupContact) {

                                angular.forEach(data.list, function (contact) {
                                    if (contact.id !== groupContact.id) { return; }

                                    convertedContacts.push(contact.id);

                                    console.log(functionName + ' > Converted action for contact > ', angular.copy(contact));

                                    // Link to existing account
                                    createOptions.contactSpecific = createOptions.contactSpecific || {};
                                    createOptions.contactSpecific[contact.id] = createOptions.contactSpecific[contact.id] || {};
                                    createOptions.contactSpecific[contact.id].mappedProperties = createOptions.contactSpecific[contact.id].mappedProperties || [];
                                    createOptions.contactSpecific[contact.id].mappedProperties.push({
                                        name: crmProperty,
                                        value: relatedRecordId,
                                        label: ''
                                    });

                                });

                            });

                            // Remove all contacts from that group
                            console.log(functionName + ' > Group (Before Cleaning)', angular.copy(group));
                            console.log(functionName + ' > Converted Contacts > ', angular.copy(convertedContacts));

                            angular.forEach(convertedContacts, function (id) {

                                var i = group.contacts.length;
                                while (i--) {
                                    if (group.contacts[i].id === id) {
                                        group.contacts.splice(i, 1);
                                        break;
                                    }
                                }

                            });

                            console.log(functionName + ' > Group (After Cleaning)', angular.copy(group));
                        }

                        resolveAllActions();
                    };

                    if (actions.length > 0) {
                        var action = actions.pop();
                        var lookup1 = lookupsToResolve.pop();
                        crmProperty = lookup1.crmProperty;
                        group = findGroup(lookup1, record);
                        console.log(functionName + ' > Resolving Action', lookup1, group);
                        last = actions.length === 0;
                        action(resolveActionCallback);
                    } else {
                        deferred.resolve(data);
                    }
                };

                // Compile list of actions to resolve
                angular.forEach(resolvedLookups, function (lookup, index) {

                    if (debug) { console.log(functionName + ' > Lookup > ', angular.copy(lookup)); }

                    if (Array.isArray(lookup.value)) {
                        resolveGroupLookup(lookup, record);
                    }

                });

                resolveAllActions();

            } catch (e) {
                console.error(composeErrorMessage(e, functionName));
                deferred.reject(functionName + ' Failed');

            }
            return deferred.promise;
        };


        var resolvePostLookups = function (data) {
            console.log('resolvePostLookups');
            var deferred = $q.defer();

            var resolvedLookups = data.resolvedLookups;

            if (!resolvedLookups) {
                deferred.resolve(data);
                return deferred.promise;
            }

            var resolveActions = [];

            var resolveAll = function () {
                console.log('Resolving post lookup actions', resolveActions.length);
                if (resolveActions.length === 0) {
                    deferred.resolve(data);
                } else {
                    var action = resolveActions.pop();
                    console.log('Resolving post lookup action');
                    action(resolveAll);
                }
            };

            // Compile list of actions to resolve
            angular.forEach(resolvedLookups, function (lookup, index) {

                if (debug) {
                    console.log('resolvedLookup', angular.copy(lookup));
                }

                if (lookup.value.id === null && lookup.value.newName) { // Create new Account

                    if (lookup.resolve) {

                        var actionCreate = function (callback) {

                            console.log('resolving (create)', angular.copy(lookup));

                            var param = {
                                record: angular.copy(data.contact),
                                newName: lookup.value.newName,
                                crmProperty: lookup.crmProperty
                            };

                            exportService.resolveLookup(
                                lookup.resolve,
                                param,
                                data.newRecordId,
                                function () {
                                    console.log('** resolve success');
                                    callback();
                                },
                                function (error) {
                                    console.log('** ERROR in resolve lookup (fail)', error);
                                    callback();
                                }
                            );
                        };

                        resolveActions.push(actionCreate);
                    }

                } else if (lookup.value.id) { // Use existing Account

                    // Stuff like addLeadToCampaign / addContactToCampaign requires calling post-create
                    // Stuff like createNewAccount does not need calling post-create (this value should be already added to mappedProperties)

                    if (lookup.resolve) {

                        var actionLink = function (callback) {

                            console.log('resolving (link)', angular.copy(lookup));

                            exportService.resolveLookup(
                                lookup.resolve,
                                lookup.value.id,
                                data.newRecordId,
                                function (link, id) {
                                    console.log('*** resolve success', link, id);
                                    callback();
                                },
                                function (error) {
                                    console.log('**** ERROR in resolve lookup', error);
                                    callback();
                                }
                            );

                        };

                        resolveActions.push(actionLink);

                    }

                }

            });

            // Resolve all actions
            resolveAll();

            return deferred.promise;
        };

        var saveRecord = function (data) {
            console.log('saveRecord');
            var deferred = $q.defer();

            //data.contact._saving = true;

            var createOptionsCopy = angular.copy(createOptions);
            if (createOptionsCopy) {
                // Apply individual properties
                if (createOptionsCopy.contactSpecific) {
                    if (createOptionsCopy.contactSpecific[data.contact.id]) {
                        var individualProps = createOptionsCopy.contactSpecific[data.contact.id].mappedProperties;

                        angular.forEach(individualProps, function (prop) {
                            createOptionsCopy.mappedProperties.push(prop);
                        });
                        console.log('Applied individual properties > ', individualProps);
                    }
                    delete createOptionsCopy.contactSpecific;
                }
            }
            console.log('Create Options > ', createOptionsCopy);
            updateActionProgress('export');
            data.exportService.createRecord(data.target, data.contact, createOptionsCopy,

                // saved
                function (newRecordLink, newRecordId) {

                    //delete data.contact._saving;
                    data.contact._saved = true;
                    data.contact._link = newRecordLink;
                    data.newRecordId = newRecordId;

                    deferred.resolve(data);
                },

                // not saved
                function (error) {
                    console.log('*** ERROR in saveRecord', error);

                    delete data.contact._saving;
                    data.contact._saved = false;

                    deferred.reject(error);
                });

            return deferred.promise;
        };

        var findDuplicatesPostSave = function (data) {
            console.log('findDuplicates');
            var deferred = $q.defer();

            if ($scope.settings.deleteAfterExport !== 'Never') {
                deferred.resolve(data);
                return deferred.promise;
            }

            var contact = data.contact;
            var newRecordLink = data.contact._link;

            var findDupsTimeout = 1;
            if ($scope.export.name.toLowerCase().indexOf('zoho') === 0) {

                // Zoho has huge delay 
                findDupsTimeout = 90 * 1000;

                // Extract Record Id
                var zohoId = newRecordLink.substring(newRecordLink.indexOf('&id=') + 4);

                // Put a 'fake' dup record in
                contact.links.push({
                    id: contact.links.length + 1,
                    first: contact.first,
                    last: contact.last,
                    company: contact.company,
                    _type: target === 'lead' ? 'Lead' : (target === 'contact' ? 'Contact' : target),
                    _link: newRecordLink,
                    _id: zohoId
                });
            }


            $timeout(function () {
                $scope.findDups([contact]);
            }, findDupsTimeout);

            // do not wait
            deferred.resolve(data);

            return deferred.promise;
        };

        var processContact = function (data, contact) {

            console.log('processContact', contact);
            var deferred = $q.defer();

            data.contact = contact;

            validateRecord(data)
            .then(resolvePreLookups)
            .then(reportExport)
            .then(saveRecord)
            .then(resolvePostLookups)
            .then(findDuplicatesPostSave)
            .then(function (c) { deferred.resolve(data); })
            .catch(handleError);

            return deferred.promise;

        };

        var processContactFactory = function (data, contact) {
            console.log('processContactFactory', contact);
            return function () {
                return processContact(data, contact)
                    .then(function () {
                        console.log('processContactFactory-then', contact);
                    });
            };
        };

        var processList = function (data) {
            console.log('processList');
            var deferred = $q.defer();

            if (Array.isArray(data.list) && data.list.length > 0) {
                console.log('processList-start');
                var chain = $q.when();
                var counter = 0;
                data.list.forEach(function (contact) {
                    console.log('processList-next', contact);
                    chain = chain
                        .then(processContactFactory(data, contact))
                        .finally(function () {
                            counter++;
                            console.log('processList-finally ' + counter + '/' + data.list.length);
                            if (counter === data.list.length) {
                                deferred.resolve(data);
                            }
                        })
                    ;
                });
                console.log('processList-end');
            } else {
                deferred.resolve(data);
            }

            return deferred.promise;
        };

        var confirmExport = function (data) {

            console.log('confirmExport');
            var deferred = $q.defer();

            var resolvedLookups = data.resolvedLookups;

            var cb = function () {
                deferred.resolve(data);
            };

            var cb2 = function () {

                var tempList = [];
                for (var i = 0; i < data.list.length; i++) {
                    if (!data.list[i]._saved)
                    { tempList.push(data.list[i]); }
                }
                data.list = tempList;
                ending = data.list.length === 1 ? '' : 's';

                $timeout(function () {
                    dialogs.confirm.show('Create ' + data.list.length + ' ' + $scope.export.name + ' ' + target + ending + '?').confirm(cb)
                    .cancel(function () { deferred.reject(); });
                }, 500);
            };

            var totalCount = data.list.length;

            $timeout(function () {
                if (processedCount === totalCount) {

                    if (totalCount === 1)
                    { dialogs.confirm.show('This Card has already been saved. Save anyway?').confirm(cb); }
                    else
                    { dialogs.confirm.show('All ' + totalCount + ' Cards have already been saved. Save anyway?').confirm(cb); }

                }
                else if (processedCount > 0) {

                    if (processedCount === 1) {
                        dialogs.confirm.show('One of ' + totalCount + ' Cards has already been saved. Save all ' + totalCount + ' Cards?')
                            .confirm(cb)
                            .cancel(cb2);
                    }
                    else {
                        dialogs.confirm.show('' + processedCount + ' of ' + totalCount + ' Cards have already been saved. Save all ' + totalCount + ' Cards?')
                            .confirm(cb)
                            .cancel(cb2);
                    }

                } else {

                    if (totalCount === 1)
                    { cb(); }
                    else
                    { dialogs.confirm.show('Create ' + totalCount + ' ' + $scope.export.name + ' ' + target + ending + '?').confirm(cb); }

                }
            }, 500);

            return deferred.promise;
        };

        var finishSave = function (data) {

            console.log('finishSave');
            var deferred = $q.defer();

            dialogs.busy.hide();
            $scope.saveHistory();
            $scope.refresh();

            var newRecordLink = data.contact._link;
            var successMessage = 'Saved as ' + $scope.export.name + ' ' + data.target + '';

            var openLinkCall = function () {
                if (debug) { console.log('openLinkCall. openAfterExport=', $scope.settings.openAfterExport, 'newRecordLink=', newRecordLink); }
                if (newRecordLink && $scope.settings.openAfterExport !== 'Never') {
                    $scope.loadPage(newRecordLink, true);
                }

                deferred.resolve(data);
            };

            var deleteCards = function () {
                console.log('deleteCards');
                $scope.deleteContacts(data.list, true);
                openLinkCall();
            };


            $timeout(function () {
                try {
                    if ($scope.settings.deleteAfterExport !== 'Never') {

                        if ($scope.settings.deleteAfterExport === 'Always') {
                            deleteCards();
                        } else {
                            dialogs.confirm.show(successMessage + '. Would you like to delete ' + data.list.length + ' Card' + ending + '?')
                                .confirm(deleteCards)
                                .cancel(openLinkCall);
                        }

                    } else {
                        //dialogs.alert.show(successMessage).ok(openLinkCall);
                        openLinkCall();
                    }
                } catch (e) {
                    console.log('ERROR in DELETE OPTION', e.message);
                }
            }, 500);

            return deferred.promise;
        };

        var getExportService = function (data) {

            console.log('getExportService');
            var deferred = $q.defer();

            if (!target) {
                deferred.reject('Export target is not set up. Please check your settings.');
            } else {

                data.exportService = $scope.export.getExportService();
                exportService = data.exportService;

                if (!data.exportService) {
                    deferred.reject('Export target is not set up. Please check your settings.');
                } else {

                    var valid = true;

                    // map exists? (export v2 )
                    if (typeof data.exportService.getInterfaceVersion === 'function' && data.exportService.getInterfaceVersion() === 2) {

                        var maps = $scope.settings.targetMap[$scope.settings.target];

                        if (maps) {

                            var entityIndex = maps.entities.length;
                            while (entityIndex--) {
                                if (maps.entities[entityIndex].name === target) {
                                    createOptions.map = maps.entities[entityIndex].map;
                                    break;
                                }
                            }

                            if (entityIndex < 0) {
                                console.log('ERROR: Entity was not found', target, maps);
                                deferred.reject('Export target is not configured. Please check your settings.');
                                valid = false;
                            }

                        }
                    }

                    if (valid) {
                        deferred.resolve(data);
                    }
                }
            }

            return deferred.promise;
        };

        var login = function (data) {
            console.log('login');
            var deferred = $q.defer();

            if (!data.exportService) {
                deferred.reject('Export target is not selected');
            } else {
                data.exportService.isLoggedIn(
                    // success
                    function () {
                        data.targetConnected = true;
                        deferred.resolve(data);
                    },
                    // failed
                    function (errorReason) {
                        data.targetConnected = false;
                        // Do not reject, try to relogin
                        //deferred.reject(errorReason);
                        deferred.resolve(data);
                    });
            }
            return deferred.promise;
        };

        var relogin = function (data) {
            console.log('relogin');
            var deferred = $q.defer();

            $scope.targetConnected = data.targetConnected === true;

            if (data.targetConnected) {
                deferred.resolve(data);
            } else {
                dialogs.busy.hide();
                $timeout(function () {
                    dialogs.confirm.show('Please login to ' + $scope.export.name + '!').confirm(function () {
                        data.exportService.login(function () {
                            $timeout(function () {
                                deferred.resolve(data);
                            }, 500);
                        }, function (error) {
                            console.log('ERROR in exportService.login', error);
                            deferred.reject(error || 'Cannot login');
                        });
                    });
                }, 500);
            }

            return deferred.promise;
        };

        var markAsSaving = function (data) {
            console.log('findDuplicates');
            var deferred = $q.defer();

            var i = 0;
            while (i < data.list.length) {
                data.list[i]._saving = true;
                i++;
            }

            $timeout(function () {
                deferred.resolve(data);
            }, 1);

            return deferred.promise;
        };

        var unmarkAsSaving = function (data) {
            console.log('findDuplicates');
            var deferred = $q.defer();

            var i = 0;
            while (i < list.length) {
                delete list[i]._saving;
                i++;
            }

            $timeout(function () {
                deferred.resolve(data);
            }, 1);

            return deferred.promise;
        };


        var data = {
            target: target,
            list: list
        };

        showActionProgress('export', list.length);

        getExportService(data)
        .then(login)
        .then(relogin)
        .then(markAsSaving)
        .then(findDuplicates)
        .then(checkDuplicates)
        .then(confirmExport)
        //.then(resolveLookups)
        .then(displayLookups)
        .then(processList)
        .then(finishSave)
        .then(function (x) {
            console.log('*** SAVE done');
            hideActionProgress('export');
        })
        .finally(unmarkAsSaving)
        .catch(handleError)
        ;

        ////  Login Check
        //exportService.isLoggedIn(
        //    //  Login success!
        //    loggedinSuccessCallback,
        //     //  Failed login
        //    function () {
        //        $scope.targetConnected = false;
        //        dialogs.busy.hide();
        //        $timeout(function () {
        //            dialogs.confirm.show('Please login to ' + $scope.export.name + '!').confirm(function () {
        //                exportService.login(function () {
        //                    $timeout(function () { loggedinSuccessCallback(); }, 500);
        //                }, function (error) {
        //                    console.log('ERROR in exportService.login', error);
        //                    if (error) {
        //                        $timeout(function () {
        //                            dialogs.alert.show(error);
        //                        }, 500);
        //                    }
        //                });
        //            });
        //        }, 500);
        //    });

    };

    $scope.save = function (contactOrContacts, target) {

        console.log('*** SAVE', contactOrContacts, target);

        var composeList = function (contactOrContacts) {

            var list = [];

            if (Array.isArray(contactOrContacts)) {
                var i = contactOrContacts.length;
                while (i--) {
                    if (contactOrContacts[i]._hidden) { continue; }
                    contactUtility.sortVenues(contactOrContacts[i]);
                    list.unshift(contactOrContacts[i]);
                }
            }
            else {
                if (contactOrContacts) {
                    contactUtility.sortVenues(contactOrContacts);
                    list.push(contactOrContacts);
                }
            }

            return list;
        };

        var list = composeList(contactOrContacts);

        if (list.length === 0) {
            dialogs.alert.show('Nothing to save');
            return;
        }

        if (target === 'csv') {
            saveAsCsv(list);
        } else {
            saveToCrm(list, target);
        }
    };

    var getEmailPattern = function (domain, successCallback, failCallback) {


        var applyPattern = function (firstname, lastname, template) {

            var first = String(firstname).toLowerCase();
            var last = String(lastname).toLowerCase();

            var fi = '';
            if (first.length > 0)
            { fi = first[0]; }

            var li = '';
            if (last.length > 0)
            { li = last[0]; }

            var res = String(template);

            if (res.indexOf('First') > -1)
            { res = res.replace(/First/g, first); }
            if (res.indexOf('F') > -1)
            { res = res.replace(/F/g, fi); }

            if (res.indexOf('Last') > -1)
            { res = res.replace(/Last/g, last); }
            if (res.indexOf('L') > -1)
            { res = res.replace(/L/g, li); }

            return res;
        };

        var detectPattern = function (records) {

            var patterns = ['FLast', 'LastF', 'First', 'FirstLast', 'First.Last', 'First_Last', 'F.Last', 'F_Last', 'FirstL', 'First.L', 'First_L'];
            var i;
            var foundPatterns = [];
            var counts = {};
            for (i = 0; i < patterns.length; i++) {
                var pattern = patterns[i];
                counts[pattern] = 0;
            }

            angular.forEach(records, function (record, i) {

                var foundPattern = null;

                if (record.email) {
                    for (i = 0; i < patterns.length; i++) {
                        var pattern = patterns[i];
                        var test = applyPattern(record.first, record.last, pattern);
                        if ((test + '@' + domain) === record.email)
                        { foundPattern = pattern; break; }
                    }
                }

                if (foundPattern)
                { foundPatterns.push(foundPattern); counts[foundPattern]++; }

            });

            var mostFrequent = null;
            var maxCount = 0;
            var minCount = 3; // Require at least X emails with this pattern
            for (i = 0; i < foundPatterns.length; i++) {
                var currentPattern = foundPatterns[i];
                if (counts[currentPattern] > maxCount && counts[currentPattern] >= minCount) {
                    maxCount = counts[currentPattern];
                    mostFrequent = currentPattern;
                }
            }
            return mostFrequent;
        };

        var processResults = function (records) {

            console.log('processResults', records);

            var pattern = detectPattern(records);

            console.log('pattern', pattern);

            if (pattern)
            { try { successCallback(pattern); } catch (e) { } }
            else
            { try { failCallback(); } catch (e) { } }

        };

        if (!domain) {
            processResults(null);
            return;
        }

        var exportService = $scope.export.getExportService();

        if (!exportService) {
            processResults(null);
            return;
        }
        // Search supported?
        if (typeof exportService.findRecord !== 'function') {
            processResults(null);
            return;
        }

        exportService.isLoggedIn(
            //  Login success!
            function () {

                var records = [];

                var searchLeads = function () {
                    exportService.findRecord('Lead', { email_endsWith: '@' + domain }, ['first', 'last', 'email'], function (nativeRecords) {

                        console.log('found leads', nativeRecords);

                        angular.forEach(nativeRecords, function (nativeRecord, index) {
                            var appRecord = exportService.fromNativeRecord(nativeRecord, 'Lead');
                            records.push(appRecord);
                        });

                        processResults(records);

                    }, function (msg) {
                        console.log('find leads failure', msg);
                        processResults(records);
                    });
                };

                exportService.findRecord('Contact', { email_endsWith: '@' + domain }, ['first', 'last', 'email'], function (nativeRecords) {

                    console.log('found contacts', nativeRecords);

                    angular.forEach(nativeRecords, function (nativeRecord, index) {
                        var appRecord = exportService.fromNativeRecord(nativeRecord, 'Contact');
                        records.push(appRecord);
                    });

                    searchLeads();

                }, function (msg) {
                    console.log('find contacts failure', msg);
                    searchLeads();
                });

            },
             //  Failed login
            function () {
                processResults(null);
            });

    };

    var getResearchStatusCount = 0;

    //  Check on research status if it goes too long
    var getResearchStatus = function (contact) {

        var checkAgain = function (minDelay) {
            //  Check status again in 5+ seconds

            var delayMultiplier = getResearchStatusCount;
            if (delayMultiplier < 0) { delayMultiplier = 0; }
            var delay = (minDelay || 5000) + delayMultiplier * 200; // extra 200ms for each waiting item. 100 items * 200 ms = 20s

            console.log('Check status again in ' + delay + ' milliseconds');

            getResearchStatusCount++;
            setTimeout(function () { getResearchStatus(contact); }, delay);
        };

        getResearchStatusCount--;
        if (!contact._researchJobId) { return; }
        console.log('Checking research status. Job ID = ' + contact._researchJobId);
        researchService.poll(contact._researchJobId, function (response) {
            if (response && response.success) {
                if (response.data) {
                    console.log('Profile response:', angular.copy(response));
                    updateActionProgress('research');
                    contact._researchJobId = undefined;
                    $scope.enhanceCallback(response);
                } else {
                    checkAgain();
                }
            }
            else {
                console.error('Research status request failed', response);
                if (response && response.message) { dialogs.alert.show(response.message); }
                    //else { dialogs.alert.show('Service is unavailable, please try again later. Error code: C-1948.'); }
                else { checkAgain(10000); }
            }
        }, function (response) {
            console.error('Research status is not available', response); // No tokens left
            if (response === 'No tokens left') {

                $scope.tokens = 0;
                mySharedService.broadcast('contactTokensLeft:0');

                //dialogs.alert.show('There are not enough credits to complete research');

                //if (getResearchStatusCount <= 1) {
                //dialogs.alert.show(response);
                //} else {
                // no message if there are many in progress
                //}
            }
            else {
                checkAgain(10000);
            }
            //if (response) { dialogs.alert.show(response); }
            //else { dialogs.alert.show('Service is unavailable, please try again later. Error code: C-1952.'); }
        });
    };

    $scope.researchInProgress = false;

    var foundDomains = {};
    var foundPatterns = {};

    //  Step 2, queue it up for full profiling
    var researchQueued = function (contact, successCallback, failureCallback) {

        var doResearch = function () {

            console.log('Research Queued > ', contact);

            //if ($scope.isLocal) {
            //    contact._researchJobId = true;
            //    researchService.quick(contactUtility.contactsToBlXml([contact]), $scope.researchMode,
            //        function (response) {
            //            console.log('Research response:', angular.copy(response));
            //            contact._researchJobId = undefined;
            //            $scope.enhanceCallback(response);
            //        }, function (response) {
            //            if (response) { dialogs.alert.show(response); }
            //            else { dialogs.alert.show('Service is unavailable, please try again later. Error code: C-1991.'); }
            //            contact._researchJobId = undefined;
            //            $scope.researchInProgress = false;
            //        });
            //    try { successCallback(); } catch (e) { }
            //    return;
            //}

            researchService.enqueue(contactUtility.contactsToBlXml([contact]), $scope.researchMode,
                function (response) {
                    if (response && response.success) {
                        //  Assign job
                        contact._researchJobId = response.jobID;
                        if (debug) { console.log('Research is in progress > Job ID > ' + contact._researchJobId); }
                        $scope.saveHistory();
                        getResearchStatusCount++;
                        setTimeout(function () { getResearchStatus(contact); }, 5000);
                        //updateActionProgress('research');
                        try { successCallback(); } catch (e) { }

                    } else {
                        if (response && response.message) { dialogs.alert.show(response.message); }
                        else { dialogs.alert.show('Service is unavailable, please try again later. Error code: C-2012.'); }

                        try { failureCallback(); } catch (e) { }
                    }
                }, function (response) {
                    console.error('Research Submit Error > ', response);
                    //Un-queue
                    delete contact._researchJobId;
                    $scope.saveHistory();
                    if (response) {
                        //dialogs.alert.show(response);
                    }
                    else { dialogs.alert.show('Service is unavailable, please try again later.  Error code: C-2016.'); }
                    try { failureCallback(); } catch (e) { }
                });
        };

        var domain = contactUtility.getDomain(contact.website);
        console.log('DOMAIN: ', domain);

        var getPatternAndDoResearch = function () {

            // Was a pattern already found?
            if (foundPatterns[domain] !== undefined) {

                // Just do research then
                doResearch();

            } else {

                // Search for pattern in CRM
                getEmailPattern(domain,

                    // Pattern found in CRM
                    function (pattern) {

                        console.log('pattern found', pattern, domain);

                        // Log it
                        foundPatterns[domain] = pattern;

                        // Report it
                        if (pattern && domain) {
                            lookupService.logEmailPattern(domain, pattern);
                        }

                        $timeout(function () {
                            doResearch();
                        }, 500);

                    },

                    // No pattern found in CRM 
                    function () {
                        console.log('pattern not found');
                        //proceed
                        doResearch();
                    }

                );

            }
        };

        if (!domain) {

            if (contact.company) {

                // Was already looked up?
                if (foundDomains[contact.company] !== undefined) {

                    console.log('AUTO LOOKUP for  ' + contact.company);
                    domain = foundDomains[contact.company];
                    getPatternAndDoResearch();

                } else {

                    // Do a mandatory Website Lookup
                    console.log('LOOKUP: ');
                    $scope.lookupWebsite(contact, 'Research', true,

                        // User pick a domain
                        function (newDomain) {
                            console.log('DOMAIN: ', newDomain);
                            domain = contactUtility.getDomain(newDomain);

                            foundDomains[contact.company] = domain;

                            getPatternAndDoResearch();
                        },

                        // User cancels out
                        function () {

                            // unqueue contacts
                            contact._researchJobId = undefined;
                            for (var i = 0; i < $scope.contacts.length; i++) {
                                if ($scope.contacts[i]._researchJobId === 0) {
                                    $scope.contacts[i]._researchJobId = undefined;
                                }
                            }

                            dialogs.busy.hide();
                            $scope.saveHistory();
                            $scope.refresh();
                        }
                    );
                }
            }
            else { doResearch(); }

        } else { getPatternAndDoResearch(); }


    };

    //  Stage 1, get simple results back if possible
    /*
    //  TODO: this is just a hack because the researching (queued) was taking 30+ seconds, Donato wanted this added for demoing
    var research = function (contact, successCallback) {

        //if ($scope.isLocal) {
        //    contact._researchJob = true;
        //    researchService.quick(contactUtility.contactsToBlXml([contact]), $scope.researchMode,
        //        function (response) {
        //            console.log('Research response:', angular.copy(response));
        //            contact._researchJob = undefined;
        //            $scope.enhanceCallback(response);
        //        }, function (response) {
        //            if (response) { dialogs.alert.show(response); }
        //            else { dialogs.alert.show('Service is unavailable, please try again later.'); }
        //            contact._researchJob = undefined;
        //            $scope.researchInProgress = false;
        //        });
        //    return;
        //}

        //if ($scope.researchInProgress) {
        researchQueued(contact, successCallback);
        return;
        //}
        //$scope.researchInProgress = true;
        //contact._researchJob = true;
        //researchService.quick(contactUtility.contactsToBlXml([contact]), researchService.modes.full,
        //    function (response) {
        //        console.log('Research response:', angular.copy(response));
        //        contact._researchJob = undefined;
        //        $scope.enhanceCallback(response);
        //        //researchQueued(contact);
        //    }, function (response) {
        //        if (response) { dialogs.alert.show(response); }
        //        else { dialogs.alert.show('Service is unavailable, please try again later.'); }
        //        contact._researchJob = undefined;
        //        $scope.researchInProgress = false;
        //    });
    };
    */

    $scope.researchButtonText = function (contact) {
        if (!contact) { return 'Research'; }
        if (contact._researchJobId === 0) { return 'Queued'; }
        if (contact._researchJobId) { return 'Researching...'; }
        if (contact._enhanced) { return 'Researched'; }
        return 'Research';
    };
    $scope.researchButtonQueued = function (contact) {
        if (!contact) { return false; }
        if (contact._researchJobId === 0) { return true; }
        return false;
    };
    $scope.researchButtonBusy = function (contact) {
        if (!contact) { return false; }
        if (contact._researchJobId === 0) { return false; }
        if (contact._researchJobId) { return true; }
        if (contact._enhanced) { return false; }
        return false;
    };
    $scope.researchButtonDone = function (contact) {
        if (!contact) { return false; }
        if (contact._researchJobId === 0) { return false; }
        if (contact._researchJobId) { return false; }
        if (contact._enhanced) { return true; }
        return false;
    };


    $scope.checkResearch = function (contact) {
        getResearchStatusCount++;
        getResearchStatus(contact);
    };

    var openStore = function () {
        storeService.open();
    };

    $scope.researchContacts = function (contactOrContacts, silent) {

        var list = [];
        var i;

        var researchAll = function () {

            var onFail = function () {
                // Unqueue all contacts
                for (i = 0; i < list.length; i++) {
                    if (list[i]._researchJobId === 0) {
                        delete list[i]._researchJobId;
                    }
                }

                $scope.saveHistory();
            };

            var f = function () {

                window.setTimeout(function () {

                    if (list.length > 0) {
                        var item = list.pop();
                        researchQueued(item, f, onFail);
                    }

                }, 500);
            };

            // Mark all contacts as Queued (Set _researchJobId = 0)
            for (i = 0; i < list.length; i++) {
                list[i]._researchJobId = 0;
            }

            showActionProgress('research', list.length);
            totangoService.sendEvent('research', list.length);
            $scope.saveHistory(f);

        };

        var researchNew = function () {

            var f = function () {
                window.setTimeout(function () {
                    try {
                        if (list.length > 0) {
                            var item = list.pop();
                            if (!item._enhanced) {
                                researchQueued(item, f);
                            } else {
                                f();
                            }
                        }
                    } catch (e) {
                        console.log('ERROR in researchNew->setTimeout', e.message);
                    }
                }, 500);
            };

            try {

                // Mark all contacts as Queued (Set _researchJobId = 0)
                var qty = 0;
                for (i = 0; i < list.length; i++) {
                    if (!list[i]._enhanced) {
                        list[i]._researchJobId = 0;
                        qty++;
                    }
                }

                totangoService.sendEvent('research', qty);

                // Save history
                $scope.saveHistory(f);

            } catch (e) {
                console.log('ERROR in researchNew->prepare', e.message);
            }

        };

        if (Array.isArray(contactOrContacts)) {
            i = contactOrContacts.length;
            while (i--) {
                if (contactOrContacts[i]._hidden) {
                    continue;
                }
                list.push(contactOrContacts[i]);
            }
        } else {
            list.push(contactOrContacts);
        }

        if (list.length === 0) {
            return;
        }

        if (list.length > $scope.tokens) {
            dialogs.confirm.show('You don\'t have enough Research Credits. Purchase more?').confirm(openStore);
            return;
        }

        if (silent) {
            researchAll();
        } else {

            var processedCount = 0;
            i = list.length;
            while (i--) {
                if (list[i]._enhanced) {
                    processedCount++;
                }
            }

            if (processedCount === list.length) {

                if (list.length === 1) {
                    dialogs.confirm.show('This Card has already been researched. Research anyway?').confirm(researchAll);
                } else {
                    dialogs.confirm.show('All ' + list.length + ' Cards have already been researched. Research anyway?').confirm(researchAll);
                }

            } else if (processedCount > 0) {

                var remainedCount = list.length - processedCount;

                if (remainedCount === 1) {
                    researchNew();
                } else {
                    dialogs.confirm.show('' + processedCount + ' of ' + list.length + ' Cards have already been researched. Research remaining ' + remainedCount + ' Cards?').confirm(researchNew);
                }

            } else {

                if (list.length === 1) {
                    researchAll();
                } else {
                    dialogs.confirm.show('Research ' + list.length + ' Cards?').confirm(researchAll);
                }

            }
        }


    };

    var updateContactWithResearchResult = function (contact, CN) {
        const functionName = 'Update Contact With Research Result';
        try {
            if (debug) { console.log(consolePrefix + functionName + '> Job ID > ' + contact._researchJobId + ' > Contact ID > ' + contact.id); }

            //var req, sf, del, hasChanges, json, x2js, cc, CN, i, n, j, before, flags, flagindex, pair, urlindex, status, exclude, dup, norm;
            var status, flags, flagindex, pair, urlindex;


            contact.emails = [];

            if (CN.Fields.LastName) { contact.last = CN.Fields.LastName; }
            if (CN.Fields.FirstName) { contact.first = CN.Fields.FirstName; }
            if (CN.Fields.MiddleName) { contact.middle = CN.Fields.MiddleName; }

            if (CN.Lists && CN.Lists.Phones) {
                //console.log('phones', CN.Lists.Phones);

                if (CN.Lists.Phones.Phone.length > 0) {

                    // Override
                    var newPhone1 = contactUtility.formatPhone(CN.Lists.Phones.Phone[0].Text);
                    var newPhone2 = '';
                    if (CN.Lists.Phones.Phone.length > 1) { newPhone2 = contactUtility.formatPhone(CN.Lists.Phones.Phone[1].Text); }

                    contact.phone = newPhone1;
                    contact.phone2 = newPhone2;

                }
                else {
                    if (CN.Lists.Phones.Phone && CN.Lists.Phones.Phone.Text) {
                        contact.phone = contactUtility.formatPhone(CN.Lists.Phones.Phone.Text);
                        contact.phone2 = '';
                    }
                }
            }
            if (CN.Fields.JobTitle) { contact.jobtitle = CN.Fields.JobTitle; }
            if (CN.Fields.Email) { contact.email = CN.Fields.Email; }
            if (CN.Lists && CN.Lists.AdditionalEmails) {
                if (debug) { console.log('AdditionalEmails', CN.Lists.AdditionalEmails, CN.Lists.AdditionalEmails.Email.length); }

                //if (CN.Lists.AdditionalEmails.Email.length > 0)
                //{ contact.email2 = CN.Lists.AdditionalEmails.Email; }

                if (Array.isArray(CN.Lists.AdditionalEmails.Email)) {
                    var emailIndex = 0;
                    while (emailIndex < CN.Lists.AdditionalEmails.Email.length) {
                        if (emailIndex === 0)
                        { contact.email2 = CN.Lists.AdditionalEmails.Email[emailIndex]; }
                        else
                        { contact.emails.push(CN.Lists.AdditionalEmails.Email[emailIndex]); }
                        emailIndex++;
                    }
                }
                else {
                    if (CN.Lists.AdditionalEmails.Email)
                    { contact.email2 = CN.Lists.AdditionalEmails.Email; }
                }

            }
            //if (CN.Fields.Bio) { contact.bio = CN.Fields.Bio; }
            if (CN.Fields.Biography) { contact.bio = CN.Fields.Biography; }
            if (CN.Fields.CompanyName) { contact.company = CN.Fields.CompanyName; }
            if (CN.Fields.Website) { contact.website = contactUtility.fixUrl(CN.Fields.Website); }
            if (CN.Fields.Revenue && CN.Fields.Revenue !== '$0 - $0') { contact.revenue = CN.Fields.Revenue; }
            if (CN.Fields.Employees) { contact.employees = CN.Fields.Employees; }
            if (CN.Fields.Industry) { contact.industry = CN.Fields.Industry; }

            if (CN.Fields.AddressLine1) { contact.address1 = CN.Fields.AddressLine1; }
            if (CN.Fields.AddressLine2) { contact.address2 = CN.Fields.AddressLine2; }
            if (CN.Fields.City) { contact.city = CN.Fields.City; }
            if (CN.Fields.PostalCode) { contact.zip = CN.Fields.PostalCode; }
            if (CN.Fields.State) { contact.state = CN.Fields.State; }
            if (CN.Fields.Country) { contact.country = contactUtility.formatCountry(CN.Fields.Country); }
            if (CN.Fields.User1) {

                var details = CN.Fields.User1 || '';

                contact.flags = details;

                try {
                    flags = details.split('\n')[0].split('|');
                } catch (e) {
                    console.log('****** ERROR spiltting flags *****', e.message, details);
                    flags = [];
                }

                flagindex = flags.length;
                while (flagindex--) {
                    pair = flags[flagindex].split(':');
                    if (pair[0] === 'phone1src') {
                        urlindex = parseInt(pair[1]);
                        //console.log(CN.Lists.AdditionalURLs);
                        if (CN.Lists.AdditionalURLs) {
                            if (Array.isArray(CN.Lists.AdditionalURLs.URL)) {
                                if (CN.Lists.AdditionalURLs.URL.length > urlindex) {
                                    contact.phone1src = CN.Lists.AdditionalURLs.URL[urlindex];
                                }
                            }
                            else {
                                contact.phone1src = CN.Lists.AdditionalURLs.URL;
                            }
                        }
                    } else if (pair[0] === 'phone2src') {
                        urlindex = parseInt(pair[1]);

                        if (CN.Lists[0].AdditionalURLs[0]) {
                            if (Array.isArray(CN.Lists[0].AdditionalURLs[0].URL)) {
                                if (CN.Lists[0].AdditionalURLs.URL.length > urlindex) {
                                    contact.phone2src = CN.Lists[0].AdditionalURLs[0].URL[urlindex];
                                }
                            }
                            else {
                                contact.phone2src = CN.Lists[0].AdditionalURLs[0].URL;
                            }
                        }
                    } else if (pair[0] === 'emailver') {
                        status = pair[1];
                        //console.log(CN.Lists.AdditionalURLs);
                        contact.emailver = status;
                    } else if (pair[0] === 'emailver2') {
                        status = pair[1];
                        //console.log(CN.Lists.AdditionalURLs);
                        contact.emailver2 = status;
                    } else if (pair[0] === 'email2ver') {
                        status = pair[1];
                        contact.email2ver = status;
                    } else if (pair[0] === 'email2ver2') {
                        status = pair[1];
                        contact.email2ver2 = status;
                    }

                }
            }

            if (CN.Lists && CN.Lists.Venues) {
                contact.venues = [];
                //console.log('Venues', CN.Lists.Venues);
                if (CN.Lists.Venues.Venue.length > 0) {
                    var vi = 0;
                    while (vi < CN.Lists.Venues.Venue.length) {
                        contactUtility.addVenue(contact, { website: contactUtility.fixUrl(CN.Lists.Venues.Venue[vi].Text), type: CN.Lists.Venues.Venue[vi].Type });
                        vi++;
                    }
                }
                else {
                    if (CN.Lists.Venues.Venue && CN.Lists.Venues.Venue.Text) {
                        contactUtility.addVenue(contact, { website: contactUtility.fixUrl(CN.Lists.Venues.Venue.Text), type: CN.Lists.Venues.Venue.Type });
                    }
                }
            }

            contactUtility.sortVenues(contact);

            if (CN.Lists && CN.Lists.AdditionalAddresses) {
                if (debug) { console.log('ADDRESSES', CN.Lists.AdditionalAddresses); }
                contact.addresses = [];
                if (CN.Lists.AdditionalAddresses.Address.length > 0) {

                    var ai = 0;
                    while (ai < CN.Lists.AdditionalAddresses.Address.length) {
                        contactUtility.addAddress(contact, {
                            address1: CN.Lists.AdditionalAddresses.Address[ai].AddressLine1,
                            address2: CN.Lists.AdditionalAddresses.Address[ai].AddressLine2,
                            city: CN.Lists.AdditionalAddresses.Address[ai].City,
                            zip: CN.Lists.AdditionalAddresses.Address[ai].PostalCode,
                            state: CN.Lists.AdditionalAddresses.Address[ai].State,
                            country: CN.Lists.AdditionalAddresses.Address[ai].Country
                        });
                        ai++;
                    }
                }
                else {
                    if (CN.Lists.AdditionalAddresses.Address && CN.Lists.AdditionalAddresses.Address.City) {
                        contactUtility.addAddress(contact, {
                            address1: CN.Lists.AdditionalAddresses.Address.AddressLine1,
                            address2: CN.Lists.AdditionalAddresses.Address.AddressLine2,
                            city: CN.Lists.AdditionalAddresses.Address.City,
                            zip: CN.Lists.AdditionalAddresses.Address.PostalCode,
                            state: CN.Lists.AdditionalAddresses.Address.State,
                            country: CN.Lists.AdditionalAddresses.Address.Country
                        });

                    }
                }
            }


        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };


    $scope.enhanceCallback = function (response) {

        //var req, sf, del, hasChanges, json, x2js, cc, CN, i, n, a, j, contact, before,
        //    flags, flagindex, pair, urlindex, status, exclude, dup, norm;

        var req, sf, del, hasChanges, json,
            flags, flagindex, pair, urlindex, status, exclude, dup;

        var invalidateLicense = function () {
            console.log('invalidateLicense');
            //chrome.storage.sync.get('license', function (value) {
            chromeUtility.getField('license', function (license) {
                console.log('************ invalidateLicense get', angular.copy(license));
                license.dateMS = null;
                //var o = { license: value };
                //chrome.storage.sync.set(o, function () {
                //    console.log('invalidateLicense set', angular.copy(o));
                //    var error = chrome.runtime.lastError;
                //    if (error)
                //    { console.log('ERROR in invalidateLicense (sync)', error); }
                //});

                chromeUtility.setField('license', license,

                function () {
                    console.log('**************** invalidateLicense set', angular.copy(license));
                },

                function (error) {
                    console.log('ERROR in invalidateLicense', error);
                }
            );

            });
        };

        sf = [];
        del = [];
        var norm = [];
        hasChanges = false;

        try {

            $scope.researchInProgress = false;

            json = response;

            console.log('Parsing research response of Job ', json.jobID);
            if (json.tokensLeft >= 0) {
                $scope.tokens = json.tokensLeft;
                mySharedService.broadcast('contactTokensLeft:' + json.tokensLeft);

                //try {
                //    invalidateLicense();
                //} catch (e) {
                //    console.log('ERROR in invalidateLicense', e.message);
                //}

            }

            if (!json.success) {
                console.log('ERROR returned by Research API: ', json.message);
            }
            else {

                if (!json.data) {
                    console.log('no _enhanced data returned');
                } else {

                    var x2js = new X2JS();
                    var cc = x2js.xml_str2json(json.data).Contacts.Contact;
                    var CN = null;
                    var n = cc.length || 1;

                    for (var i = 0; i < n; i++) {
                        CN = null;
                        if (cc.length) { CN = cc[i]; }
                        else { CN = cc; }

                        var extra = i > 0; // normally only one contact is returned - unless we do "profile" a website

                        var contact = null;
                        var j = $scope.contacts.length;
                        while (j--) {
                            if (parseInt($scope.contacts[j].id) === parseInt(CN.Fields.Handle)) { contact = $scope.contacts[j]; break; }
                        }
                        if (contact === null) {
                            console.error('ERROR! cannot find contact with id=', CN.Fields.Handle);
                            continue;
                        }

                        if (!extra) {
                            var before = angular.copy(contact);
                            updateContactWithResearchResult(contact, CN);
                            var after = angular.copy(contact);
                            if (debug) { console.log('Research Result > ', CN, ' > Before > ', before, ' > After > ', after); }
                            if (after !== before) {
                                hasChanges = true;
                            }
                            contact._enhanced = true;
                            norm.push(contact);
                        } else {

                            //var extraContact = contactUtility.createNewContact();
                            //updateContactWithResearchResult(extraContact, CN);
                            //extraContact.id = bgProcess.getValue('count');
                            //extraContact.mark = contact.mark;
                            //extraContact._enhanced = false;
                            //if (debug) { console.log('added', CN, angular.copy(extraContact)); }
                            //saveContact(extraContact);
                        }
                    }




                    /*

                    x2js = new X2JS();
                    cc = x2js.xml_str2json(json.data).Contacts.Contact;

                    n = cc.length || 1;

                    for (i = 0; i < n; i++) {
                        CN = null;
                        if (cc.length) { CN = cc[i]; }
                        else { CN = cc; }

                        a = null;
                        j = $scope.contacts.length;
                        while (j--) {
                            if (parseInt($scope.contacts[j].id) === parseInt(CN.Fields.Handle)) { a = $scope.contacts[j]; break; }
                        }

                        if (a === null) {
                            console.log('ERROR! cannot find contact with id=', CN.Fields.Handle);
                            continue;
                        }

                        contact = $scope.contacts[j];

                        before = angular.copy(contact);

                        if (contact._researchJob) {
                            delete contact._researchJob;
                        }
                        //contact._researchJob = null; //remove so the spinner goes away and the records won't be checked again

                        hasChanges = true;

                        contact.emails = [];

                        if (CN.Fields.LastName) { contact.last = CN.Fields.LastName; }
                        if (CN.Fields.FirstName) { contact.first = CN.Fields.FirstName; }

                        if (CN.Lists && CN.Lists.Phones) {
                            //console.log('phones', CN.Lists.Phones);

                            if (CN.Lists.Phones.Phone.length > 0) {

                                // Override
                                var newPhone1 = contactUtility.formatPhone(CN.Lists.Phones.Phone[0].Text);
                                var newPhone2 = '';
                                if (CN.Lists.Phones.Phone.length > 1) { newPhone2 = contactUtility.formatPhone(CN.Lists.Phones.Phone[1].Text); }

                                contact.phone = newPhone1;
                                contact.phone2 = newPhone2;

                            }
                            else {
                                if (CN.Lists.Phones.Phone && CN.Lists.Phones.Phone.Text) {
                                    contact.phone = contactUtility.formatPhone(CN.Lists.Phones.Phone.Text);
                                    contact.phone2 = '';
                                }
                            }
                        }
                        if (CN.Fields.JobTitle) { contact.jobtitle = CN.Fields.JobTitle; }
                        if (CN.Fields.Email) { contact.email = CN.Fields.Email; }
                        if (CN.Lists && CN.Lists.AdditionalEmails) {
                            if (debug) { console.log('AdditionalEmails', CN.Lists.AdditionalEmails, CN.Lists.AdditionalEmails.Email.length); }

                            //if (CN.Lists.AdditionalEmails.Email.length > 0)
                            //{ contact.email2 = CN.Lists.AdditionalEmails.Email; }

                            if (Array.isArray(CN.Lists.AdditionalEmails.Email)) {
                                var emailIndex = 0;
                                while (emailIndex < CN.Lists.AdditionalEmails.Email.length) {
                                    if (emailIndex === 0)
                                    { contact.email2 = CN.Lists.AdditionalEmails.Email[emailIndex]; }
                                    else
                                    { contact.emails.push(CN.Lists.AdditionalEmails.Email[emailIndex]); }
                                    emailIndex++;
                                }
                            }
                            else {
                                if (CN.Lists.AdditionalEmails.Email)
                                { contact.email2 = CN.Lists.AdditionalEmails.Email; }
                            }

                        }
                        //if (CN.Fields.Bio) { contact.bio = CN.Fields.Bio; }
                        if (CN.Fields.Biography) { contact.bio = CN.Fields.Biography; }
                        if (CN.Fields.CompanyName) { contact.company = CN.Fields.CompanyName; }
                        if (CN.Fields.Website) { contact.website = CN.Fields.Website; }

                        if (CN.Fields.AddressLine1) { contact.address1 = CN.Fields.AddressLine1; }
                        if (CN.Fields.AddressLine2) { contact.address2 = CN.Fields.AddressLine2; }
                        if (CN.Fields.City) { contact.city = CN.Fields.City; }
                        if (CN.Fields.PostalCode) { contact.zip = CN.Fields.PostalCode; }
                        if (CN.Fields.State) { contact.state = CN.Fields.State; }
                        if (CN.Fields.Country) { contact.country = CN.Fields.Country; }
                        if (CN.Fields.User1) {

                            var details = CN.Fields.User1 || '';

                            contact.flags = details;

                            try {
                                flags = details.split('\n')[0].split('|');
                            } catch (e) {
                                console.log('****** ERROR spiltting flags *****', e.message, details);
                                flags = [];
                            }

                            flagindex = flags.length;
                            while (flagindex--) {
                                pair = flags[flagindex].split(':');
                                if (pair[0] === 'phone1src') {
                                    urlindex = parseInt(pair[1]);
                                    //console.log(CN.Lists.AdditionalURLs);
                                    if (CN.Lists.AdditionalURLs) {
                                        if (Array.isArray(CN.Lists.AdditionalURLs.URL)) {
                                            if (CN.Lists.AdditionalURLs.URL.length > urlindex) {
                                                contact.phone1src = CN.Lists.AdditionalURLs.URL[urlindex];
                                            }
                                        }
                                        else {
                                            contact.phone1src = CN.Lists.AdditionalURLs.URL;
                                        }
                                    }
                                } else if (pair[0] === 'emailver') {
                                    status = pair[1];
                                    //console.log(CN.Lists.AdditionalURLs);
                                    contact.emailver = status;
                                } else if (pair[0] === 'emailver2') {
                                    status = pair[1];
                                    //console.log(CN.Lists.AdditionalURLs);
                                    contact.emailver2 = status;
                                } else if (pair[0] === 'email2ver') {
                                    status = pair[1];
                                    contact.email2ver = status;
                                } else if (pair[0] === 'email2ver2') {
                                    status = pair[1];
                                    contact.email2ver2 = status;
                                }

                            }
                        }

                        if (CN.Lists && CN.Lists.Venues) {
                            contact.venues = [];
                            //console.log('Venues', CN.Lists.Venues);
                            if (CN.Lists.Venues.Venue.length > 0) {
                                var vi = 0;
                                while (vi < CN.Lists.Venues.Venue.length) {
                                    $scope.addVenue(contact, { website: CN.Lists.Venues.Venue[vi].Text, type: CN.Lists.Venues.Venue[vi].Type });
                                    vi++;
                                }
                            }
                            else {
                                if (CN.Lists.Venues.Venue && CN.Lists.Venues.Venue.Text) {
                                    $scope.addVenue(contact, { website: CN.Lists.Venues.Venue.Text, type: CN.Lists.Venues.Venue.Type });
                                }
                            }
                        }

                        contactUtility.sortVenues(contact);

                        if (CN.Lists && CN.Lists.AdditionalAddresses) {
                            if (debug) { console.log('ADDRESSES', CN.Lists.AdditionalAddresses); }
                            contact.addresses = [];
                            if (CN.Lists.AdditionalAddresses.Address.length > 0) {

                                var ai = 0;
                                while (ai < CN.Lists.AdditionalAddresses.Address.length) {
                                    contactUtility.addAddress(contact, {
                                        address1: CN.Lists.AdditionalAddresses.Address[ai].AddressLine1,
                                        address2: CN.Lists.AdditionalAddresses.Address[ai].AddressLine2,
                                        city: CN.Lists.AdditionalAddresses.Address[ai].City,
                                        zip: CN.Lists.AdditionalAddresses.Address[ai].PostalCode,
                                        state: CN.Lists.AdditionalAddresses.Address[ai].State,
                                        country: CN.Lists.AdditionalAddresses.Address[ai].Country
                                    });
                                    ai++;
                                }
                            }
                            else {
                                if (CN.Lists.AdditionalAddresses.Address && CN.Lists.AdditionalAddresses.Address.City) {
                                    contactUtility.addAddress(contact, {
                                        address1: CN.Lists.AdditionalAddresses.Address.AddressLine1,
                                        address2: CN.Lists.AdditionalAddresses.Address.AddressLine2,
                                        city: CN.Lists.AdditionalAddresses.Address.City,
                                        zip: CN.Lists.AdditionalAddresses.Address.PostalCode,
                                        state: CN.Lists.AdditionalAddresses.Address.State,
                                        country: CN.Lists.AdditionalAddresses.Address.Country
                                    });

                                }
                            }
                        }

                        if (debug) { console.log('enhanced', CN, before, angular.copy(contact)); }
                        contact._enhanced = true;

                        // check exclusions
                        exclude = $scope.shouldExclude(contact);

                        if (exclude) {
                            if (debug) { console.log('EXCLUDED!'); }
                            del.push(contact);
                            continue;
                        }

                        // see if name did change and we should merge
                        dup = $scope.duplicateOf(contact);
                        if (dup) {
                            $scope.merge(dup, contact);
                            del.push(contact);
                            continue;
                        }
                        // end of merge


                        if (!exclude && !contact._searched)
                        { sf.push(contact); }

                        norm.push(contact);
                        //}
                    }*/


                }
            }
        } catch (e) {
            console.log('ERROR in enhance callback (parsing)', e, req);
        }

        if (del) {
            $scope.deleteContacts(del, true);
        }

        $scope.updateMarks();

        if (!$scope.$$phase) { $scope.$apply(); }

        if (hasChanges)
        { $scope.saveHistory(); }

        if (debug) { console.log('NORM', norm); }
        if (norm) {
            $scope.normalize(norm);
        }

    };

    $scope.addVenue = function (contact, venue) {
        contactUtility.addVenue(contact, venue);
        //contact.venues = contact.venues || [];
        //if (venue && venue.website) {
        //    var i = contact.venues.length;
        //    while (i--) {
        //        if (contact.venues[i].website === venue.website) { return; }
        //    }
        //    contact.venues.push(venue);
        //}
    };

    $scope.applyAddress = function (contact, address) {

        var current = {
            address1: contact.address1,
            address2: contact.address2,
            city: contact.city,
            state: contact.state,
            zip: contact.zip,
            country: contact.country
        };

        contactUtility.addAddress(contact, current);

        contact.address1 = address.address1;
        contact.address2 = address.address2;
        contact.city = address.city;
        contact.state = address.state;
        contact.zip = address.zip;
        contact.country = address.country;

        if (debug) { console.log('REPLACED ADDRESS', current, 'WITH', address, angular.copy(contact)); }

        $scope.saveHistory();

    };

    //  Convert contact to multimerge candidate
    var contactToCandidate = function (contact, display) {
        var candidate = { fieldValues: {} };
        candidate.id = (contact.id ? contact.id : display);
        candidate.display = display;
        candidate.fieldValues.FirstName = contact.first;
        candidate.fieldValues.MiddleName = contact.middle;
        candidate.fieldValues.LastName = contact.last;
        candidate.fieldValues.Title = contact.jobtitle;
        candidate.fieldValues.Company = contact.company;
        candidate.fieldValues.Email = contact.email;
        candidate.fieldValues.Phone = contact.phone;
        candidate.fieldValues.MobilePhone = contact.phone2;
        candidate.fieldValues.Website = contact.website;
        candidate.fieldValues.Description = contact.bio;
        candidate.fieldValues.Street = contact.address1;
        candidate.fieldValues.City = contact.city;
        candidate.fieldValues.State = contact.state;
        candidate.fieldValues.PostalCode = contact.zip;
        candidate.fieldValues.Country = contact.country;
        candidate.fieldValues.Linkedin = contactUtility.getVenue(contact, 'linkedin.com');
        candidate.fieldValues.Facebook = contactUtility.getVenue(contact, 'facebook.com');
        candidate.fieldValues.Twitter = contactUtility.getVenue(contact, 'twitter.com');
        candidate.fieldValues.GooglePlus = contactUtility.getVenue(contact, 'google.com');
        candidate.fieldValues.Myspace = contactUtility.getVenue(contact, 'myspace.com');
        candidate.fieldValues.Pinterest = contactUtility.getVenue(contact, 'pinterest.com');
        candidate.fieldValues.MyLife = contactUtility.getVenue(contact, 'mylife.com');
        candidate.fieldValues.Xing = contactUtility.getVenue(contact, 'xing.com');
        candidate.fieldValues.Industry = contact.industry;
        candidate.fieldValues.Employees = contact.employees;
        candidate.fieldValues.EmployeesAvg = contactUtility.getEmployeesAvg(contact.employees);
        candidate.fieldValues.Revenue = contact.revenue;
        candidate.fieldValues.RevenueAvg = contactUtility.getRevenueAvg(contact.revenue);
        return candidate;
    };
    var candidateToContact = function (candidate) {
        var contact = {};
        candidate = candidate.fieldValues;
        contact.first = candidate.FirstName;
        contact.middle = candidate.MiddleName;
        contact.last = candidate.LastName;
        contact.jobtitle = candidate.Title;
        contact.company = candidate.Company;
        contact.email = candidate.Email;
        contact.phone = candidate.Phone;
        contact.phone2 = candidate.MobilePhone;
        contact.website = candidate.Website;
        contact.bio = candidate.Description;
        contact.address1 = candidate.Street;
        contact.city = candidate.City;
        contact.state = candidate.State;
        contact.zip = candidate.PostalCode;
        contact.country = candidate.Country;
        contact.linkedin = candidate.Linkedin;
        contact.facebook = candidate.Facebook;
        contact.twitter = candidate.Twitter;
        contact.googlePlus = candidate.GooglePlus;
        contact.myspace = candidate.Myspace;
        contact.pinterest = candidate.Pinterest;
        contact.myLife = candidate.MyLife;
        contact.xing = candidate.Xing;
        contact.industry = candidate.Industry;
        contact.employees = candidate.Employees;
        contact.employeesAvg = candidate.EmployeesAvg;
        contact.revenue = candidate.Revenue;
        contact.revenueAvg = candidate.RevenueAvg;
        return contact;
    };

    //  Convert salesforce object to a multimerge candidate
    var salesforceToCandidate = function (contact) {
        var candidate = { fieldValues: {} };
        candidate.id = 'contact.Id';
        candidate.display = 'Salesforce';
        for (var fieldKey in contact) {
            candidate.fieldValues[fieldKey] = contact[fieldKey];
        }
        return candidate;
    };

    //  Convert multimerge candidate to salesforce object
    var candidateToSalesforce = function (candidate, objectType) {
        var contact = {};
        if (debug) { console.log('objectType:', objectType); }
        for (var fieldKey in candidate.fieldValues) {
            if (objectType === 'contact') {
                if (fieldKey === 'Website') { continue; }
            }
            contact[fieldKey] = candidate.fieldValues[fieldKey];
        }
        return contact;
    };


    $scope.mergeDups = function (contact, objType, crmRecordId) {
        if (debug) { console.log('Merging into ' + crmRecordId); }

        var exportService = $scope.export.getExportService();

        if (!exportService) {
            dialogs.alert.show('Export target is not set up. Please check your settings.');
            return;
        }

        showLoader();

        //dialogs.busy.show('Testing merge capabilities');
        //  Login Check
        exportService.isLoggedIn(
            //  Login success!
            function () {
                $scope.targetConnected = true;
                //  Get object definitions
                exportService.getDefinition(objType,
                    //  Definitions retrieved!
                    function (definition) {
                        if (debug) { console.log('Definition', objType, definition); }
                        //  Retireve CRM record
                        exportService.retrieveRecord(crmRecordId, objType,
                            //  Record retrieved!
                            function (record) {
                                if (debug) { console.log('CRM Record (Native) > ', angular.copy(record)); }
                                docSize.pushWidth(800);

                                var crmConvertedRecord = exportService.fromNativeRecord(record, objType);
                                if (debug) { console.log('CRM Record (Converted) > ', angular.copy(crmConvertedRecord)); }

                                var candidate1 = contactToCandidate(crmConvertedRecord, $scope.export.name);
                                if (debug) { console.log('CRM Record (Candidate) > ', angular.copy(candidate1)); }

                                var candidate2 = contactToCandidate(contact, 'Captured');
                                if (debug) { console.log('Capture Record (Candidate) > ', angular.copy(candidate2)); }

                                var candidates = [candidate1, candidate2];
                                if (debug) { console.log('Candidates', angular.copy(candidates)); }

                                //dialogs.busy.hide();

                                $timeout(function () {
                                    multimerge.merge(definition, candidates,
                                        //  Merge confirmed
                                        function (winningCandidate) {
                                            console.log('Do Merge > ', winningCandidate);
                                            docSize.popWidth();
                                            var winningContact = candidateToContact(winningCandidate);
                                            //var  sfWinner = candidateToSalesforce(winner, objType);
                                            // Begin the CRM update
                                            //dialogs.busy.show('Merging...');
                                            var nativeRecord = exportService.toNativeRecord(winningContact, objType);
                                            exportService.updateRecord(crmRecordId, objType, nativeRecord,
                                                // Update success!
                                                function (response) {
                                                    //dialogs.busy.hide();
                                                    totangoService.sendEvent('merge');

                                                    var deleteCards = function () {
                                                        var skipPrompt = true;
                                                        $scope.deleteContacts([contact], skipPrompt);
                                                    };

                                                    var successMessage = $scope.export.name + ' merge successful!';

                                                    $timeout(function () {
                                                        try {
                                                            if ($scope.settings.deleteAfterExport !== 'Never') {

                                                                if ($scope.settings.deleteAfterExport === 'Always') {
                                                                    dialogs.alert.show(successMessage);
                                                                    deleteCards();
                                                                } else {
                                                                    dialogs.confirm.show(successMessage + ' Would you like to delete this Card?')
                                                                        .confirm(deleteCards);
                                                                }
                                                            } else {
                                                                dialogs.alert.show(successMessage);
                                                            }
                                                        } catch (e) {
                                                            console.error('ERROR in DELETE OPTION', e.message);
                                                        }
                                                    }, 1000);

                                                },
                                                // Update failed!
                                                function (error) {
                                                    dialogs.busy.hide();
                                                    //dialogs.busy.hide();
                                                    console.error('Update Record > ', error);
                                                    $timeout(function () {
                                                        dialogs.alert.show(error);
                                                    }, 1000);
                                                }, record);
                                        },
                                        //  Merge cancelled
                                        function () {
                                            console.warn('Cancel Merge');
                                            docSize.popWidth();
                                        });
                                }, 100);
                            },
                            //  Failed to retrieve record
                            function (error, status) {
                                console.error('CRM Record Retrieve Error > ', error, status);
                                dialogs.busy.hide();
                                $timeout(function () {
                                    if (status === 401) {
                                        console.log('presenting login');

                                        dialogs.confirm.show('Please login to ' + $scope.export.name + '!').confirm(exportService.login);

                                    } else {
                                        dialogs.alert.show(error);
                                    }
                                }, 1000);

                            });

                    },
                    //  Failed to retrieve definitions
                    function (error) {
                        dialogs.busy.hide();
                        console.error('Get Definitions > ', error);
                        $timeout(function () {
                            dialogs.alert.show('An error occurred when retrieving the definition from ' + $scope.export.name);
                        }, 1000);
                    });
            },
            //  Failed login
            function (error) {
                $scope.targetConnected = false;
                dialogs.busy.hide();
                console.error('Log In Error > ', error);
                $timeout(function () {
                    dialogs.confirm.show('Please login to ' + $scope.export.name + '!').confirm(function () {
                        exportService.login(function () { }, function (error) {
                            console.log('ERROR in exportService.login', error);
                            dialogs.alert.show(error);
                        });
                    });
                }, 1000);

            });


    };


    var updateActionProgress = function (action) {
        try {
            $scope.runtime[action].done++;
            $scope.runtime[action].progress = Math.round(100.0 * $scope.runtime[action].done / $scope.runtime[action].total);
            if ($scope.runtime[action].done >= $scope.runtime[action].total) {
                $timeout(function () {
                    hideActionProgress(action);
                }, 3000);
            }
        } catch (e) {
            console.error('Update Action Progress > ', e.message);
        }
    };
    var showActionProgress = function (action, total) {
        try {
            $scope.runtime[action] =
                $scope.runtime[action] ||
                {
                    done: 0,
                    total: 0,
                    progress: 0
                };
            $scope.runtime[action].active = true;
            //$scope.runtime[action].done = 0;
            $scope.runtime[action].total = ($scope.runtime[action].total || 0) + (total || 0);
            //$scope.runtime[action].progress = 0;           
        } catch (e) {
            console.error('Init Action Progress > ', e.message);
        }
    };
    var hideActionProgress = function (action) {
        try {
            $scope.runtime[action].active = false;
            $scope.runtime[action].done = 0;
            $scope.runtime[action].total = 0;
            $scope.runtime[action].progress = 0;
        } catch (e) {
            console.error('Update Action Progress > ', e.message);
        }
    };

    $scope.findDups = function (contactOrContacts, successCallback, failureCallback) {


        //var f = function() {

        var contacts = [];

        if (Array.isArray(contactOrContacts)) {
            var i = contactOrContacts.length;
            while (i--) {
                if (contactOrContacts[i]._hidden) { continue; }
                contacts.push(contactOrContacts[i]);
            }
        }
        else {
            contacts.push(contactOrContacts);
        }

        if (contacts.length < 1) {
            return;
        }

        showActionProgress('search', contacts.length);

        var foundRecords = [];

        var exportService = $scope.export.getExportService();

        if (!exportService) {
            failureCallback();
            return;
        }

        var findLink = function (contacts) {

            if (!contacts || contacts.length === 0) {
                if (debug) { console.log('Duplicates search over'); }
                if (!$scope.$$phase) { $scope.$apply(); }
                $scope.saveHistory();
                hideActionProgress('search');
                if (successCallback) { successCallback(foundRecords); }
                return;
            }

            var contact = contacts.pop();

            contact.links = [];
            contact._searched = false;
            contact._searching = true;
            updateActionProgress('search');

            if (debug) { console.log('Searching for duplicates', contact); }

            var findDuplicateContacts = function () {

                exportService.findDuplicates('Contact', contact, function (response) {
                    // success
                    if (debug) { console.log('Found duplicate contacts', angular.copy(response), contact.links); }
                    var crmRecords = response.duplicates;
                    if (!contact.links) { contact.links = []; }
                    var i = 0;
                    while (i < crmRecords.length) {
                        var crmRecord = crmRecords[i];
                        var found = false;
                        var j = contact.links.length;
                        while (j--) {
                            if (contact.links[j]._link === crmRecord._link)
                            { found = true; break; }
                        }
                        if (!found) {
                            contact.links.push(crmRecord);
                            foundRecords.push(crmRecord);
                        }
                        i++;
                    }

                    contact._searching = false;
                    contact._searched = true;
                    findLink(contacts);

                }, function (error) {
                    // failure
                    console.error('ERROR in duplicate search', error);
                    contact._searching = false;
                    contact._searched = true;
                    if (error)
                    { dialogs.alert.show(error); }
                    else
                    { findLink(contacts); }


                });

            };

            exportService.findDuplicates('Lead', contact, function (response) {
                // success

                if (debug) { console.log('Found duplicate leads', angular.copy(response), contact.links); }

                //var contact = response.contact;
                var crmRecords = response.duplicates;


                if (!contact.links) { contact.links = []; }
                var i = 0;
                while (i < crmRecords.length) {
                    var crmRecord = crmRecords[i];
                    var found = false;
                    var j = contact.links.length;
                    while (j--) {
                        if (contact.links[j]._link === crmRecord._link)
                        { found = true; break; }
                    }
                    if (!found) {
                        contact.links.push(crmRecord);
                        foundRecords.push(crmRecord);
                    }


                    /*{
                            id: contact.links.length + 1,
                            name: sflead.first + ' ' + sflead.last,
                            company: sflead.company,
                            email: sflead.email,
                            _type: 'lead',
                            _link: $scope.sf.url + '/' + sflead.Id,
                            _sfid: sflead.Id
                        });*/


                    i++;
                }

                findDuplicateContacts();

            }, function (error) {
                // failure
                console.error('ERROR in duplicate search', error);
                if (error) {
                    contact._searching = false;
                    contact._searched = true;
                    dialogs.alert.show(error);
                }
                else { findDuplicateContacts(); }
            });

        };

        exportService.isLoggedIn(

            // we are logged in already
            function () {
                $scope.targetConnected = true;
                findLink(contacts);
            },

            // we are not logged in yet
            function () {
                $scope.targetConnected = false;
                dialogs.confirm
                    .show('Please login to ' + $scope.export.name + '!')
                    .confirm(

                        // try to login
                        function () {
                            exportService.login(

                                // login success
                                function () {
                                    $scope.targetConnected = true;
                                    findLink(contacts);
                                },

                                // login failure
                                function (msg) {
                                    dialogs.alert.show(msg);
                                    if (failureCallback) { failureCallback('Cannot login to ' + $scope.export.name + '!'); }
                                });
                        }

                    )
                    .cancel(

                        // user declined the login attempt
                        function () {
                            if (failureCallback) { failureCallback('Please login to ' + $scope.export.name + '!'); }
                        }

                    );


            });

    };

    $scope.deleteContacts = function (contact, skipprompt) {

        var finish = function () {


            //$timeout(function () {

            $scope.setFilteredContacts();

            try {
                mySharedService.broadcast('runtime:contactsCount:' + $scope.contacts.length);
                //chrome.browserAction.setBadgeBackgroundColor({ color: '#5cb85c' });
                //chrome.browserAction.setBadgeText({ text: ($scope.contacts.length > 0 ? '' + $scope.contacts.length : '') });
                //chrome.browserAction.setBadgeText({ text: '' });
            } catch (e) {
                console.log('EEROR in delete->broadcast', e.message);
            }

            try {
                $scope.saveHistory();
            } catch (e) {
                console.log('ERROR in delete->save history', e.message);
            }

            if (debug) { console.log('existing contacts', angular.copy($scope.contacts.length), angular.copy($scope.contacts)); }

            $scope.updateMarks();

            //}, 500);

        };

        var deleteOne = function (c) {
            if (debug) { console.log('deleting one', angular.copy(c)); }
            try {
                var i = $scope.contacts.length;
                var found = false;
                while (i--) {
                    if ($scope.contacts[i] === c) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    //if (debug) console.log('deleting contact', i, $scope.contacts[i]);
                    $scope.contacts.splice(i, 1);
                    $scope.filteredCount--;
                } else {
                    console.log('ERROR: deleting contact error - NOT FOUND!', angular.copy(c));
                }
            } catch (e) {
                console.log('ERROR while deleting ', e, i, contact[j]);
            }
        };

        var deleteMany = function (contactsToDelete, callback) {
            if (debug) { console.log('deleting many', angular.copy(contactsToDelete)); }
            var i = contactsToDelete.length;
            while (i--) {
                deleteOne(contactsToDelete[i]);
            }

            if (callback)
            { callback(); }

        };

        var contacts = [];

        if (Array.isArray(contact)) {
            var i = contact.length;
            while (i--) {
                if (contact[i]._hidden) { continue; }
                contacts.push(contact[i]);
            }
        }
        else {
            contacts.push(contact);
        }

        var j = contacts.length;
        if (j === 0) { return; }
        //if (j === 1) { skipprompt = true; }

        if (skipprompt) {
            deleteMany(contacts, finish);
        }
        else {

            var ending = j === 1 ? '' : 's';
            //var deletePrompt = 'Are you absolutely sure you want to delete ' + j + ' contact' + ending + '?';
            var deletePrompt = 'Delete ' + j + ' contact' + ending + '?';

            dialogs.confirm.show(deletePrompt)
                .confirm(function () {
                    deleteMany(contacts, finish);
                });
        }

    };

    $scope.reloadPage = function () {
        $scope.reload = false;
        // reloads chrome tab
        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
            function (tabs) {
                if (debug) { console.log('get chrome tabs callback'); }
                if (!tabs || tabs.length === 0) {
                    return;
                }
                var tab = tabs[0];
                chrome.tabs.reload(tab.id);
            });
    };

    $scope.loadPage = function (url, openInSFTab, capture) {

        if (debug) { console.log('opening page', url); }

        if (url && url.indexOf('http') !== 0) { url = 'http://' + url; }


        var callback = function () { };
        var f = function (tabs) {

            var props2 = { url: url };

            if (!tabs || tabs.length === 0)
            { chrome.tabs.create(props2, callback); }
            else
            { chrome.tabs.update(tabs[0].id, props2, callback); }

            if (capture) {

                $timeout(function () {

                    mySharedService.broadcast('captureNow');

                }, 4000);

            }
        };

        var props1 = { windowId: chrome.windows.WINDOW_ID_CURRENT };

        if (openInSFTab)
        { props1.url = 'https://*.salesforce.com/*'; }
        else
        { props1.active = true; }

        chrome.tabs.query(props1, f);
    };

    $scope.canDive = function (contact) {
        //contact._diveable
        return true;
    };

    $scope.dived = function (contact) {
        if (!contact) { return false; }
        return contact._dived;
    };

    $scope.dive = function (contact, url) {

        if (!contact) { return; }
        // has LI?

        if (!url)
        { url = contact.sourceurl; }

        //var url = null;

        if (!url) { // old way, for compatibility only
            if (contact.venues) {
                for (var i = 0; i < contact.venues.length; i++) {
                    if (contact.venues[i].website.indexOf('linkedin.com') !== -1)
                    { url = contact.venues[i].website; break; }
                }
            }
        }

        //if (!url && contact.sourceurl)
        //{ url = contact.sourceurl; }


        if (url) {
            contact._dived = true;
            //loadPage(contact.sourceurl, false, true);
            $scope.loadPage(url, false, true);
            //focus($index);
            $scope.focusOnContact(contact);
        }

    };

    $scope.hl = function (contact) {
        //var css = 'background-color: rgb(255, 251, 204);';
        if (!contact) { return; }
        var url = contact.sourceurl;
        if (!url) { return; }
        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
            function (tabs) {
                if (!tabs || tabs.length === 0) { return; }
                chrome.tabs.sendRequest(tabs[0].id, { method: 'highlightGoogleResult' + url }, function (response) { });
            });
    };

    $scope.focus = function (index) {

        $timeout(function () {

            //$location.hash(index ? 'anchor_row_' + index : null);
            //$anchorScroll();

            var element = document.getElementById('anchor_row_' + (index || 'top'));
            if (element) { window.scrollTo(0, element.offsetTop - 100); }

        }, 100);
    };

    $scope.focusOnContact = function (contact) {

        var index = -1;

        var i = $scope.pageOfFilteredContacts.length;
        while (i--) {
            if ($scope.pageOfFilteredContacts[i] === contact)
            { index = i; break; }
        }

        if (index === -1) { return; }

        $timeout(function () {

            var element = document.getElementById('anchor_row_' + (index || 'top'));
            if (element) { window.scrollTo(0, element.offsetTop - 100); }

        }, 100);
    };

    $scope.filterBy = function (filter) {

        filter = (filter ? filter : '').toLowerCase();
        if (debug) { console.log('Filter=' + filter); }
        $scope.filterText = filter;

        $scope.activeMark = $scope.markAll;

        var f = 0;
        var i = $scope.contacts.length;
        $scope.filteredCount = 0;
        while (i--) {
            var c = $scope.contacts[i];

            if (!filter) {
                c._hidden = false;
                $scope.filteredCount++;
            } else {
                if (
                    (c.first ? c.first : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.last ? c.last : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.company ? c.company : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.jobtitle ? c.jobtitle : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.email ? c.email : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.website ? c.website : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.sourceurl ? c.sourceurl : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.phone ? c.phone : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.phone2 ? c.phone2 : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.address1 ? c.address1 : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.address2 ? c.address2 : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.city ? c.city : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.state ? c.state : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.zip ? c.zip : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.country ? c.country : '').toLowerCase().indexOf(filter) >= 0 ||
                    (c.mark ? c.mark : '').toLowerCase().indexOf(filter.replace('[', '').replace(']', '')) >= 0
                ) {
                    c._hidden = false;
                    $scope.filteredCount++;
                } else {
                    c._hidden = true;
                    f++;
                }
            }

        }
        if (debug) { console.log('filtered out', f); }

        $scope.setFilteredContacts();

        if (!$scope.$$phase) { $scope.$apply(); }

    };

    $scope.search = function (where, contact) {
        var s = [];

        var siteMap = {
            'linkedin': 'site:linkedin.com "Search for people you know"',//'site:linkedin.com/in -dir/pub',
            'twitter': 'site:twitter.com',
            'facebook': 'site:facebook.com',
            'blog': 'blog',
            'youtube': 'site:youtube.com',
            'skype': 'site:skype.com',
            'foursquare': 'site:foursquare.com',
            'googleplus': 'site:plus.google.com'
        };

        var site = siteMap[where];
        if (site) {
            s.push('https://google.com/search?q=');
            s.push(site);
            s.push('"' + contact.first + ' ' + contact.last + '"');
            if (contact.company) {
                if (where === 'linkedin')
                { s.push('"at ' + contact.company + '"'); }
                else
                { s.push('"' + contact.company + '"'); }
            }

            $scope.loadPage(s.join(' ').replace(/ /g, '+'));
        }
    };

    $scope.showMark = function (mark) {

        // takes all contacts and marks as hidden all that have different mark

        var changed = $scope.activeMark !== mark;

        if (debug) { console.log(debug + 'filtering by mark = ' + mark, changed); }

        $scope.activeMark = mark;

        // reset filter too
        if (mark === $scope.markAll)
        { $scope.filterText = ''; }
        else
        { $scope.filterText = '[' + mark + ']'; }

        var f = 0;
        var i = $scope.contacts.length;
        $scope.filteredCount = 0;
        while (i--) {
            var c = $scope.contacts[i];

            if (c.mark === mark || mark === $scope.markAll) {
                c._hidden = false;
                $scope.filteredCount++;
            } else {
                c._hidden = true;
                f++;
            }
        }

        if (debug) { console.log('filtered out (by mark)', f); }

        $scope.setFilteredContacts();

        if (changed)
        { $scope.saveMark(); }

        if (!$scope.$$phase) { $scope.$apply(); }

    };

    $scope.applyMarkToContacts = function (mark, contacts, callback) {
        for (var index in contacts) {
            contacts[index].mark = mark;
        }
        $scope.updateMarks();
        $scope.saveHistory();
        if (callback) { callback(); }
    };

    $scope.applyMark = function (newMark, contact, callback) {

        // takes visible contacts and changes mark to new one

        if (newMark === $scope.markAll) { return; }// invalid value
        if (newMark === $scope.markNew) { return; }// invalid value

        var cc = [];

        if (contact === null) {

            var i = $scope.contacts.length;
            while (i--) {
                if ($scope.contacts[i]._hidden) { continue; }
                cc.push($scope.contacts[i]);
            }

        } else if (!Array.isArray(contact)) {
            cc.push(contact);
        }
        else {
            cc = contact;
        }

        var j = cc.length;
        if (debug) { console.log('Apply Mark = ' + newMark + ' to ' + j + ' records'); }

        if (j === 0) { return; }

        var cb = function () {
            for (var i = 0; i < j; i++)
            { cc[i].mark = newMark; }
            $scope.updateMarks();
            $scope.saveHistory();
            //$scope.markConfirmDlg.show = false;
            if (callback) { callback(); }
        };

        if (j === 1) {
            cb();
        }
        else {

            //$scope.markConfirmDlg.mark = newMark;
            //$scope.markConfirmDlg.count = j;
            //$scope.markConfirmDlg.ending = j > 1 ? 's' : '';
            //$scope.markConfirmDlg.callback = cb;
            //$scope.markConfirmDlg.show = true;
            //$scope.focus();

            cb();
        }

    };

    $scope.removeMark = function () {

        $scope.applyMark($scope.markDefault, null, function () {
            $scope.showMark($scope.markDefault);
        });
    };

    $scope.showNewMarkDlg = function (contact) {

        dialogs.text.show({ message: 'Enter new list name' }).confirm(function (value) {
            if (debug) { console.log(debug + 'newList->' + value); }
            $scope.marks.push(value);
            $scope.updateMarks();

            if (Array.isArray(contact) && contact.length === 0) {
                // add new list only, do not apply to any items
                $scope.saveHistory();
                $scope.showMark(value);
            } else {
                $scope.applyMark(value, contact, function () {
                    $scope.saveHistory();
                    $scope.showMark(value);
                });
            }

        });
    };

    $scope.applyExistingMark = function (mark) {

        $scope.applyMark(mark, null, function () {
            $scope.showMark(mark);
        });

        //$scope.applyMark($scope.markNewDlg.text, null, function () {
        //    $scope.showMark($scope.markNewDlg.text);
        //    $scope.markNewDlg.show = false;
        //});
    };

    $scope.updateMarks = function () {

        if (debug) { console.log(debug + 'updateMarks', angular.copy($scope.marks)); }

        var m,
            i = $scope.marks.length;

        // dedupe marks, remove default
        while (i--) {
            m = $scope.marks[i];
            if (!m || $scope.marks.indexOf(m) !== i || m === $scope.markDefault || m === $scope.markAll)
            { $scope.marks.splice(i, 1); }
        }

        // add new marks from contacts
        i = $scope.contacts.length;
        while (i--) {
            m = $scope.contacts[i].mark;
            if (!m) { continue; }
            if (m === $scope.markDefault) { continue; }
            if (m === $scope.markAll) { continue; }
            if ($scope.marks.indexOf(m) < 0)
            { $scope.marks.push(m); }
        }

        $scope.marks.sort();

    };

    $scope.toggleShowDups = function (contact) {

        if (debug) { console.log('Showing duplicates'); }

        if (contact) {
            if (!contact._searched)
            { $scope.findDups(contact); }
        }
    };

    $scope.renameList = function (oldMark) {

        var renamingActiveMark = oldMark === $scope.activeMark;

        dialogs.text.show({ message: 'Rename list to', value: oldMark }).confirm(function (value) {

            if (debug) { console.log('Rename List to ' + value); }

            var i, m, newMark = value;

            if (!newMark) { return; }
            if (newMark === $scope.markAll) { return; }// invalid value
            if (newMark === $scope.markNew) { return; }// invalid value
            if (newMark === $scope.markDefault) { return; }// invalid value

            // update the list of marks 
            i = $scope.marks.length;
            while (i--) {
                m = $scope.marks[i];
                // remove dups, empty ones and default
                if (!m || $scope.marks.indexOf(m) !== i || m === $scope.markDefault)
                { $scope.marks.splice(i, 1); }
                // replace old with new one
                if (m === oldMark)
                { $scope.marks[i] = newMark; }
            }

            // update contacts: replace old mark with new mark
            i = $scope.contacts.length;
            while (i--) {
                m = $scope.contacts[i].mark;
                if (!m) { continue; }
                if (m === oldMark)
                { $scope.contacts[i].mark = newMark; }
            }

            // sort
            $scope.marks.sort();

            // switch view
            if (renamingActiveMark) {
                $scope.showMark(newMark);
            }

            $scope.saveHistory();

        });

    };

    $scope.deleteList = function (mark) {

        var ending, msg,
            itemCount = 0,
            i = $scope.contacts.length;

        var deletingActiveMark = mark === $scope.activeMark;

        var cb = function () {

            var m,
                i = $scope.marks.length;

            // update the list of marks
            while (i--) {
                m = $scope.marks[i];
                if (m === mark)
                { $scope.marks.splice(i, 1); }
            }

            // update the list of contacts; move items with deleted mark to default list
            i = $scope.contacts.length;
            while (i--) {
                if ($scope.contacts[i].mark === mark) {
                    $scope.contacts[i].mark = $scope.markDefault;
                }
            }

            // change view
            if (deletingActiveMark) {
                $scope.activeMark = $scope.markDefault;
                $scope.showMark($scope.markDefault);
            }

            $scope.saveHistory();
        };


        while (i--) {
            if (!$scope.contacts[i]._hidden)
            { itemCount++; }
        }

        if (itemCount === 0)
        { cb(); }
        else {
            ending = itemCount > 1 ? 's' : '';
            msg = 'Delete list [' + mark + '] and move ' + itemCount + ' Card' + ending + ' to the Default list?';
            dialogs.confirm.show(msg).confirm(cb);
        }

    };

    $scope.newContact = function () {
        dialogs.contacts.edit.show({})
            .confirm(function (c) {
                var contacts = [c];

                if (c.company && c.website) {
                    lookupService.logCompanyWebsite(c.company, c.website);
                }

                contactUtility.addContacts(contacts, null, false);
                if (!$scope.$$phase) { $scope.$apply(); }
            });
    };

    var updateWebsites = function (company, website) {
        const functionName = 'Update Websites';

        try {

            if (!company || !website) {
                return;
            }

            console.log(consolePrefix + functionName + ' > New Values > ', company, website);

            angular.forEach($scope.contacts, function (contact) {
                if (contact.company === company || contact.website === website) {
                    console.log(consolePrefix + functionName + ' > Old Values > ', contact.company, contact.website);
                    contact.company = company;
                    contact.website = website;
                } else if ((!contact.company || !contact.website) && contact.email && contact.email.indexOf('@' + website) > 0) {
                    console.log(consolePrefix + functionName + ' > Old Values (Email Match) > ', contact.company, contact.website);
                    contact.company = company;
                    contact.website = website;
                }
            });

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }

    };

    $scope.editContact = function (contact) {
        dialogs.contacts.edit.show(angular.copy(contact))
            .confirm(function (c) {

                // Website was updated? Report it.
                if (c.company && c.website && c.website !== contact.website) {
                    lookupService.logCompanyWebsite(c.company, c.website);
                }

                // remove email verification result if email was edited
                if (contact.email !== c.email) {
                    contact.emailver = null;
                    contact.emailver2 = null;
                }

                if (contact.email2 !== c.email2) {
                    contact.email2ver = null;
                    contact.email2ver2 = null;
                }

                contact.first = c.first;
                contact.middle = c.middle;
                contact.last = c.last;
                contact.jobtitle = c.jobtitle;
                contact.company = c.company;
                contact.email = c.email;
                contact.email2 = c.email2;
                contact.phone = c.phone;
                contact.phone2 = c.phone2;
                contact.website = c.website;
                contact.sourceurl = c.sourceurl;
                contact.address1 = c.address1;
                contact.address2 = c.address2;
                contact.city = c.city;
                contact.state = c.state;
                contact.zip = c.zip;
                contact.country = c.country;
                contact.venues = c.venues;
                contact.bio = c.bio;
                contact.industry = c.industry;
                contact.revenue = c.revenue;
                contact.employees = c.employees;

                contactUtility.sortVenues(contact);

                updateWebsites(contact.company, contact.website);

                $scope.saveHistory();
            });
    };

    $scope.normalize = function (contacts) {

        try {

            if (debug) { console.log(debug + 'normalizing', angular.copy(contacts)); }

            shieldService.normalize(contacts, $scope.normalizeCallback);

        } catch (e) {
            console.log('ERROR in normalize', e.message);
        }

    };

    $scope.normalizeCallback = function () {

        //console.log('normalizeCallback', event);

        var i, CN, a, j, contact, before, dup,
            json,
            hasChanges = false,
            del = [],
            req = event.target;

        if (req.readyState !== 4) { return; }
        this.onreadystatechange = null;

        if (req.status !== 200) {

            console.log('ERROR in normalizeCallback (http)', angular.copy(req));

            try {
                json = JSON.parse(req.responseText);
                if (json) {
                    if (!json.success && json.message) {
                        if (json.message === 'Schema is required') {
                        }
                        else {
                            dialogs.alert.show('Data Shield Service error: ' + json.message);
                        }
                    }
                }
            } catch (e) {

            }

            if (!$scope.$$phase) { $scope.$apply(); }

            return;
        }

        if (debug) { console.log('normalizeCallback', req.responseText); }

        try {

            json = JSON.parse(req.responseText);

            //if (debug) { console.log('normalizeCallback JSON', angular.copy(json)); }

            if (json.length > 0) {


                for (i = 0; i < json.length; i++) {

                    CN = json[i];

                    //if (debug) { console.log('CN=', angular.copy(CN)); }

                    a = null;
                    j = $scope.contacts.length;
                    while (j--)
                    { if ($scope.contacts[j].id === CN.Handle[0]) { a = $scope.contacts[j]; break; } }

                    if (a === null) {
                        console.log('ERROR! cannot find contact with id=', CN.Fields.Handle);
                        continue;
                    }

                    contact = $scope.contacts[j];
                    before = angular.copy(contact);

                    hasChanges = true;

                    if (CN.LastName) { contact.last = CN.LastName[0]; }
                    if (CN.FirstName) { contact.first = CN.FirstName[0]; }
                    if (CN.JobTitle) {
                        //if (debug) { console.log('NORM TITLE: ', angular.copy(contact.jobtitle), ' --> ', angular.copy(CN.JobTitle)); }
                        contact.jobtitle = CN.JobTitle[0];
                        if (contact.jobtitle[0] === '?') { contact.jobtitle = contact.jobtitle.substring(1); }
                    }
                    if (CN.CompanyName) { contact.company = CN.CompanyName[0]; }
                    if (CN.Website) { contact.website = CN.Website[0]; }

                    if (CN.AddressLine1) { contact.address1 = CN.AddressLine1[0]; }
                    if (CN.AddressLine2) { contact.address2 = CN.AddressLine2[0]; }
                    if (CN.City) { contact.city = CN.City[0]; }
                    if (CN.PostalCode) { contact.zip = CN.PostalCode[0]; }
                    if (CN.State) { contact.state = CN.State[0]; }
                    if (CN.Country) { contact.country = CN.Country[0]; }

                    if (CN.Phone) {
                        contact.phone = CN.Phone[0];
                        if (CN.Phone.length > 1) { contact.phone2 = CN.Phone[1]; }
                    }

                    contact.n = true;
                    if (debug) {
                        console.log('JSON->', CN);
                        console.log('before->', before);
                        console.log('after->', angular.copy(contact));
                    }

                    dup = $scope.duplicateOf(contact);
                    if (dup) {
                        $scope.merge(dup, contact);
                        del.push(contact);
                    }

                }
            }
        } catch (e) {
            console.log('ERROR in normalizeCallback', e, req);
        }


        if (del) {
            console.log('Deleting', angular.copy(del));
            $scope.deleteContacts(del, true);
        }

        $scope.updateMarks();

        if (!$scope.$$phase) { $scope.$apply(); }

        if (hasChanges)
        { $scope.saveHistory(); }
    };

    $scope.currentPage = 0;
    $scope.pageSize = 100;
    $scope.pages = [];
    $scope.setCurrentPage = function (currentPage) {
        if (debug) { console.log('Setting page to ' + currentPage); }

        if (currentPage < 0) { return; }
        if (currentPage >= $scope.pages.length) { return; }

        showLoader();

        $timeout(function () {
            $scope.currentPage = currentPage;
            $scope.setPageOfFilteredContacts();

        }, 10);
    };
    $scope.isPageVisible = function (index) {
        if ($scope.currentPage === 0 && index === 2) { return true; }
        if ($scope.currentPage === ($scope.pages.length - 1) && index === ($scope.pages.length - 3)) { return true; }
        return index >= ($scope.currentPage - 1) && index <= ($scope.currentPage + 1);
    };
    $scope.getNumberAsArray = function (num) {
        return new Array(num);
    };
    $scope.numberOfPages = function () {
        var c = $scope.contacts.length;
        var j = $scope.contacts.length;
        while (j--) {
            if ($scope.contacts[j]._hidden)
            { c--; }
        }
        return Math.ceil(c / $scope.pageSize);
    };


    $scope.filteredContacts = [];
    $scope.setFilteredContacts = function () {
        $scope.filteredContacts = [];
        var j = 0;
        while (j < $scope.contacts.length) {
            if (!$scope.contacts[j]._hidden)
            { $scope.filteredContacts.push($scope.contacts[j]); }
            j++;
        }
        if (debug) { console.log('filteredContacts size=' + $scope.filteredContacts.length); }
        $scope.setPageOfFilteredContacts();
    };

    $scope.pageOfFilteredContacts = [];
    $scope.setPageOfFilteredContacts = function () {
        var array = [];
        var j = 0;

        if ($scope.currentPage * $scope.pageSize > $scope.filteredContacts.length)
        { $scope.currentPage = 0; }

        var low = $scope.currentPage * $scope.pageSize;
        var high = ($scope.currentPage + 1) * $scope.pageSize - 1;
        j = 0;
        while (j < $scope.filteredContacts.length) {
            if (j >= low && j <= high)
            { array.push($scope.filteredContacts[j]); }
            j++;
        }
        $scope.pageOfFilteredContacts = array;
        if (debug) { console.log('page of filteredContacts size=' + $scope.pageOfFilteredContacts.length + ' ' + low + '..' + high); }

        var pages = [];
        var currentPage = 1;
        low = 1;
        high = currentPage * $scope.pageSize;
        j = 1;
        while (j <= $scope.filteredContacts.length) {
            if (j === high || j === ($scope.filteredContacts.length)) {
                //pages.push(' Page ' + currentPage + ' (' + low + '-' + high + ')');
                pages.push('' + low + '-' + j + '');
                low = currentPage * $scope.pageSize + 1;
                high = (currentPage + 1) * $scope.pageSize;
                currentPage++;
            }
            j++;
        }


        $scope.pages = pages;
    };

    var getPageIndex = function (contactid) {
        const functionName = 'Get Contact Page Index';
        try {
            console.log(functionName, ' > For > ', contactid);
            var currentPage = 1;
            var high = currentPage * $scope.pageSize;
            var j = 1;
            while (j <= $scope.filteredContacts.length) {
                //Match by ID
                if ($scope.filteredContacts[j - 1].id === contactid) {
                    console.log(functionName, ' > Found on Page > ', currentPage);
                    return (currentPage - 1);
                }
                //Next page
                if (j === high || j === ($scope.filteredContacts.length)) {
                    high = (currentPage + 1) * $scope.pageSize;
                    currentPage++;
                }
                //Next record
                j++;
            }

            console.warn(functionName, ' > Not Found ');

        } catch (e) {
            console.error(functionName, e.message);
        }
        return -1;
    };

    // I am the callback handler for the ngRepeat completion.
    $scope.doSomething = function (index) {

        //$scope.showLoading = false;
        //console.log('ngRepeat completed (' + index + ')!');

    };

    $scope.getCount = function (mark) {
        var c = 0;

        if (mark === $scope.markAll)
        { c = $scope.contacts.length; }
        else {
            angular.forEach($scope.contacts, function (cnt, i) {
                if (cnt.mark === mark)
                { c++; }
            });
        }
        //if (debug) { console.log(debug + 'getCount', mark, c); }
        return c;
    };

    // startup events
    mySharedService.broadcast('login');

    $timeout(function () {
        $scope.loadHistory();
    }, 100);


    contactUtility.addContacts = $scope.addContacts;

    $scope.viewCard = function (contact) {


        var url = endpoints.accountService() + 'api/v1/contact/viewcard';

        if (debug) { console.log(debug + 'viewCard', url); }

        var callback = function () {
            var error = chrome.runtime.lastError;
            if (debug) { console.log(debug + 'viewCard.callback', error); }
            if (error) {
                var props2 = { url: newTabUrl };
                chrome.tabs.create(props2, callback);
            }
        };

        var Base64 = {

            // private property
            _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',

            // public method for encoding
            encode: function (input) {
                var output = '';
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;

                input = Base64._utf8_encode(input);

                while (i < input.length) {

                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output +
                    this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
                    this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

                }

                return output;
            },

            // public method for decoding
            decode: function (input) {
                var output = '';
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

                while (i < input.length) {

                    enc1 = this._keyStr.indexOf(input.charAt(i++));
                    enc2 = this._keyStr.indexOf(input.charAt(i++));
                    enc3 = this._keyStr.indexOf(input.charAt(i++));
                    enc4 = this._keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output = output + String.fromCharCode(chr1);

                    if (enc3 !== 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 !== 64) {
                        output = output + String.fromCharCode(chr3);
                    }

                }

                output = Base64._utf8_decode(output);

                return output;

            },

            // private method for UTF-8 encoding
            _utf8_encode: function (string) {
                string = string.replace(/\r\n/g, '\n');
                var utftext = '';

                for (var n = 0; n < string.length; n++) {

                    var c = string.charCodeAt(n);

                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    }
                    else if ((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                    else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }

                }

                return utftext;
            },

            // private method for UTF-8 decoding
            _utf8_decode: function (utftext) {
                var string = '';
                var i = 0;
                var c = 0;
                var c1 = 0;
                var c2 = 0;
                var c3 = 0;

                while (i < utftext.length) {

                    c = utftext.charCodeAt(i);

                    if (c < 128) {
                        string += String.fromCharCode(c);
                        i++;
                    }
                    else if ((c > 191) && (c < 224)) {
                        c2 = utftext.charCodeAt(i + 1);
                        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                        i += 2;
                    }
                    else {
                        c2 = utftext.charCodeAt(i + 1);
                        c3 = utftext.charCodeAt(i + 2);
                        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                        i += 3;
                    }

                }

                return string;
            }

        };

        // console.log('fakePost', contact); 

        function fakePost(contact) {

            console.log('fakePost');

            var form = document.createElement('form');
            form.setAttribute('method', 'post');

            form.setAttribute('action', '%URL%');

            var params = { crmid: null, sitekey: null, data: contact };

            for (var key in params) {
                var hiddenField = document.createElement('input');
                hiddenField.setAttribute('type', 'hidden');
                hiddenField.setAttribute('name', key);
                hiddenField.setAttribute('value', params[key]);
                form.appendChild(hiddenField);
            }
            document.body.appendChild(form);
            form.submit();
        }

        //minify function
        var fakePostCode = fakePost.toString().replace(/(\r|\n|\t)/gm, ' ');
        fakePostCode = fakePostCode.replace(/%URL%/g, url);
        fakePostCode = fakePostCode.replace(/'/gm, '"');

        var s = JSON.stringify(contact);
        s = Base64.encode(s);

        var newTabUrl = 'javascript:' + fakePostCode + '; fakePost("' + s + '");';

        //if (debug) { console.log(debug + 'newTabUrl', newTabUrl); }

        var loadTab = function (tabs) {

            var props2 = { url: newTabUrl };

            if (debug) { console.log(debug + 'viewCard.loadTab', tabs, props2); }

            try {

                if (!tabs || tabs.length === 0)
                { chrome.tabs.create(props2, callback); }
                else
                { chrome.tabs.update(tabs[0].id, props2, callback); }

            } catch (e) {
                if (debug) { console.log(debug + 'viewCard.loadTab.ERROR', e.message); }
            }

        };


        chrome.tabs.query({ windowId: chrome.windows.WINDOW_ID_CURRENT, active: true }, loadTab);

    };

    environmentUtility.onLoaded(function () {

        try { console.time('contact.ui load time'); } catch (e) { }

        $scope.isLocal = environmentUtility.isRelease('local');
        $scope.isAlpha = environmentUtility.isRelease('alpha');
        $scope.isBeta = environmentUtility.isRelease('beta');
        $scope.isProduction = environmentUtility.isRelease('production');

        if ($scope.isLocal) {
            $scope.pageSize = 10;
        }

        if (debug) { console.log(debug + 'release', $scope.isLocal, $scope.isAlpha, $scope.isBeta, $scope.isProduction); }
    });

    $scope.lookupWebsite = function (contact, selectButtonLabel, autopick, successCallback, failureCallback) {

        var processWinner = function (website) {

            if (debug) {
                console.log('SELECTED WINNER WEBSITE: ', website);
            }

            if (website && contact.website !== website) {

                contact.website = website;

                if (contact.company && contact.website) {
                    lookupService.logCompanyWebsite(contact.company, contact.website);
                }

                $scope.saveHistory();

            }

            try {
                successCallback(contact.website);
            } catch (e) {
            }

        };

        var service = {

            findRecord: function (recordType, query, fields, successCallback, failCallback) {

                if (debug) { console.log('query=', angular.copy(query)); }

                var companyName = query.company;

                if (!companyName) {
                    successCallback([]);
                    return;
                }

                lookupService.lookupCompanyWebsite(
                          companyName,
                          function (rr) {

                              var results = [];

                              // Filter out outliers
                              var i, r, max = 0, min = 0;
                              for (i = 0; i < rr.results.length; i++) {
                                  r = rr.results[i];
                                  max = r.rank > max ? r.rank : max;
                                  min = r.rank < min || min === 0 ? r.rank : min;
                              }

                              var threshold = 0.75 * max;

                              for (i = 0; i < rr.results.length; i++) {
                                  r = rr.results[i];
                                  if (r.rank >= threshold) {
                                      results.push(r);
                                  }
                              }

                              successCallback(results);
                          },
                          function (error) { failCallback(error); }
                       );

                return [];
            },

            toLookupObject: function (value, type) {
                if (debug) { console.log(value); }
                var lookupObject = {};
                lookupObject.label = value.website + ' (' + (value.name || '') + ') ';
                lookupObject.link = value.website;
                lookupObject.id = value.website;
                return lookupObject;
            }

        };

        var displayDialog = function () {

            dialogs.lookup
                .show({ lookup: { message: 'Lookup Website', allowNew: false, required: !autopick, appProperty: 'company', selectButtonLabel: selectButtonLabel || 'Save', type: 'Website', showGoogle: true }, value: contact.company, exportService: service })
                .select(
                    function (value) {
                        processWinner((value && value.link) ? value.link : '');
                    }
                )
                .cancel(
                    function () {
                        if (debug) {
                            console.log('SELECTED WEBSITE: NONE');
                        }
                        try {
                            failureCallback();
                        } catch (e) {
                        }
                    }
                );
        };

        if (!autopick) {
            displayDialog();
            return;
        }

        // Try to pick a winner without dialog
        service.findRecord(null, { company: contact.company }, null,

            // have results
            function (results) {

                // single well-rated winner?
                if (results.length === 1 && results[0].rank >= 20) {
                    processWinner(results[0].website);
                    return;
                }

                displayDialog();
            },

            // no results
            function () {
                displayDialog();
            }

        );

    };

    $scope.getDisplayAddress = function (contact) {

        return ('' + (contact.address1 || '') + ' ' + (contact.city || '') + ' ' + (contact.state || '')).trim();
    };

    $scope.earnTokens = function () {

        var websites = [];

        // setName:     [{ url: '', name: '' }]
        // setPattern:  [{ url: '', pattern: '' }]

        var data = { setName: [], setPattern: [] };

        var presentResults = function () {

            if (debug) { console.log('Presenting results', data); }

            dialogs.progress.hide();

            if (data.setName.length === 0 && data.setPattern.length === 0) {

                $timeout(function () {
                    dialogs.alert.show('Capture! came back empty-handed this time... Please try again later. Error code: C-4200.');
                }, 500);

                return;
            }

            $timeout(function () {
                dialogs.list
                    .show(data)
                    .select(function (items) {
                        if (debug) { console.log('Sending results', items); }

                        var total = items.setName.length + items.setPattern.length;

                        if (total > 0) {

                            if (items.setPattern) {
                                angular.forEach(items.setPattern, function (pattern, index) {
                                    lookupService.logEmailPattern(pattern.url, pattern.pattern);
                                });
                            }

                            if (items.setName) {
                                angular.forEach(items.setName, function (name, index) {
                                    lookupService.logCompanyWebsite(name.name, name.url);
                                });
                            }

                            $timeout(function () {
                                var ending = total === 1 ? '' : 's';
                                dialogs.alert.show('Successfully submitted ' + total + ' record' + ending + '.');
                            }, 500);

                        }

                    });
            }, 500);

        };

        var progressValue = 0;

        var shuffle = function (array) {
            var currentIndex = array.length, temporaryValue, randomIndex;

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {

                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;

                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }

            return array;
        };

        var step3 = function () {

            var exportService = $scope.export.getExportService();

            if (!exportService) {
                dialogs.alert.show('Export target is not set up. Please check your settings.');
                return;
            }

            var max = 10;

            var loginFailure = function (error) {
                console.log('ERROR in exportService.login', error);
                dialogs.alert.show(error);
            };

            var loginSuccess = function (error) {
                step3action();
            };

            var step3action = function () {

                dialogs.progress.show({ min: 0, max: max * 2, value: 0, message: 'Scanning Accounts....' });

                exportService.findRecord('Account', { limit: 0 }, ['company', 'website'], function (nativeRecords) {

                    // randomize
                    shuffle(nativeRecords);
                    if (debug) { console.log('found accounts', nativeRecords.length); }


                    var keepGoing = true, found;

                    angular.forEach(nativeRecords, function (nativeRecord, index) {

                        if (!keepGoing) { return; }

                        var appRecord = exportService.fromNativeRecord(nativeRecord, 'Account');
                        var url = contactUtility.getDomain(appRecord.website);

                        if (contactUtility.isBlacklistedDomain(url) || contactUtility.isFreeEmailDomain(url) || contactUtility.isSuspiciousDomain(url))
                        { url = null; }

                        if (url && appRecord.company) {
                            found = false;
                            angular.forEach(data.setName, function (record, index) {
                                if (record.url === url && record.name === appRecord.company) { found = true; }
                            });

                            if (!found) {
                                data.setName.push({ url: url, name: appRecord.company });

                                if (data.setName.length >= max)
                                { keepGoing = false; }

                                dialogs.progress.update({ value: progressValue++ });
                            }
                        }

                    });

                    keepGoing = true;

                    var findPattern = function () {

                        if (!keepGoing || nativeRecords.length === 0) {
                            presentResults();
                            return;
                        }
                        var nativeRecord = nativeRecords.pop();

                        var appRecord = exportService.fromNativeRecord(nativeRecord, 'Account');
                        var url = contactUtility.getDomain(appRecord.website);

                        if (contactUtility.isBlacklistedDomain(url) || contactUtility.isFreeEmailDomain(url) || contactUtility.isSuspiciousDomain(url))
                        { url = null; }

                        if (!url) {
                            findPattern();
                            return;
                        }

                        var found = false;
                        angular.forEach(websites, function (website, index) {
                            if (website === url) { found = true; }
                        });

                        if (found) {
                            findPattern();
                            return;
                        }

                        websites.push(url);

                        getEmailPattern(url, function (pattern) {

                            if (pattern && url) {
                                data.setPattern.push({ url: url, pattern: pattern });

                                if (data.setPattern.length >= max)
                                { keepGoing = false; }

                                dialogs.progress.update({ value: progressValue++ });
                            }

                            findPattern();

                        }, function () { findPattern(); });

                    };

                    findPattern();

                }, function (msg) {
                    console.log('find accounts failure', msg);
                    dialogs.alert.show('Search failed: ' + (msg || 'Unknown error'));
                });

            };

            exportService.isLoggedIn(
                //  Login success!
                step3action,
                 //  Failed login
                function () {
                    dialogs.alert.show('Please login to ' + $scope.export.name + '!').ok(function () {
                        exportService.login(loginSuccess, loginFailure);
                    });
                });
        };

        var step2 = function () {
            $timeout(function () {
                dialogs.confirm.show('Would you like Capture! to take a look in your CRM and see if there are any companies that we may be interested in? The only information we read is a company domain + most common email pattern that this company uses.').confirm(step3);
            }, 500);
        };

        dialogs.confirm.show('Would you like to earn FREE Research Tokens by providing us limited data from your CRM? Click OK to see what we would like to know.').confirm(step2);

    };

    // Maintain the same position on close/open 

    var savedPosition = 0;
    var scrollableArea = null;

    var defineScrollableArea = function () {
        try {
            if (!scrollableArea) {
                scrollableArea = $('#scrollArea'); //$(window);
            }
        } catch (e) {
            console.log('ERROR in defineScrollableArea', e.message);
        }
    };

    var getPosition = function () {
        try {
            defineScrollableArea();
            return scrollableArea.scrollTop();
        } catch (e) {
            console.log('ERROR in getPosition', e.message);
        }
        return 0;
    };

    var savePosition = function () {
        //console.log('savePosition', savedPosition);
        bgService.setValue('scrollPosition', savedPosition);
    };

    var restorePosition = function () {
        try {
            savedPosition = bgService.getValue('scrollPosition') || 0;
            //window.scrollTo(0, savedPosition);
            defineScrollableArea();
            scrollableArea.scrollTop(savedPosition);
            console.log('restorePosition', savedPosition);
        } catch (e) {
            console.log('ERROR in restorePosition', e.message);
        }
    };

    var watchPositionChange = function () {
        try {
            var currentPosition = getPosition();
            //console.log('watchPositionChange', currentPosition);

            if (savedPosition !== currentPosition) {
                savedPosition = currentPosition;
                savePosition();
            }

        } catch (e) {
            console.log('ERROR in watchPositionChange', e.message);
        }
    };

    var initPositionChangeWatcher = function () {
        if (debug) { console.log('initPositionChangeWatcher'); }

        try {
            defineScrollableArea();
            scrollableArea.bind('scroll', function () {
                watchPositionChange();
            });
        } catch (e) {
            console.log('ERROR in initPositionChangeWatcher', e.message);
        }

        try { console.timeEnd('contact.ui load time'); } catch (e) { }
        try { console.timeEnd('app load time'); } catch (e) { }
        try {
            console.warn('Tooltipster > Init');
            $('.tooltipstered').tooltipster();
        } catch (e) {
            console.error('Tooltipster > ', e.message);
        }

    };

    //}]);

    $scope.test = function () {
        try {

            driveService.list(

                function (result) {
                    console.log('SUCCESS', result);

                    try {

                        var docId = //'1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4';
                            '10Giyj2hXUBwSIwXiOlYIc_YjdLUYsHKZKKuke-yoqC0';
                        var worksheetId = '';
                        var value = 'TEST';
                        var f = function () {
                            console.log('SUCCESS APPEND');
                        };

                        driveService.appendSpreadsheet(docId, worksheetId, value, f);

                    } catch (e) {
                        console.log('ERROR in appendSpreadsheet', e.message);
                    }
                },

                function (error) {
                    console.log('ERROR', error);
                }

                );

        } catch (e) {
            console.log('ERROR in test', e.message);
        }
    };

    $scope.formatLink = function (url) {
        if (url && url.indexOf('://') < 0) { url = 'http://' + url; }
        return url;
    };

    $scope.moveToList = function (list0, contacts) {
        const functionName = 'Move To List';
        try {

            if (debug) { console.log(consolePrefix + functionName, contacts); }

            if (!contacts || contacts.length < 1) {
                console.error(composeErrorMessage('Empty contacts list', functionName));
                return;
            }
            //if (!list) { // New list!
            //    $scope.createNewList(contacts);
            //} else {
            //    setList(list, contacts);
            //    $scope.showList(list);
            //}

            var list = [];

            var excludedList = contacts[0].mark; // Exclude current list - unless moving multiple contacts from various lists 
            angular.forEach(contacts, function (contact) {
                if (excludedList !== contact.mark) { excludedList = null; }
            });

            angular.forEach($scope.marks, function (mark, index) {

                if (mark === $scope.markAll) { return; }
                if (mark === excludedList) { return; }

                list.push({
                    label: mark,
                    value: mark,
                    link: null
                });
            });

            dialogs.lookup
                .show({ lookup: { fixedlist: list, message: 'Select List', allowNew: true, required: true, appProperty: 'mark', selectButtonLabel: 'Move', type: 'list', showGoogle: false }, value: '', exportService: null })
                .select(
                    function (value) {
                        if (debug) { console.log(consolePrefix + functionName + ' > Selected', value); }
                        var listName = value.id;

                        if (!listName) { // New list!
                            $scope.showNewMarkDlg(contacts);
                        } else {
                            //setList(listName, contacts);

                            $scope.applyMarkToContacts(listName, contacts, function () {
                                $scope.showMark(listName);
                            });

                        }
                    }
                )
                .cancel(
                    function () {
                        if (debug) { console.log(consolePrefix + functionName + ' > Canceled'); }
                    }
                );

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
            showError(e.message);
        }
    };

    var lookupWebsiteAsync = function (company, options) {
        const functionName = 'Lookup Website (Async)';
        var deferred = $q.defer();
        try {
            if (debug) { console.log(consolePrefix + functionName + ' > Company > ', company); }

            options = options || {};

            var processWinner = function (website, buttonIndex) {
                if (debug) { console.log(consolePrefix + functionName + ' > Website > ', website); }
                deferred.resolve({ Website: website, ButtonIndex: !buttonIndex ? 0 : buttonIndex, Company: company });
            };

            var service = {

                findRecord: function (recordType, query, fields, successCallback, failCallback) {

                    if (debug) { console.log('query=', angular.copy(query)); }

                    var companyName = query.company;

                    if (!companyName) {
                        successCallback([]);
                        return;
                    }

                    lookupService.lookupCompanyWebsite(
                        companyName,
                        function (response) {
                            console.log(consolePrefix + functionName + ' Lookup Result > ', angular.copy(response));
                            successCallback(response.results);
                        },
                        function (error) {
                            console.error(composeErrorMessage(error, functionName));
                            failCallback(error);
                        }
                    );

                    return [];
                },

                toLookupObject: function (value, type) {
                    var lookupObject = {};
                    lookupObject.label = value.website + ' (' + (value.name || '') + ') ';
                    lookupObject.link = value.website;
                    lookupObject.id = value.website;
                    return lookupObject;
                }

            };

            var displayDialog = function () {

                dialogs.lookup
                    .show({
                        lookup: {
                            message: 'Lookup Website',
                            description: 'Please select which website we should use for this contact. Don\'t see the right one? You can modify the search string to get better results.',
                            allowNew: false,
                            required: !options.AutoPick,
                            appProperty: 'company',
                            selectButtonLabel: options.SelectButtonLabel || 'Save',
                            selectButton2Label: options.SelectButton2Label || '',
                            type: 'Website',
                            showGoogle: true
                        },
                        value: company,
                        exportService: service
                    })
                    .select(
                        function (value) {
                            if (debug) { console.log(consolePrefix + functionName + ' > Selected (button 0)', value); }
                            processWinner((value && value.link) ? value.link : '');
                        }
                    )
                    .select2(
                        function (value) {
                            if (debug) { console.log(consolePrefix + functionName + ' > Selected (button 1)', value); }
                            processWinner((value && value.link) ? value.link : '', 1);
                        }
                    )
                    .cancel(
                        function () {
                            if (debug) { console.log(consolePrefix + functionName + ' > Canceled'); }
                            deferred.reject('Canceled');
                        }
                    );
            };

            if (!options.AutoPick) {
                displayDialog();
            } else if (options.Silent) {

                //lookupService.lookupCompanyWebsite(
                //    company,
                //    function (response) {
                //        console.log(consolePrefix + functionName + ' Lookup For > ' + company + ' > Response > ', angular.copy(response));
                //        if (response && response.results && response.results.length >= 1 && response.results[0].rank >= 1) {
                //            processWinner(response.results[0].website);
                //        }
                //        else {
                //            deferred.reject('No reliable results');
                //        }
                //    },
                //    function (error) {
                //        console.error(composeErrorMessage(error, functionName));
                //        deferred.reject(error);
                //    }
                //);

                service.findRecord(null, { company: company }, null,

                    // have results
                    function (results) {
                        console.log(consolePrefix + functionName + ' Lookup For > ' + company + ' > Results > ', angular.copy(results));
                        // pick the first winner
                        if (results.length >= 1 && results[0].rank >= 1) {
                            processWinner(results[0].website);
                        }
                        else {
                            deferred.reject('No reliable results');
                        }
                    },

                    // no results
                    function () { deferred.reject('No results'); }

                );

            } else {

                // Autopick: Try to pick a winner without dialog
                service.findRecord(null, { company: company }, null,

                    // have results
                    function (results) {
                        // single well-rated winner?
                        if (results.length === 1 && results[0].rank >= 20) {
                            processWinner(results[0].website);
                        }
                        else {
                            displayDialog();
                        }
                    },

                    // no results
                    function () { displayDialog(); }

                );
            }

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
            $timeout(function () { deferred.reject(functionName + ' failed. ' + e.message); }, 100);
        }
        return deferred.promise;
    };

    var contains = function (element, array) {
        var found = false;
        var j = array.length;
        while (j--) {
            if (array[j] === element) {
                found = true;
                break;
            }
        }
        return found;
    };

    var fillWebsitesAsync = function (contacts, options) {
        const functionName = 'Fill Websites (Async)';
        var deferred = $q.defer();
        try {
            if (debug) { console.log(consolePrefix + functionName + ' > Contacts >', contacts); }

            options = options || {};

            var list = [];

            var i = contacts.length;
            while (i--) {
                if (options.IgnoreExisting) {
                    if (contacts[i].company && !contains(contacts[i].company, list)) {
                        list.push(contacts[i].company);
                    }
                }
                else {
                    if (!contacts[i].website && contacts[i].company) {
                        if (!contains(contacts[i].company, list)) {
                            list.push(contacts[i].company);
                        }
                    }
                }
            }

            if (debug) { console.log(consolePrefix + functionName + ' > Companies >', list); }

            if (list.length === 0) {
                $timeout(function () { deferred.resolve(contacts); }, 100);
                return deferred.promise;
            }

            const autopick = true;
            const selectButtonLabel = 'Select';
            var companyIndex = list.length;

            var onLookupCompleted = function (lookupResult) {
                var company = lookupResult.Company;
                if (debug) { console.log(consolePrefix + functionName + ' > Company > ' + company + ' > Website Found >', angular.copy(lookupResult)); }

                // find all contacts with this company and update missing website
                var k = contacts.length;
                while (k--) {
                    var contact = contacts[k];
                    if (options.IgnoreExisting) {
                        if (contact.company === company) {
                            if (debug) { console.log(consolePrefix + functionName + ' > Replace Website > ', angular.copy(contact.website), ' > With > ', angular.copy(lookupResult.Website)); }
                            // Move old website to Venues
                            if (contact.website && contact.website !== lookupResult.Website) {
                                contactUtility.addVenue(contact, { website: contact.website, type: 'website' });
                            }
                            contact.website = lookupResult.Website;
                        }
                    } else {
                        if (contact.company === company && !contact.website) {
                            if (debug) { console.log(consolePrefix + functionName + ' > Set Website > ', angular.copy(lookupResult.Website)); }
                            contact.website = lookupResult.Website;
                        }
                    }
                }

                if (companyIndex === -1) {
                    deferred.resolve(contacts);
                }
            };

            var onLookupError = function (error) {
                console.error(composeErrorMessage(error, functionName + ' > Website Lookup'));
                deferred.resolve(contacts);
            };

            while (companyIndex--) {
                console.log('while', companyIndex);
                var company = list[companyIndex];
                if (debug) { console.log(consolePrefix + functionName + ' > Company > ' + company + ' > Looking up a website'); }
                var promise2 =
                    lookupWebsiteAsync(company, { AutoPick: autopick, SelectButtonLabel: selectButtonLabel, Silent: options.Silent })
                    .then(onLookupCompleted)
                    .catch(onLookupError);
            }


        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
            $timeout(function () { deferred.reject(functionName + ' failed. ' + e.message); }, 100);
        }

        return deferred.promise;
    };

    var fillWebsites = function (contacts) {
        const functionName = 'Fill Websites';
        try {

            if (debug) { console.log(consolePrefix + functionName, contacts); }

            $q.when(contacts)
            .then(function (contacts) {
                if (contacts.length > 0) {
                    if (debug) { console.log(consolePrefix + functionName + ' > Lookup websites'); }
                    return fillWebsitesAsync(contacts, { IgnoreExisting: true, Silent: true });
                }
                return contacts;
            })
            .catch(function (error) {
                console.error(consolePrefix + functionName, error);
            })
            .finally(function () {
            });

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.getVenueName = function (venueType, venueUrl) {

        var name = venueType || 'website';

        if (!name) { return name; }

        if (name === 'linkedin') {
            name = 'LinkedIn';
        } else if (name === 'website') {
            name = 'Web site';
        } else if (name === 'social') {
            if (venueUrl) {
                if (venueUrl.indexOf('linkedin.com') >= 0) {
                    name = 'LinkedIn';
                } else if (venueUrl.indexOf('twitter.com') >= 0) {
                    name = 'Twitter';
                }
            }
        } else {
            name = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();
        }

        return name;
    };

    $scope.getEmailVerTitle = function (v, t) {
        var res = 'Email was not validated. Please run Research.';
        if (v > 1) {
            res = 'Email was confirmed by at least one data source';
        } else if (v > 0) {
            res = 'Email may be valid but it was not confirmed by other data sources';
        } else if (parseInt(v) === 0) {
            res = 'Email is likely invalid';
        }
        if (t) {
            res += '. ' + t;
        }
        return res;
    };

    $scope.getEmailVerIcon = function (v) {
        //if (!contact) { return; }
        //var v = contact.emailver;
        var res = 'question';
        if (v > 1) {
            res = 'check-circle text-success';
        } else if (v > 0) {
            res = 'question-circle text-warning';
        } else if (parseInt(v) === 0) {
            res = 'exclamation-circle text-danger';
        }
        //console.warn('getEmailVerIcon > ', v, res, angular.copy(contact));
        return res;
    };

    $scope.showTips = function () {
        const functionName = 'Show Tips';
        try {

            var t = 3 * 1000;

            var step1 = function () {
                $('#capture-button-group').tooltipster({
                    content: $('<span>Select what to capture</span>'),
                    position: 'right',
                    timer: t
                });
                $('#capture-button-group').tooltipster('show');
                $timeout(step2, t);
            };

            //var step1b = function () {
            //    $('#capture-button-group').tooltipster('hide');
            //    $timeout(step2, t);
            //};

            var step2 = function () {
                $('#capture-button').tooltipster({
                    content: $('<span>Click to capture</span>'),
                    position: 'bottom',
                    timer: t
                });
                $('#capture-button').tooltipster('show');
                $timeout(step3, t);
            };

            var step3 = function () {
                $('#capture-sample').tooltipster({
                    content: $('<span>Try it here</span>'),
                    position: 'bottom',
                    timer: t
                });
                $('#capture-sample').tooltipster('show');
            };

            step1();

        } catch (e) {
            console.error(composeErrorMessage(e, functionName));
        }
    };

    $scope.showSettings = function () {
        $location.path('/settings');
    };

    $scope.toggleExpand = function (contacts) {

        var value = !contacts[0]._collapsed;
        angular.forEach(contacts, function (contact) {
            contact._collapsed = value;
        });

    };

    $scope.selectAddress = function (contact) {

        if (!contact || !contact.addresses || contact.addresses.length === 0) {
            return;
        }
        var targets = [];

        angular.forEach(contact.addresses, function (address) {
            targets.push({ label: $scope.getDisplayAddress(address), target: address });
        });

        $q.when(targets)
            .then(modals.exportTargetSelector({ title: 'Select Address' }))
            .then(function (address) {
                console.log('Select address > ', address);
                $scope.applyAddress(contact, address);
                $scope.saveHistory();
            });

    };

}



'use strict';

/* global angular: false */
/* global SearchEngine: false */
/* global bsn: false */
//  TODO: Retire this controller!
function SearchController($scope, mySharedService) {
    var debug = 'search.ui.js->';
    $scope.tab = 1;
    $scope.status = '';
    $scope.canSee = false;
    $scope.allowed = true;
    $scope.tokens = 0;
    $scope.keyword = '';
    $scope.location = '';
    $scope.locationOptions = {
        options: {
            focusOpen: true,
            source: function (request, response) {
                console.log(123, request, response);
                var listData = ['France', 'Finland', 'USA'];
                var result = [];
                angular.forEach(listData, function (s) {
                    result.push({ label: s, value: s });
                });
                response(result);
            }
        },
        events: {
            change: function (event, ui) {
                console.log('change');
                console.log(ui);
                console.log(event);
            }
        }
    };

    $scope.autoCapture = false;
    $scope.selectedSearch = null;
    $scope.hasLocation = false;
    $scope.searches = [];
    $scope.vals = [];

    $scope.back = function () {
        //$location.path('/home');
        mySharedService.broadcast('contact:show');
    };

    $scope.$on('handleBroadcast', function () {
        //if (debug) { console.log(debug + 'Broadcast received', mySharedService.message); }
        if (mySharedService.message.indexOf('listTokens:') === 0) {
            $scope.tokens = mySharedService.message.substring(mySharedService.message.indexOf(':') + 1);
            //$scope.allowed = ($scope.tokens > 0);
        }
        else if (mySharedService.message.indexOf('search:') === 0) {

            if (mySharedService.message.indexOf(':hide') > 0) {
                $scope.canSee = false;
            } else if (mySharedService.message.indexOf(':show') > 0) {
                $scope.canSee = true;
            }

        }
        else if (mySharedService.message === 'logout') {
            $scope.canSee = false;
        }
    });

}

'use strict';


function ProfilerController($scope, $, X2JS, mySharedService, $timeout, profilerService, contactUtility) {

    $scope.key_hash = '';
    $scope.status = '';
    $scope.url = '';
    $scope.results = [];
    $scope.company = {};
    $scope.showOthers = true;
    $scope.showHistory = false;
    $scope.canProfile = false;
    $scope.canSee = false;
    $scope.allowed = false;
    $scope.tokens = 0;

    $scope.LABEL_MORE = 'Want to find more contacts on this website?';
    $scope.LABEL_ANY = 'Research website';
    $scope.label = $scope.LABEL_ANY;

    $scope.description = 'Website research works best on corporate websites. This action will consume one Company Research token.';

    $scope.$on('handleBroadcast', function () {

        if (mySharedService.message.indexOf('sitekey:') === 0) {
            //$scope.canSee = true;
            //$scope.listSearches();
        }
        else if (mySharedService.message.indexOf('profiler:') === 0) {

            if (mySharedService.message.indexOf(':hide') > 0) {
                $scope.canSee = false;
            } else if (mySharedService.message.indexOf(':show') > 0) {
                $scope.canSee = true;
            } else {
                $scope.canSee = true;

                if (mySharedService.message.indexOf(':more') > 0) {
                    $scope.label = $scope.LABEL_MORE;
                } else {
                    $scope.label = $scope.LABEL_ANY;
                }

                $scope.checkPage(function () { });

            }
            //$scope.listSearches();
        }
        else if (mySharedService.message.indexOf('companyTokens:') === 0) {
            $scope.tokens = mySharedService.message.substring(mySharedService.message.indexOf(':') + 1);
            $scope.allowed = ($scope.tokens > 0);
        }
        else if (mySharedService.message === 'logout') {
            $scope.canSee = false;
        }

    });

    $scope.showCurrentResults = function () {
        if (!$scope.url) { return; }
        if (!$scope.results) { return; }

        var i = $scope.results.length;
        while (i--) {
            if ($scope.url === $scope.results[i].url || $scope.url === 'www.' + $scope.results[i].url) {
                $scope.loadSearch($scope.results[i]);
                break;
            }
        }
    };

    $scope.checkPage = function (callback) {
        $scope.canProfile = false;

        if (typeof (chrome) === 'object' && typeof (chrome.tabs) === 'object') { // Chrome extension
            chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
                function (tabs) {
                    if (!tabs || tabs.length === 0) { return; }

                    $scope.url = tabs[0].url.match(/^[\w-]+:\/*\[?([\w\.:-]+)\]?(?::\d+)?/)[1];
                    $scope.canProfile = $scope.url && $scope.url.length > 0;
                    if (!$scope.$$phase) { $scope.$apply(); }
                    callback();
                });
        }
        else { // standalone page
            $scope.url = document.domain;
            $scope.canProfile = $scope.url && $scope.url.length > 0;
            callback();
        }
    };


    $scope.listSearches = function () {
        $scope.status = 'Checking...';
        profilerService.executeSyncCommand($scope.key_hash, $scope.listSearchesCallback);
    };

    $scope.listSearchesCallback = function (event) {

        var entry, xml, x2js, json, vals, v, res, p, 
            req = event.target;

        if (req.readyState !== 4 /* complete */) {
            return;
        }

        this.onreadystatechange = null; //avoids memory leaks

        $scope.results = [];

        if (req.status !== 200) {
            //Failure
            $scope.status = 'Failed to communicate with Profiler\'s Service';
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }


        //Success
        xml = req.responseText;
        //var json = $.xml2json(xml);
        x2js = new X2JS();
        json = x2js.xml_str2json(xml);

        try {

            //if (json.params.param.value.struct.member.name == "SEARCHES") {
            vals = json.params.param.value.struct.member.value.array.data.value;

            for (v in vals) {

                if (v === 'struct') { // one element
                    entry = vals.struct.member;
                } else {// array
                    entry = vals[v].struct.member;
                }

                res = {
                    search_id: '',
                    url: '',
                    options: '',
                    created_ts: '',
                    completed_ts: '',
                    state: '',
                    storage: '',
                    priority: '',
                    state_label: '',
                    showDetails: false
                };


                for (p in entry) {
                    if (entry[p].name === 'search_id') { res.search_id = entry[p].value.int; }
                    else if (entry[p].name === 'url') { res.url = entry[p].value.string; }
                    else if (entry[p].name === 'options') { res.options = entry[p].value.string; }
                    else if (entry[p].name === 'created_ts') { res.created_ts = entry[p].value.string; }
                    else if (entry[p].name === 'completed_ts') { res.completed_ts = entry[p].value.string; }
                    else if (entry[p].name === 'state') { res.state = entry[p].value.int; }
                    else if (entry[p].name === 'storage') { res.storage = entry[p].value.string; }
                    else if (entry[p].name === 'priority') { res.priority = entry[p].value.int; }
                    else if (entry[p].name === 'state_label') { res.state_label = entry[p].value.string; }
                    else { console.log('Unknown param: ' + entry[p].name); }
                }

                res.done = false;
                $scope.results.push(res);
            }

            $scope.checkPage($scope.showCurrentResults);

            $scope.status = '';

        } catch (e) {
            console.log('Cannot parse response');
            console.log(e);
            $scope.status = 'Foreign language... No comprendo...';
        }

        if (!$scope.$$phase) { $scope.$apply(); }
    };


    $scope.execute = function () {

        if (typeof (chrome) === 'object' && typeof (chrome.tabs) === 'object') {
            $scope.profileCurrentTab();
            return;
        }

        if ($scope.url) {
            var www = $scope.url;
            $scope.search(www);
            return;
        }

        $scope.status = 'Nothing to profile';

        if (!$scope.$$phase) { $scope.$apply(); }
    };

    $scope.profileCurrentTab = function () {

        $scope.status = 'diving into selection';

        if (!chrome || !chrome.tabs) {
            $scope.status = 'Not a Chrome extension';
            return;
        }

        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
            function (tabs) {
                if (!tabs || tabs.length === 0) {
                    $scope.status = 'No open tabs';
                    if (!$scope.$$phase) { $scope.$apply(); }
                    return;
                }
                var tab = tabs[0];
                $scope.search(tab.url);
            });
    };

    $scope.refresh = function(){
        if (!$scope.$$phase) { $scope.$apply(); }
    };





    $scope.search = function (www) {
        console.log(www);
        $scope.status = 'Profiling';
        if (!$scope.$$phase) { $scope.$apply(); }
        profilerService.executeQuickSearchCommand(www, $scope.key_hash, function(response){
                var x2js = new X2JS();
                response = x2js.xml_str2json(response);

                if (response.fault) {
                    $scope.status = response.fault.value.struct.member[1].value.string;
                    if (!$scope.$$phase) { $scope.$apply(); }
                    return;
                }

                if (response.params.param.value.struct.member.name === 'ERROR') {
                    $scope.status = response.params.param.value.struct.member.value.string;
                    if (!$scope.$$phase) { $scope.$apply(); }
                    return;
                }

                $scope.status = 'Research has started. Please check back in few minutes.';
                $scope.refresh();

            }, function(response){
                $scope.status = 'Failed to communicate with Profiler\'s Service';
                $scope.refresh();
            });
    };



    /*
    $scope.search = function (www) {
        console.log(www);
        $scope.status = 'Profiling';
        if (!$scope.$$phase) { $scope.$apply(); }
        profilerService.executeQuickSearchCommand(www, $scope.key_hash, $scope.searchCallback);
    };

    $scope.searchCallback = function (event) {

        var xml, x2js, json, error,
            req = event.target;

        if (req.readyState !== 4 ) {
            return;
        }

        this.onreadystatechange = null; //avoids memory leaks

        if (req.status !== 200) {
            //Failure
            $scope.status = 'Failed to communicate with Profiler\'s Service';
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        //Success
        xml = req.responseText;
        //json = $.xml2json(xml);
        x2js = new X2JS();
        json = x2js.xml_str2json(xml);

        console.log(req);
        console.log(json);

        error = '';

        if (json.fault) {
            error = json.fault.value.struct.member[1].value.string;
            $scope.status = error;
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        if (json.params.param.value.struct.member.name === 'ERROR') {

            error = json.params.param.value.struct.member.value.string;
            $scope.status = error;
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        $scope.status = 'Research has started. Please check back in few minutes.';
        if (!$scope.$$phase) { $scope.$apply(); }
    };
    */

    $scope.deleteSearch = function (search) {
        $scope.status = 'Deleting...' + search;
        profilerService.executeDeleteCommand(search.id, $scope.key_hash, function(response){
            var x2js = new X2JS();
            response = x2js.xml_str2json(response);
            if (response.fault) {
                $scope.status = response.fault.value.struct.member[1].value.string;
                $scope.refresh();
                return;
            }

            $scope.status = 'Deleted successfully!';
            $scope.refresh();
        }, function(response){
            $scope.status = 'Failed to communicate with Diver\'s Base';
            $scope.refresh();
        });
    };

    /*
    $scope.deleteSearch = function (search) {
        $scope.status = 'Deleting...' + search;
        profilerService.executeDeleteCommand(search.id, $scope.key_hash, $scope.deleteSearchCallback);
    };

    $scope.deleteSearchCallback = function (event) {

        var req = event.target;

        if (req.readyState !== 4 ) {
            return;
        }

        this.onreadystatechange = null; //avoids memory leaks

        $scope.results = [];

        if (req.status !== 200) {
            //Failure
            $scope.status = 'Failed to communicate with Diver\'s Base';
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        var xml = req.responseText;
        //var json = $.xml2json(xml);
        var x2js = new X2JS();
        var json = x2js.xml_str2json(xml);

        console.log(req);
        console.log(json);

        if (json.fault) {
            var error = json.fault.value.struct.member[1].value.string;
            $scope.status = error;
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        $scope.status = 'Deleted successfully!';
        if (!$scope.$$phase) { $scope.$apply(); }

    };
    */

    $scope.loadSearch = function (search) {
        $scope.status = 'Loading...';
        profilerService.executeLoadCommand(search.storage, function(response){
                if (!response.success) {
                    $scope.status = response.message;
                    $scope.refresh();
                    return;
                }

                var data = $.xml2json(response.xml);

                if (!data || !data.INFO || data.INFO.DATA !== 'blxml') {
                    $scope.status = 'Invalid BLXML';
                    $scope.refresh();
                    return;
                }

                var c = {};

                c.name = data.COMPANIES.COMPANY.COMPANY_NAME;
                c.www = data.COMPANIES.COMPANY.WWW;
                c.address = data.COMPANIES.COMPANY.ADDRESS;
                c.city = data.COMPANIES.COMPANY.CITY;
                c.phone = data.COMPANIES.COMPANY.PHONE;
                c.state = data.COMPANIES.COMPANY.STATE;
                c.zip = data.COMPANIES.COMPANY.ZIP;

                c.contacts = [];

                if (data.COMPANIES.COMPANY.CONTACTS.CONTACT) {
                    var n = data.COMPANIES.COMPANY.CONTACTS.CONTACT.length;
                    for (var i = 0; i < n; i++) {
                        var CN = data.COMPANIES.COMPANY.CONTACTS.CONTACT[i];

                        //if (i == 0) console.log(CN);
                        var a = {};
                        a.link = ''; // exported link
                        a.last = CN.NAME_LAST;
                        a.first = CN.NAME_FIRST;
                        a.phone = CN.PHONE;
                        a.phone2 = CN.PHONE2;
                        a.jobtitle = CN.TITLE;
                        a.email = CN.EMAIL;
                        a.bio = CN.BIO;
                        a.company = CN.CONTEXT_COMPANY;
                        if (!a.company) { a.company = c.name; }


                        c.contacts.push(a);
                    }
                }
                else {
                    console.log(c);
                }

                $scope.company = c;

                contactUtility.addContacts(c.contacts, c, false);

                $scope.status = '';
                $scope.refresh();
            },function(response){
                $scope.status = 'Failed to communicate with Profiler Service';
                $scope.refresh();
            });
    };

    


}


'use strict';

function DiverController($scope, X2JS, Base64, mySharedService, $timeout, diverService) {

    $scope.key_hash = '';
    $scope.status = '';
    $scope.pastedUrl = '';
    $scope.pastedHtml = '';
    $scope.results = [];
    $scope.canDive = false;
    $scope.canSee = false;

    $scope.$on('handleBroadcast', function () {

        if (mySharedService.message.indexOf('sitekey:') === 0) {
            //$scope.canSee = true;
            $scope.canDive = true;
        }
        else if (mySharedService.message === 'logout') {
            $scope.canSee = false;
        }

    });

    $scope.deleteSearch = function (search) {
        $scope.status = 'Deleting...' + search;
        diverService.executeDeleteCommand(search.id, $scope.key_hash, $scope.deleteSearchCallback);
    };

    $scope.deleteSearchCallback = function (event) {

        var req = event.target;

        if (req.readyState !== 4 /* complete */) {
            return;
        }

        this.onreadystatechange = null; //avoids memory leaks

        $scope.results = [];

        if (req.status !== 200) {
            //Failure
            $scope.status = 'Failed to communicate with Diver\'s Base';
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        var xml = req.responseText;
        //var json = $.xml2json(xml);
        var x2js = new X2JS();
        var json = x2js.xml_str2json(xml);


        console.log(req);
        console.log(json);

        if (json.fault) {
            var error = json.fault.value.struct.member[1].value.string;
            $scope.status = error;
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        $scope.status = 'Deleted successfully!';
        if (!$scope.$$phase) { $scope.$apply(); }

    };

    $scope.getStatus = function () {
        $scope.status = 'Checking...';
        diverService.executeProgressCommand($scope.key_hash, $scope.getStatusCallback);
    };

    $scope.getStatus2 = function () {
        $scope.status = 'Checking...';
        diverService.executeSyncCommand($scope.key_hash, $scope.getStatusCallback);
    };

    $scope.getStatusCallback = function (event) {

        var entry, xml, x2js, json, res, vals, v, p,
            req = event.target;

        if (req.readyState !== 4 /* complete */) {
            return;
        }

        this.onreadystatechange = null; //avoids memory leaks

        $scope.results = [];

        if (req.status !== 200) {
            //Failure
            $scope.status = 'Failed to communicate with Diver\'s Base';
            if (!$scope.$$phase) {
                $scope.$apply();
            }
            return;
        }


        //Success
        xml = req.responseText;
        //console.log(xml);
        //var json = $.xml2json(xml);
        x2js = new X2JS();
        json = x2js.xml_str2json(xml);
        //console.log(json);

        try {

            //if (json.params.param.value.struct.member.name == "SEARCHES") {

            vals = json.params.param.value.struct.member.value.array.data.value;

            for (v in vals) {

                if (v === 'struct') {// one element
                    entry = vals.struct.member;
                } else { // array
                    entry = vals[v].struct.member;
                }

                res = {
                    search_id: '',
                    id: '',
                    url: '',
                    created_ts: '',
                    completed_ts: '',
                    state: '',
                    storage: '',
                    options: '',
                };


                for (p in entry) {
                    if (entry[p].name === 'search_id') { res.search_id = entry[p].value.int; }
                    else if (entry[p].name === 'id') { res.id = entry[p].value.int; }
                    else if (entry[p].name === 'url') { res.url = entry[p].value.string; }
                    else if (entry[p].name === 'created_ts') { res.created_ts = entry[p].value.string; }
                    else if (entry[p].name === 'completed_ts') { res.completed_ts = entry[p].value.string; }
                    else if (entry[p].name === 'state') { res.state = entry[p].value.int; }
                    else if (entry[p].name === 'storage') { res.storage = entry[p].value.string; }
                    else if (entry[p].name === 'options') { res.options = entry[p].value.string; }
                    else { console.log('Unknown param: ' + entry[p].name); }
                }

                res.done = false;

                //console.log(res);

                //res.text = entry;
                //console.log(res);
                $scope.results.push(res);
            }

            $scope.status = 'Done';

            //}

        } catch (e) {
            console.log('Cannot parse response');
            console.log(e);
            $scope.status = 'Foreign language... No comprendo...';
        }

        if (!$scope.$$phase) { $scope.$apply(); }
    };

    $scope.execute = function () {

        if (typeof (chrome) === 'object' && typeof (chrome.tabs) === 'object') {
            $scope.diveSelection();
            return;
        }

        if ($scope.pastedHtml) {
            var www = $scope.pastedUrl;
            var html = $scope.pastedHtml;
            $scope.diveExecute(www, html);
            return;
        }

        $scope.status = 'cold water... can\'t dive....';

        if (!$scope.$$phase) {
            $scope.$apply();
        }
    };

    $scope.diveExecute = function (www, html) {
        var base64 = Base64.encode(html);
        console.log(www);
        console.log(base64.length);
        var options = 'contacts';
        $scope.status = 'Splash!';
        if (!$scope.$$phase) {
            $scope.$apply();
        }
        diverService.executeDiveCommand(www, base64, options, $scope.key_hash, $scope.executeDiveCallback);
    };

    $scope.executeDiveCallback = function (event) {

        var req = event.target;

        if (req.readyState !== 4 /* complete */) {
            return;
        }

        this.onreadystatechange = null; //avoids memory leaks

        if (req.status !== 200) {
            //Failure
            $scope.status = 'Failed to communicate with Diver\'s Base';
            if (!$scope.$$phase){ $scope.$apply(); }
            return;
        }

        //Success
        var xml = req.responseText;
        //var json = $.xml2json(xml);
        var x2js = new X2JS();
        var json = x2js.xml_str2json(xml);

        console.log(req);
        console.log(json);

        if (json.fault) {
            var error = json.fault.value.struct.member[1].value.string;
            $scope.status = error;
            if (!$scope.$$phase) { $scope.$apply(); }
            return;
        }

        $scope.status = 'Diver sent out successfully!';
        if (!$scope.$$phase) { $scope.$apply(); }
    };

    $scope.diveSelection = function () {

        $scope.status = 'diving into selection';

        //alert(1);
        if (!chrome || !chrome.tabs) {
            $scope.status = 'I am diving only as a Chrome extension';
            return;
        }
        //windowId: chrome.windows.WINDOW_ID_CURRENT
        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
            function (tabs) {

                if (!tabs || tabs.length === 0) {
                    $scope.status = 'No open tabs';
                    if (!$scope.$$phase) {
                        $scope.$apply();
                    }
                    return;
                }

                var tab = tabs[0];
                //alert(tab.title);
                //if(!tab) {alert('no tab'); return; }

                chrome.tabs.sendRequest(tab.id, { method: 'getSelection' },
                    function (response) {
                        //if(!response) { alert('diveSelection:no response'); return; }
                        //if(!response.data) { alert('diveSelection:no data'); return; }
                        //alert('Data: ' + response.data);
                        if (response && response.data) {
                            var www = tab.url;
                            var html = response.data;

                            $scope.diveExecute(www, html);
                        }
                        else {
                            $scope.divePage();
                            return;
                        }
                    });

            });
    };

    $scope.divePage = function () {

        $scope.status = 'diving into whole page';

        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
            function (tabs) {

                if (!tabs || tabs.length === 0) {
                    $scope.status = 'No open tabs.';
                    if (!$scope.$$phase) {
                        $scope.$apply();
                    }
                    return;
                }

                var tab = tabs[0];

                chrome.tabs.sendRequest(tab.id, { method: 'getPage' }, function (response) {

                    if (response && response.data) {
                        var www = tab.url;
                        var html = response.data;
                        $scope.diveExecute(www, html);
                    }
                    else {
                        $scope.status = 'Nowhere to dive :(';
                        if (!$scope.$$phase) {
                            $scope.$apply();
                        }
                    }
                });
            });
    };

}
'use strict';

function CCaptureController($scope, $, mySharedService, $timeout, captureService, contactUtility, debugUtility, dialogs) {

    var debug = false;

    $scope.status = '';
    $scope.message = '';
    $scope.url = '';
    $scope.pastedHtml = '';
    $scope.results = [];
    $scope.cached = false;

    //$scope.crmid = '';
    //$scope.sitekey = '';
    //$scope.uid = '';
    //$scope.schema = '';

    $scope.canSee = false;
    $scope.allowed = false;
    $scope.showClipboard = false;
    $scope.showCompany = false;
    $scope.clipboardData = null;
    $scope.companyName = '';
    $scope.companyURL = '';

    $scope.tokens = 0;

    $scope.STATUS_NO_CONTACTS = 'No contacts found on this page';

    //debugUtility.addLoggingProperties($scope);
    //$scope.logLevel = $scope.LOG_LEVEL_ALL;

    $scope.$on('handleBroadcast', function () {

        var msg = mySharedService.message;
        //console.log('broadcast: ' + mySharedService.message);

        if (msg.indexOf('pageTokens:') === 0) {
            $scope.tokens = msg.substring(msg.indexOf(':') + 1);
            $scope.allowed = ($scope.tokens > 0);
        }
        else if (msg.indexOf('ccapture:') === 0) {

            if (msg.indexOf(':hide') > 0)
                {$scope.canSee = false; }
            else if (msg.indexOf(':show') > 0)
                {$scope.canSee = true;   }

        }
        else if (msg === 'logout') {
            $scope.canSee = false;
        }
        else if (msg === 'exec-ccapture') {
            $scope.showClipboard = false;
            $scope.showCompany = false;
            console.log('Attempting to capture where capture was migraged :-(');
            //$scope.capture();
        }
        else if (msg === 'exec-ccapture-clipboard') {
            $scope.showClipboard = true;
            $scope.showCompany = false;
            mySharedService.broadcast('ccapture:show');
            mySharedService.broadcast('contact:hide');
            mySharedService.broadcast('search:hide');
            //$scope.capture();
        }
        else if (msg === 'exec-ccapture-company') {
            //$scope.capture();
            $scope.showCompany = true;
            $scope.showClipboard = false;
            mySharedService.broadcast('ccapture:show');
            mySharedService.broadcast('contact:hide');
            mySharedService.broadcast('search:hide');
        }


    });

    $scope.test = function () {
        //$scope.status = ccapture.hello();
    };

    $scope.searchPaste = function () {

        if ($scope.pastedHtml) {
            $scope.executeCapture($scope.pastedHtml, 'PASTE');
            return;
        }

        $scope.status = 'no content... can\'t capture....';
    };


    $scope.finish = function (contacts, extra) {

        if (debug) {
            if (contacts !== null) {
                var i = contacts.length;
                while (i--) {
                    console.log('finish capture', $.extend({}, contacts[i]));
                }
            }
        }

        $scope.status = '';
        if (!$scope.$$phase) {$scope.$apply();   }

        contactUtility.addContacts(contacts, null, false);
    }       ;

}

'use strict';

/* global $: false */
/* global angular: false */
/* global jQuery: false */
/* global ContactController: false */
/* global SearchController: false */
/* global ProfilerController: false */
/* global CCaptureController: false */
/* global AccountController: false */
/* global DiverController: false */

try { console.time('app load time'); } catch (e) { }

//     Startup the tool tips
$(document).ready(function () {
    $('body').tooltip({
        selector: '[data-toggle=tooltip]',
        container: 'body',
        delay: { show: 500, hide: 0 }
    });
    //     Workaround for tool tips not always going away

    $(document).click(function (e) {
        $('.tooltip').remove();
    });

    //paceOptions = {
    //    // Disable the 'elements' source
    //    elements: false,

    //    // Only show the progress on regular and ajax-y page navigation,
    //    // not every request
    //    restartOnRequestAfter: true
    //};

});



/**
 * @namespace captureApp
 */


var captureApp = angular.module('captureApp', ['bgLinkModule', 'ngRoute', 'ngSanitize', 'stores', 'webServices', 'utilities', 'broadlook.multimerge', 'dialogs', 'modals', 'ui.bootstrap']) //'ngGrid'

    /*

    // Temporary hack for angular 1.2 -> 1.3 migration
    // No longer needed since we explictly add our top level controllers to the app (see bottom of file)

.config(['$controllerProvider', function($controllerProvider) {
    // this option might be handy for migrating old apps, but please don't use it
    // in new ones!

   $controllerProvider.allowGlobals();
}])

     */

.factory('docSize', [function () {
    return {
        width: 400,
        widthStack: [],

        setWidth: function (width) {
            this.width = width;
            $('body').css('width', width + 'px')
                 .css('min-width', width + 'px')
                 .css('max-width', width + 'px');
        },
        setHeight: function (height) {
            $('body').css('height', height + 'px')
                 .css('min-height', height + 'px')
                 .css('max-height', height + 'px');
        },
        setSize: function (width, height) {
            this.setWidth(width);
            this.setHeight(height);
        },
        pushWidth: function (width) {
            this.widthStack.push(this.width);
            this.setWidth(width);
        },
        popWidth: function () {
            this.setWidth(this.widthStack.pop());
        }
    };
}])
.factory('bgService',
                    ['helperService', function (helperService) {
                        return {
                            getValue: function (key) {
                                var value = helperService.getValue(key);
                                return value;
                            },
                            setValue: function (key, value) {
                                helperService.setValue(key, value);
                            },

                        };
                    }]
        )
.factory('mySharedService', ['$rootScope', function ($rootScope) {

    var sharedService = {};

    sharedService.message = '';
    sharedService.params = '';

    sharedService.contacts = [];
    sharedService.flags = {};

    sharedService.broadcast = function (msg, params) {
        // console.log('broadcasting  ', msg);
        this.message = msg;
        this.params = params;
        $rootScope.$broadcast('handleBroadcast');
    };

    return sharedService;
}])
.service('TimeTracker', ['$log', function ($log) {
    var reviewListLoaded = new Date().getTime();

    this.reviewListLoaded = function () {
        return reviewListLoaded;
    };

    this.setReviewListLoaded = function (date) {
        reviewListLoaded = date.getTime();
    };
    this.resetReviewListLoaded = function () {
        reviewListLoaded = new Date().getTime();
    };
}])
.run(['$route', function ($route) {
    $route.reload();
}]);

captureApp.filter('startFrom', function () {
    return function (input, start) {
        return input.slice(start);
    };
});

captureApp.constant('jQuery', window.jQuery);
captureApp.constant('lodash', window._);
captureApp.constant('X2JS', window.X2JS);
captureApp.constant('Base64', window.Base64);




// needed by angular 1.2 -> 1.3 migration
function registerController(name, controller, deps) {
    controller.$inject = deps;
    captureApp.controller(name, controller);
}



registerController('ContactController', ContactController, ['$scope', '$q', 'jQuery', 'lodash', 'mySharedService', 'X2JS', '$timeout', '$location', '$anchorScroll', 'linkedinService', 'debugUtility',
    'captureService', 'userInfoStore', 'multimerge.service', 'docSize',
    //'salesforce', 'dynamicsCrm', 'pipeliner', 'zoho',
    'exportWrapperService',
    'totangoService', 'contactUtility', 'dialogs', 'researchService', 'storageService', 'lookupService', 'limitService', 'bgService', 'endpoints', 'environmentUtility', 'shieldService', 'exportService', 'chromeUtility', 'driveService', 'modals', 'storeService'])
;
registerController('SearchController', SearchController, ['$scope', 'mySharedService']);
registerController('ProfilerController', ProfilerController, ['$scope', 'jQuery', 'X2JS', 'mySharedService', '$timeout', 'profilerService', 'contactUtility']);
registerController('CCaptureController', CCaptureController, ['$scope', 'jQuery', 'mySharedService', '$timeout', 'captureService', 'contactUtility', 'debugUtility', 'dialogs']);
registerController('AccountController', AccountController, ['$scope', '$location', 'mySharedService', '$timeout', 'docSize', 'environmentUtility', 'captureService', 'parsingService', 'debugUtility',
    'registrationService', 'chromeUtility',
    //'salesforce', 'dynamicsCrm', 'pipeliner', 'zoho', 
    'exportWrapperService',
    'shieldService', 'storeService', 'storageService', 'userInfoStore', 'totangoService', 'dialogs', 'patternStore', 'contactUtility', 'bgService', 'settingsUtility']);
registerController('DiverController', DiverController, ['$scope', 'X2JS', 'Base64', 'mySharedService', '$timeout', 'diverService']);






'use strict';

/* global angular: false */
/* global jQuery: false */

//function ngController($q, $scope) {

//    let controller = this;

//}

//  The partials for this are in main.html
angular.module('captureApp')

    .directive('contactCardEmailInfo', function () {
        return {
            restrict: 'EA',
            scope: {
                email: '@',
                verificationLevel: '@',
                verificationLevel2: '@'
            },
            templateUrl: 'components/partials/contacts/card/email-info.html'
        };
    })

    .directive('contactCardWebsite', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/website.html'
        };
    })

    .directive('contactCardLocationInfo', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/location-info.html'
        };
    })

    .directive('contactCardPhoneInfo', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/phone-info.html'
        };
    })

    .directive('contactCardJobInfo', function () {
        return {
            restrict: 'EA',
            template: '<div class="capture-card-cell"><span title="Job Title: {{contact.jobtitle}}">{{contact.jobtitle}}</span></div>'
        };
    })
    .directive('contactCardName', function () {
        return {
            restrict: 'EA',
            template: '<div class="capture-card-cell"><strong>{{contact.first}} {{contact.middle}} {{contact.last}}</strong></div>'
        };
    })
    .directive('contactCardIndustryInfo', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/industry-info.html'
        };
    })
    .directive('contactCardCompanyInfo', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/company-info.html'
        };
    })
    .directive('contactCardDetails', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/details.html'
        };
    })

    //.directive('contactCardDetailsTree', function () {
    //    return {
    //        restrict: 'EA',
    //        scope: {
    //            contact: '=',
    //            getVenueName: '&'
    //        },
    //        templateUrl: 'components/partials/contacts/card/details-tree.html'
    //    };
    //})

    .directive('contactCardDetailsTreePersonal', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/details-tree-personal.html'
        };
    })

    .directive('contactCardTreeNode', function () {
        return {
            restrict: 'EA',
            scope: {
                field: '@',
                value: '@',
                link: '@',
                contact: '=',
                action: '&',
                icon: '@',
                title: '@',
                always: '@'
            },
            controller: ['$scope', function ($scope) {

                $scope.openLink = function (url, currentTab) {
                    const functionName = 'Open Link';
                    try {
                        console.error(functionName, url);
                        if (url) {
                            if (url.indexOf('mailto:') !== 0) {
                                if (url.indexOf('://') < 0)
                                { url = 'https://' + url; }
                            }
                            //if (currentTab) {
                            //    chrome.tabs.update(tabs[0].id, { url: url });
                            //} else {
                            chrome.tabs.create({ url: url, active: false });
                            //}
                        }
                    } catch (e) {
                        console.error(functionName, e);
                    }
                };

                $scope.diveLink = function (url) {
                    const functionName = 'Dive';
                    try {
                        console.error(functionName, $scope.contact, url);
                        $scope.dive($scope.contact, url);
                    } catch (e) {
                        console.error(functionName, e);
                    }
                };

            }],
            templateUrl: 'components/partials/contacts/card/details-tree-node3.html'
        };
    })

    .directive('contactCardVenues', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/venues.html'
        };
    })

     .directive('contactCardDups', function () {
         return {
             restrict: 'EA',
             templateUrl: 'components/partials/contacts/card/dups.html'
         };
     })

    .directive('contactCardButtons', function () {
        return {
            restrict: 'EA',
            templateUrl: 'components/partials/contacts/card/buttons.html'
        };
    })

    .directive('contactCard', function () {
        return {
            restrict: 'EA',
            scope: false,
            templateUrl: 'components/partials/contacts/card/card3.html'
        };
    })
     .directive('loader', function ($compile) {
         return {
             restrict: 'EA',
             //require: 'ngModel',
             transclude: true,
             scope: {
                 loading: '=',
                 message: '@'
             },
             controller: ['$q', '$scope', function ($q, $scope) {
                 //let controller = this;
             }],

             link: function (scope, element, attrs, ctrl) {
             },

             template: `
                <div ng-show="loading">
                    <div class="row"><div class="col-xs-12 text-center">{{message || 'Loading...'}}</div></div>
                    <div class="row"><div class="col-xs-12 text-center"><img src="/images/103.GIF"></div></div>
                </div>
                <ng-transclude ng-hide="loading"></ng-transclude>

                `
         };
     })
    .directive('forceModelUpdate', function ($compile) {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                scope.$on('event:force-model-update', function () {
                    ctrl.$setViewValue(element.val());
                });
            }
        };
    })
    .directive('ngEnter', function () {
        return function (scope, element, attrs) {
            element.bind('keydown keypress', function (event) {
                if (event.which === 13) {
                    scope.$apply(function () {
                        scope.$eval(attrs.ngEnter);
                    });

                    event.preventDefault();
                }
            });
        };
    })
    .directive('contenteditable', function () {
        return {
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                // view -> model
                element.bind('blur', function () {
                    scope.$apply(function () {
                        ctrl.$setViewValue(element.html());
                    });
                });

                // model -> view
                ctrl.$render = function () {
                    element.html(ctrl.$viewValue);
                };

                ctrl.$render();
            }
        };
    })
    .directive('customAutofocus', function () {
        return {
            restrict: 'A',

            link: function (scope, element, attrs) {
                scope.$watch(function () {
                    return scope.$eval(attrs.customAutofocus);
                }, function (newValue) {
                    if (newValue) {
                        element[0].focus();//use focus function instead of autofocus attribute to avoid cross browser problem. And autofocus should only be used to mark an element to be focused when page loads.
                    }
                });
            }
        };
    })
    .directive('showonhoverparent', function () {
        return {
            link: function (scope, element, attrs) {
                element.parent().bind('mouseenter', function () {
                    element.show();
                });
                element.parent().bind('mouseleave', function () {
                    element.hide();
                });
            }
        };
    })
    .directive('showonhovergrandparent', function () {
        return {
            link: function (scope, element, attrs) {
                element.parent().parent().bind('mouseenter', function () {
                    element.show();
                });
                element.parent().parent().bind('mouseleave', function () {
                    element.hide();
                });
            }
        };
    })
    .directive('repeatComplete', function ($rootScope) {

        // Because we can have multiple ng-repeat directives in
        // the same container, we need a way to differentiate
        // the different sets of elements. We'll add a unique ID
        // to each set.
        var uuid = 0;


        // I compile the DOM node before it is linked by the
        // ng-repeat directive.
        function compile(tElement, tAttributes) {

            // Get the unique ID that we'll be using for this
            // particular instance of the directive.
            var id = ++uuid;

            // Add the unique ID so we know how to query for
            // DOM elements during the digests.
            tElement.attr('repeat-complete-id', id);

            // Since this directive doesn't have a linking phase,
            // remove it from the DOM node.
            tElement.removeAttr('repeat-complete');

            // Keep track of the expression we're going to
            // invoke once the ng-repeat has finished
            // rendering.
            var completeExpression = tAttributes.repeatComplete;

            // Get the element that contains the list. We'll
            // use this element as the launch point for our
            // DOM search query.
            var parent = tElement.parent();

            // Get the scope associated with the parent - we
            // want to get as close to the ngRepeat so that our
            // watcher will automatically unbind as soon as the
            // parent scope is destroyed.
            var parentScope = (parent.scope() || $rootScope);

            // Since we are outside of the ng-repeat directive,
            // we'll have to check the state of the DOM during
            // each $digest phase; BUT, we only need to do this
            // once, so save a referene to the un-watcher.
            var unbindWatcher = parentScope.$watch(
                function () {

                    //console.info('Digest running.');

                    // Now that we're in a digest, check to see
                    // if there are any ngRepeat items being
                    // rendered. Since we want to know when the
                    // list has completed, we only need the last
                    // one we can find.
                    var lastItem = parent.children('*[ repeat-complete-id = \'' + id + '\' ]:last');

                    // If no items have been rendered yet, stop.
                    if (!lastItem.length) {

                        return;

                    }

                    // Get the local ng-repeat scope for the item.
                    var itemScope = lastItem.scope();

                    // If the item is the "last" item as defined
                    // by the ng-repeat directive, then we know
                    // that the ng-repeat directive has finished
                    // rendering its list (for the first time).
                    if (itemScope.$last) {

                        // Stop watching for changes - we only
                        // care about the first complete rendering.
                        unbindWatcher();

                        // Invoke the callback.
                        itemScope.$eval(completeExpression);

                    }

                }
            );

        }

        // Return the directive configuration. It's important
        // that this compiles before the ngRepeat directive
        // compiles the DOM node.
        return ({
            compile: compile,
            priority: 1001,
            restrict: 'A'
        });

    }
            )
    .directive('postRepeatDirective',
      ['$timeout', '$log', 'TimeTracker',
      function ($timeout, $log, TimeTracker) {
          return function (scope, element, attrs) {
              if (scope.$last) {
                  $timeout(function () {
                      var timeFinishedLoadingList = TimeTracker.reviewListLoaded();
                      var ref = new Date(timeFinishedLoadingList);
                      var end = new Date();
                      var sec = (end - ref) / 1000;
                      //$log.debug('## DOM rendering list took: ' + sec + ' s');
                  });
              }
          };
      }
      ])

;
'use strict';

/* global angular: false */

angular.module('captureApp')
    .config(['$routeProvider', function ($routeProvider) {
        $routeProvider.
            when('/searches', {
                templateUrl: 'components/views/searches.html',
            }).
            when('/register', {
                templateUrl: 'components/views/register.html',
            }).
            when('/subscription', {
                templateUrl: 'components/views/subscription.html',
            }).
            when('/subaccounts', {
                templateUrl: 'components/views/subaccounts.html',
            }).
            when('/settings', {
                templateUrl: 'components/views/settings.html',
            }).
            when('/signin', {
                templateUrl: 'components/views/signin.html',
            }).
            when('/home', {
                templateUrl: 'components/views/home2.html',
            }).
            when('/patterns', {
                templateUrl: 'components/views/pattern/view.html',
            }).
            otherwise({
                //redirectTo: '/home'
                redirectTo: '/signin'
            });

    }])
    .config(['$httpProvider', function($httpProvider) {
        $httpProvider.defaults.headers.patch = {
            'Content-Type': 'application/json;charset=utf-8'
        };
    }])
    .config(['$compileProvider', function ($compileProvider) {
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|chrome-extension):/);
            //$compileProvider.aHrefSanitizationWhitelist(/\S*/);
            // Angular before v1.2 uses $compileProvider.urlSanitizationWhitelist(...)
        }
    ])
;
'use strict';

/* global angular: false */

//     Create a namespace for our utilities (defined in untilites sub folder)
var utilitiesModule = angular.module('utilities', []);

'use strict';

/* global angular: false */

angular.module('utilities')
.factory('userInfoStore', ['$http', 'chromeUtility', function ($http, chromeUtility) {
    var storeConfig = {
        loaded: false,
        key: 'userInfoStore',
        debug: false,
        //disableChromeStorage: false,
        loadCallbacks: []
    };
    var store = {
        //profile:{},
        //auth: {},
        //license: {}
    };
    var storeLocal = {

    };

    //  Private functions
    var saveStore = function () {
        const functionName = 'Save User Info Store';
        if (storeConfig.debug) { console.log(functionName + ' > Config > ', storeConfig); }

        //if (storeConfig.disableChromeStorage) {
        //    console.warn('Chrome Storage may not be available!');
        //}

        if (storeConfig.debug) { console.log('userInfoStore.saveStore:', store); }

        try {
            chromeUtility.setField(storeConfig.key, store, function () {
                if (storeConfig.debug) { console.log('userInfoStore.saveStore:success'); }
            }, function () {
                if (storeConfig.debug) { console.log('userInfoStore.saveStore:fail', chrome.runtime.lastError); }
            });
        } catch (e) {
            console.error(functionName + ' > Set Cloud', e.message);
        }

        try {
            chromeUtility.setFieldLocal(storeConfig.key, storeLocal, function () {
                if (storeConfig.debug) { console.log('userInfoStore.saveStoreLocal:success'); }
            }, function () {
                if (storeConfig.debug) { console.log('userInfoStore.saveStoreLocal:fail', chrome.runtime.lastError); }
            });
        } catch (e) {
            console.error(functionName + ' > Set Local', e.message);
        }

    };
    var loadStore = function () {
        const functionName = 'Load User Info Store';
        if (storeConfig.loaded) { return; }
        if (storeConfig.debug) { console.log('userInfoStore.loadStore... config=', storeConfig); }

        //if (storeConfig.disableChromeStorage) {
        //    console.warn('Chrome Storage may not be available!');
        //}

        var finish = function () {
            storeConfig.loaded = true;
            //  Do callbacks
            for (var index in storeConfig.loadCallbacks) {
                try { storeConfig.loadCallbacks[index](); } catch (e) { }
            }
        };

        try {
            chromeUtility.getFieldLocal(storeConfig.key, function (data) {
                if (data) { storeLocal = data; }
                if (storeConfig.debug) { console.log('userInfoStore.loadStoreLocal:', data); }
            });
        } catch (e) {
            console.error(functionName + ' > Get Local', e.message);
        }

        try {
            chromeUtility.getField(storeConfig.key, function (data) {
                if (data) { store = data; }
                if (storeConfig.debug) { console.log('userInfoStore.loadStore:', data); }
                finish();
            });
        } catch (e) {
            console.error(functionName + ' > Get Cloud', e.message);
            finish();
        }
    };
    var clearStore = function () {
        if (storeConfig.debug) { console.log('userInfoStore.clearStore:', storeConfig); }
        chromeUtility.clearField(storeConfig.key);
    };
    var setStoreData = function (key, data) {
        var value = angular.copy(data);
        //if (storeConfig.debug) { console.log('userInfoStore.setStoreData:', key, value, 'same=', store[key] === value); }
        if (store[key] === value) { return; }
        store[key] = value;
        saveStore();
    };
    var getStoreData = function (key) {
        var value = angular.copy(store[key]);
        //if (storeConfig.debug) { console.log('userInfoStore.getStoreData:', key, value); }
        return value;
    };
    var setLocalStoreData = function (key, data) {
        var value = angular.copy(data);
        //if (storeConfig.debug) { console.log('userInfoStore.setStoreData:', key, value, 'same=', store[key] === value); }
        if (storeLocal[key] === value) { return; }
        storeLocal[key] = value;
        saveStore();
    };
    var getLocalStoreData = function (key) {
        var value = angular.copy(storeLocal[key]);
        return value;
    };

    //loadStore(); //Test!

    //  Public functions
    var service = {
        isLoaded: function () {
            return storeConfig.loaded;
        },
        onLoaded: function (callback) {
            if (storeConfig.loaded) {
                try { callback(); } catch (e) { }
                return;
            }
            storeConfig.loadCallbacks.push(callback);
        },
        load: function () {
            loadStore();
        },
        loadManual: function (data) {
            //storeConfig.disableChromeStorage = true;
            if (!storeConfig.loaded) {
                store = data;
                storeLocal = data;
            }
            loadStore();
        },
        clear: function () {
            clearStore();
        },

        getSiteKey: function () {
            return getStoreData('siteKey');
        },
        setSiteKey: function (data) {
            setStoreData('siteKey', data);
        },

        getCrmId: function () {
            return getStoreData('crmId');
        },
        setCrmId: function (data) {
            setStoreData('crmId', data);
        },


        getShieldAuth: function () {
            return getStoreData('ShieldAuth');
        },
        setShieldAuth: function (data) {
            setStoreData('ShieldAuth', data);
        },

        getShieldId: function () {
            return getStoreData('ShieldId');
        },
        setShieldId: function (data) {
            setStoreData('ShieldId', data);
        },

        getShieldScheme: function () {
            return getStoreData('ShieldScheme');
        },
        setShieldScheme: function (data) {
            setStoreData('ShieldScheme', data);

            // removed old value
            if (getStoreData('ShieldSchema'))
            { setStoreData('ShieldSchema', null); }
        },

        getProfileName: function () {
            return getStoreData('ProfileName');
        },
        setProfileName: function (data) {
            setStoreData('ProfileName', data);
        },

        getProfileTitle: function () {
            return getStoreData('ProfileTitle');
        },
        setProfileTitle: function (data) {
            setStoreData('ProfileTitle', data);
        },

        getProfileCompany: function () {
            return getStoreData('ProfileCompany');
        },
        setProfileCompany: function (data) {
            setStoreData('ProfileCompany', data);
        },

        getProfilePhone: function () {
            return getStoreData('ProfilePhone');
        },
        setProfilePhone: function (data) {
            setStoreData('ProfilePhone', data);
        },

        getProfileTarget: function () {
            var t = getStoreData('ProfileTarget');
            console.log('********************************* get target', t);
            return t;
        },
        setProfileTarget: function (data) {
            console.log('********************************* set target', data);
            setStoreData('ProfileTarget', data);
        },

        getProfileEmail: function () {
            return getStoreData('ProfileEmail');
        },
        setProfileEmail: function (data) {
            setStoreData('ProfileEmail', data);
        },

        getSettings: function () {
            return getStoreData('Settings');
        },
        setSettings: function (data) {
            setStoreData('Settings', data);
        },
        getTarget: function () {
            return getStoreData('Target');
        },
        setTarget: function (data) {
            setStoreData('Target', data);
        },
        getTargetUrl: function () {
            return getStoreData('TargetUrl');
        },
        setTargetUrl: function (data) {
            setStoreData('TargetUrl', data);
        },
    };

    return service;
}]);

'use strict';

/* global angular: false */

angular.module('utilities')
.factory('debugUtility', [function () {
    return {
         addLoggingProperties: function(obj) {
            //obj.LOG_LEVEL_NONE = 0;
            //obj.LOG_LEVEL_ERRORS = 1;
            //obj.LOG_LEVEL_ALL = 2;

            //obj.logLevel = obj.logLevel || obj.LOG_LEVEL_NONE;

            //obj.canLogDebug = function() {
            //    return (this.logLevel >= this.LOG_LEVEL_ALL);
            //};
            //obj.canLogErrors = function() {
            //    return (this.logLevel >= this.LOG_LEVEL_ALL);
            //};

         }

     };
}]);

'use strict';

/* global angular: false */

angular.module('utilities')
.factory('xmlUtility', [function () {
    return {
        prolog:   '<?xml version="1.0"?>',
        xmlencode: function (string) {
            if (!string) { return ''; }
            return string.replace(/\&/g, '&' + 'amp;').replace(/</g, '&' + 'lt;').replace(/>/g, '&' + 'gt;').replace(/\'/g, '&' + 'apos;').replace(/\"/g, '&' + 'quot;');
        },
        xmldecode: function (string) {
            if (!string) { return ''; }
            return string.replace(/\&amp;/g, '&').replace(/\&lt;/g, '<').replace(/\&gt;/g, '>').replace(/\&apos;/g, '\'').replace(/\&quot;/g, '"');
        },

        //  Duplicate of xmlEncode, which just xml encodes a string
        encode: function (string) {
            if (typeof string === 'undefined') { string = ''; }
            string += '';
            if (!string) { return ''; }
            return string.replace(/\&/g, '&' + 'amp;').replace(/</g, '&' + 'lt;').replace(/>/g, '&' + 'gt;').replace(/\'/g, '&' + 'apos;').replace(/\"/g, '&' + 'quot;');
        },
        //  Wraps tags around a string
        tag: function(string, tag, onlyIfValid){

            if(onlyIfValid && !string) { return ''; }
            return '<' + tag + '>' + string + '</' + tag +'>';
        },
        //  XML encodes a string then wraps it in tags
        encodeAndWrap: function(string, tag, onlyIfValid){
            if(onlyIfValid && !string) { return ''; }
            return this.tag(this.encode(string), tag);
        },
        //  xml encode a string, wrap it in tags, and push it into an array
        encodeWrapPush: function(stringToEncode, tagToWrap, arrayToPush, onlyIfValid){
            if(onlyIfValid && !stringToEncode){ return; }
            arrayToPush.push(this.encodeAndWrap(stringToEncode, tagToWrap));
        },
        //  Wrap a string in tags, and push into an array
        wrapAndPush: function(data, tagToWrap, arrayToPush, onlyIfValid){
            if(onlyIfValid && !data){ return; }
            arrayToPush.push(this.tag(data, tagToWrap));
        },

        //  encodes paramaters object into xml header {key:value, key2:value2} BECOMES  <?xml version="1.0"?><request><key>value</key><key2>value2</key2></request>
        encodeParameters: function(parameters){
            var result = '';
            for(var key in parameters){
                if(parameters[key]) {
                    result += this.encodeAndWrap(parameters[key], key);
                }
            }
            return this.prolog + this.tag(result, 'request');
        },




        getTagValueWithPosition: function (html, tag, className, attr) {

            var pos = null;

            if (!html) { return { value: '', position: pos };  }


            var n = html.length;
            var tagCharIndex = 0;
            var attrCharIndex = 0;
            var classCharIndex = 0;

            var state = 'tag-search';
            if (!attr) {
                attr = ' class=';
            }
            var value = [];

            var tagCounter = 0;
            var i = 0;
            while (i < n) {

                switch (state) {

                     case 'tag-search':

                         if (html[i] === tag[tagCharIndex]) {
                             if (tagCharIndex === (tag.length - 1)) {
                                 attrCharIndex = 0;
                                 if (className) {
                                     state = 'attr-search';
                                 } else {
                                     state = 'value-search';
                                 }
                             } else {
                                 tagCharIndex++;
                             }
                         }
                         else {
                             tagCharIndex = 0;
                         }

                         break;

                     case 'attr-search':

                         if (html[i] === attr[attrCharIndex]) {
                             if (attrCharIndex === (attr.length - 1)) {
                                 state = 'class-search';
                                 classCharIndex = 0;
                                 i++; // skip an opening quote
                             } else {
                                 attrCharIndex++;
                             }
                         }
                         else {
                             attrCharIndex = 0;

                             if (html[i] === '>') {
                                 tagCharIndex = 0;
                                 state = 'tag-search';
                             }
                         }


                         break;

                     case 'class-search':

                         if (html[i] === className[classCharIndex]) {
                             if (classCharIndex === (className.length - 1)) {
                                 state = 'value-search';
                             } else {
                                 classCharIndex++;
                             }
                         }
                         else {
                             classCharIndex = 0;

                             if (html[i] === '>' || html[i] === '"' || html[i] === '\'') {
                                 tagCharIndex = 0;
                                 state = 'tag-search';
                             }
                         }

                         break;

                     case 'value-search':

                         if (html[i] === '>') {
                             state = 'value-read';
                         }

                         break;

                     case 'value-read':

                         if (html[i] === '<' && html.substring(i, i + tag.length + 3) === ('</' + tag + '>')) {
                             tagCounter--;
                             if (tagCounter < 0) {
                                 pos = i;
                                 state = 'done';
                                 break;
                             }
                             //return xmlUtility.xmldecode(value.join('')).trim();
                         }
                         else if (html[i] === '<' && html.substring(i, i + tag.length + 1) === ('<' + tag)) {
                             tagCounter++;
                         }
                         
                         value.push(html[i]);
                         

                         break;

                     default:
                }
                i++;
            }
            return { value: this.xmldecode(value.join('')).trim(), position: pos };
        },
        getTagValue: function (html, tag, className, attr) {
            return this.getTagValueWithPosition(html, tag, className, attr).value;
        },

        getTagValues: function (html, tag, className, attr) {

            if (!html) { return []; }

            var results = [];

            var n = html.length;
            var tagCharIndex = 0;
            var attrCharIndex = 0;
            var classCharIndex = 0;

            var state = 'tag-search';
            if (!attr) {
                attr = ' class=';
            }
            var value = [];
            var tagCounter = 0;

            var i = 0;
            while (i < n) {

                switch (state) {

                     case 'tag-search':

                         if (html[i] === tag[tagCharIndex]) {
                             if (tagCharIndex === (tag.length - 1)) {
                                 attrCharIndex = 0;
                                 if (className) {
                                     state = 'attr-search';
                                 } else {
                                     state = 'value-search';
                                 }
                             } else {
                                 tagCharIndex++;
                             }
                         }
                         else {
                             tagCharIndex = 0;
                         }

                         break;

                     case 'attr-search':

                         if (html[i] === attr[attrCharIndex]) {
                             if (attrCharIndex === (attr.length - 1)) {
                                 state = 'class-search';
                                 classCharIndex = 0;
                                 i++; // skip an opening quote
                             } else {
                                 attrCharIndex++;
                             }
                         }
                         else {
                             attrCharIndex = 0;

                             if (html[i] === '>') {
                                 tagCharIndex = 0;
                                 state = 'tag-search';
                             }
                         }


                         break;

                     case 'class-search':

                         if (html[i] === className[classCharIndex]) {
                             if (classCharIndex === (className.length - 1)) {
                                 state = 'value-search';
                             } else {
                                 classCharIndex++;
                             }
                         }
                         else {
                             classCharIndex = 0;

                             if (html[i] === '>' || html[i] === '"' || html[i] === '\'') {
                                 tagCharIndex = 0;
                                 state = 'tag-search';
                             }
                         }

                         break;

                     case 'value-search':

                         if (html[i] === '>') {
                             state = 'value-read';
                             tagCounter = 0;
                         }

                         break;

                     case 'value-read':

                         if (html[i] === '<' && html.substring(i, i + tag.length + 3) === ('</' + tag + '>')) {
                             tagCounter--;

                             if (tagCounter < 0) {
                                 var res = this.xmldecode(value.join('')).trim();
                                 results.push({ value: res, position: i });
                                 value = [];
                                 state = 'tag-search';
                                 tagCharIndex = 0;
                                 attrCharIndex = 0;
                                 classCharIndex = 0;
                                 i = i + tag.length + 2;
                             } else {
                                 //console.log('tag counter >= 0', results.length, html.substring(i, i + 20));
                             }
                         }
                         else if (html[i] === '<' && html.substring(i, i + tag.length + 1) === ('<' + tag)) {
                             tagCounter++;
                         }
                         else {
                             value.push(html[i]);
                         }

                         break;

                     default:
                }
                i++;
            }
            return results;
        },

        getAttrValue: function (html, tag, attr) {

            if (!html) { return ''; }

            var n = html.length;
            var tagCharIndex = 0;
            var attrCharIndex = 0;


            var state = 'tag-search';
            if (!attr) {
                attr = 'href';
            }
            attr = ' ' + attr + '=';
            var value = [];

            //console.log('html: ' + html);
            //console.log('tag: ' + tag);
            //console.log('attr: ' + attr);

            var i = 0;
            while (i < n) {

                switch (state) {

                     case 'tag-search':
                         //console.log(state);
                         if (html[i] === tag[tagCharIndex]) {
                             if (tagCharIndex === (tag.length - 1)) {
                                 attrCharIndex = 0;
                                 state = 'attr-search';
                             } else {
                                 tagCharIndex++;
                             }
                         }
                         else {
                             tagCharIndex = 0;
                         }

                         break;

                     case 'attr-search':
                         //console.log(state);
                         if (html[i] === attr[attrCharIndex]) {
                             if (attrCharIndex === (attr.length - 1)) {
                                 state = 'value-read';
                                 if (html[i + 1] === '"' || html[i + 1] === '\'') {
                                     i++; // skip an opening quote
                                 }
                             } else {
                                 attrCharIndex++;
                             }
                         }
                         else {
                             attrCharIndex = 0;

                             if (html[i] === '>') {
                                 tagCharIndex = 0;
                                 state = 'tag-search';
                             }
                         }


                         break;

                     case 'value-read':
                         //console.log(html[i]);
                         //console.log(state);
                         if (html[i] === '<' || html[i] === '"' || html[i] === '\'' || html[i] === ' ') {
                             //return xmlUtility.xmldecode(value.join('')).trim();
                             state = 'done';
                         }
                         else {
                             value.push(html[i]);
                         }

                         break;

                     default:
                         //console.log('default: ' + state);
                         break;
                }
                i++;
            }
            return this.xmldecode(value.join('')).trim();
        },

        removeTags: function (s) {
            //console.log('removeTags');
            //console.log(s);
            if (s) {
                var regex = /(<([^>]+)>)/ig;
                s = s.replace(regex, '');
            }
            //console.log(s);
            return s;
        },

        getTags: function (s) {
            if (s) {
                var tagArray = s.match(/(<([^>]+)>)/ig);
                if (tagArray) {
                    return tagArray;
                }
            }
            return [];
        },

        getTagName: function(tag){
            tag = tag.substring(1);
            return tag.substring(0, tag.length - 1);

        }

    };
}]);

'use strict';

/* global angular: false */
/* global firstNameGraphDriver: false */

angular.module('utilities')
.factory('contactUtility', ['xmlUtility', function (xmlUtility) {
    var socialDomains = [
        { domain: 'linkedin.com', venue: 'linkedin' },
        { domain: 'facebook.com', venue: 'facebook' },
        { domain: 'foursquare.com', venue: 'foursquare' },
        { domain: 'twitter.com', venue: 'twitter' },
        { domain: 'youtube', venue: 'youtube' },
        { domain: 'vimeo.com', venue: 'vimeo' },
        { domain: 'flickr.com', venue: 'flickr' },
        { domain: 'pinterest.com', venue: 'pinterest' },
        { domain: 'gravatar.com', venue: 'gravatar' },
        { domain: 'klout.com', venue: 'klout' },
        { domain: 'myspace.com', venue: 'myspace' },
        { domain: 'profiles.google.com', venue: 'googleprofile' },
        { domain: 'plus.google.com', venue: 'googleplus' },
        { domain: 'picasaweb.google.com', venue: 'googleplus' },
    ];

    var freeEmailDomains = ['0815.ru', '0clickemail.com', '10minutemail.com', '123.com', '123mail.org', '150mail.com', '150ml.com', '163.net', '16mail.com', '1gb.pl', '1me.net', '1mum.com', '20minutemail.com', '21cn.com', '263.net', '2gb.pl', '2-mail.com', '37.com', '420email.com', '4degreez.com', '4email.net', '5.am', '50mail.com', '8.am', 'a.org.ua', 'aaronkwok.net', 'abha.cc', 'abv.bg', 'aemail4u.com', 'aim.com', 'airmail.net', 'airpost.net', 'akcja.pl', 'allmail.net', 'alltel.net', 'altavista.com', 'altavista.net', 'america.hm', 'amexmail.com', 'amorki.pl', 'amrer.net', 'amuro.net', 'amuromail.com', 'andylau.net', 'angelfire.com', 'angelfire.lycos.com', 'anonbox.net', 'aol.co.uk', 'aol.com', 'aol.de', 'aol.fr', 'aol.in', 'aol.nl', 'aol.se', 'aport.ru', 'aroundhawaii.com', 'astaga.com', 'asurfer.com', 'atlas.cz', 'att.net', 'attglobal.net', 'attymail.com', 'ausi.com', 'aussiemail.com.au', 'autograf.pl', 'bahrainmail.com', 'bellatlantic.net', 'bellsouth.net', 'bestmail.us', 'bharatmail.com', 'bigfoot.com', 'bigpond.com', 'bikemechanics.com', 'binkmail.com', 'bitmail.com', 'bk.ru', 'blackplanet.com', 'blazemail.com', 'bluemail.ch', 'boardermail.com', 'bobmail.info', 'bol.com.br', 'bol.uol.com.br', 'bolt.com', 'boltonfans.com', 'bradfordfans.com', 'brain.net.pk', 'brainbench.com', 'bright.net', 'btinternet.com', 'buziaczek.pl', 'byke.com', 'canada.com', 'canada-11.com', 'caramail.com', 'caramail.fr', 'cd2.com', 'centras.lt', 'centurytel.net', 'charter.net', 'chat.ru', 'citlink.net', 'city-of-bath.org', 'city-of-birmingham.com', 'city-of-brighton.org', 'city-of-cambridge.com', 'cityofcardiff.net', 'city-of-coventry.com', 'city-of-edinburgh.com', 'city-of-lichfield.com', 'city-of-lincoln.com', 'city-of-liverpool.com', 'cityoflondon.org', 'city-of-manchester.com', 'city-of-nottingham.com', 'city-of-oxford.com', 'city-of-swansea.com', 'city-of-westminster.com', 'city-of-westminster.net', 'city-of-york.net', 'club4x4.net', 'clubalfa.com', 'clubbers.net', 'clubducati.com', 'clubhonda.net', 'cluemail.com', 'columbus.rr.com', 'comcast.net', 'compuserve.com', 'computermail.net', 'courrieltemporaire.com', 'cox.net', 'crosswinds.net', 'cs.com', 'cyber.net.pk', 'czateria.pl', 'dacoolest.com', 'data.bg', 'daum.net', 'dbzmail.com', 'dcemail.com', 'deadaddress.com', 'delfi.lt', 'dir.bg', 'dispostable.com', 'doctor.com', 'doramail.com', 'dostmail.com', 'draac.com', 'dslextreme.com', 'e4ward.com', 'earthlink.com', 'earthlink.net', 'echina.com', 'elitemail.org', 'email.de', 'email.msn.com', 'email.ro', 'email.ru', 'email60.com', 'emailaccount.com', 'e-mailanywhere.com', 'emailcorner.net', 'emailengine.net', 'emailengine.org', 'emailgroups.net', 'emailplus.org', 'emailsensei.com', 'emailuser.net', 'emirates.net.ae', 'eml.cc', 'epatra.com', 'epix.net', 'es.co.nz', 'etisalat.ae', 'eudoramail.com', 'everymail.com', 'excite.com', 'execpc.com', 'ezzemail.com', 'f1fans.net', 'fastem.com', 'fast-email.com', 'fastemail.us', 'fastemailer.com', 'fastest.cc', 'fastimap.com', 'fastmail.ca', 'fastmail.cn', 'fastmail.co.uk', 'fastmail.com.au', 'fastmail.es', 'fastmail.fm', 'fastmail.in', 'fastmail.jp', 'fastmail.net', 'fast-mail.org', 'fastmail.to', 'fastmail.us', 'fastmailbox.net', 'fastmessaging.com', 'fea.st', 'filzmail.com', 'flash.net', 'f-m.fm', 'fmail.co.uk', 'fmailbox.com', 'fmgirl.com', 'fmguy.com', 'freemail.com.au', 'freemail.de', 'freemail.gr', 'freemail.lt', 'freemail.org.mk', 'freenet.de', 'freestart.hu', 'frontier.my.yahoo.com', 'frontier.net', 'frontiernet.net', 'ftml.net', 'fuorissimo.com', 'fuse.net', 'gateway.net', 'gci.net', 'gmail.com', 'gmx.at', 'gmx.ch', 'gmx.de', 'gmx.fr', 'gmx.net', 'go.com', 'gobrainstorm.net', 'googlemail.com', 'guerrillamail.com', 'hailmail.net', 'hanmail.net', 'hawaii.rr.com', 'heesun.net', 'h-mail.us', 'home.ro', 'hongkong.com', 'hot.ee', 'hotbox.ru', 'hotmail.co.il', 'hotmail.co.jp', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.br', 'hotmail.com.tr', 'hotmail.de', 'hotmail.es', 'hotmail.fr', 'hotmail.it', 'hotmail.jp', 'hotmail.ru', 'hsuchi.net', 'hulapla.de', 'hushmail.com', 'icqmail.com', 'ig.com.br', 'ihug.co.nz', 'iinet.net.au', 'ilovejesus.com', 'imap.cc', 'imap-mail.com', 'imapmail.org', 'in.com', 'inbox.lv', 'inbox.ru', 'incognitomail.com', 'incredimail.com', 'india.com', 'indiainfo.com', 'indiatimes.com', 'indya.com', 'inmail.sk', 'inoutbox.com', 'interia.eu', 'interia.pl', 'internet-e-mail.com', 'internetemails.net', 'internet-mail.org', 'internetmailing.net', 'inwind.it', 'iol.it', 'ipa.net', 'iprimus.com.au', 'ivillage.com', 'iwon.com', 'ix.netcom.com', 'jetemail.net', 'jmail.co.za', 'jpopmail.com', 'jubiimail.dk', 'juno.com', 'justemail.net', 'kayafmmail.co.za', 'kc.rr.com', 'kellychen.com', 'keromail.com', 'kimo.com', 'kinki-kids.com', 'kinkyemail.com', 'kittymail.com', 'ladymail.cz', 'lankamail.com', 'latinmail.com', 'lawyer.com', 'leehom.net', 'leonlai.net', 'letterboxes.org', 'levele.hu', 'libero.it', 'linuxmail.org', 'live.at', 'live.be', 'live.ca', 'live.cl', 'live.cn', 'live.co.kr', 'live.co.uk', 'live.co.za', 'live.com', 'live.com.ar', 'live.com.au', 'live.com.mx', 'live.com.my', 'live.com.sg', 'live.de', 'live.dk', 'live.fr', 'live.hk', 'live.ie', 'live.in', 'live.it', 'live.jp', 'live.nl', 'live.no', 'live.ru', 'live.se', 'louiskoo.com', 'lovers-mail.com', 'lycos.co.de', 'lycos.co.uk', 'lycos.com', 'lycos.es', 'lycos.it', 'lycos.ne.jp', 'lycosemail.com', 'mac.com', 'madrid.com', 'magicmail.co.za', 'magpiesfan.co.uk', 'mail.az', 'mail.be', 'mail.by', 'mail.co.za', 'mail.com', 'mail.cz', 'mail.ee', 'mail.gr', 'mail.lv', 'mail.lycos.com', 'mail.nu', 'mail.pt', 'mail.ru', 'mail.webdunia.com', 'mail2007.com', 'mail2aaron.com', 'mail2abby.com', 'mail2abc.com', 'mail2actor.com', 'mail2admiral.com', 'mail2adorable.com', 'mail2adoration.com', 'mail2adore.com', 'mail2adventure.com', 'mail2aeolus.com', 'mail2aether.com', 'mail2affection.com', 'mail2afghanistan.com', 'mail2africa.com', 'mail2agent.com', 'mail2aha.com', 'mail2ahoy.com', 'mail2aim.com', 'mail2air.com', 'mail2airbag.com', 'mail2airforce.com', 'mail2airport.com', 'mail2alabama.com', 'mail2alan.com', 'mail2alaska.com', 'mail2albania.com', 'mail2alcoholic.com', 'mail2alec.com', 'mail2alexa.com', 'mail2algeria.com', 'mail2alicia.com', 'mail2alien.com', 'mail2allan.com', 'mail2allen.com', 'mail2allison.com', 'mail2alpha.com', 'mail2alyssa.com', 'mail2amanda.com', 'mail2amazing.com', 'mail2amber.com', 'mail2america.com', 'mail2american.com', 'mail2andorra.com', 'mail2andrea.com', 'mail2andy.com', 'mail2anesthesiologist.com', 'mail2angela.com', 'mail2angola.com', 'mail2ann.com', 'mail2anna.com', 'mail2anne.com', 'mail2anthony.com', 'mail2aphrodite.com', 'mail2apollo.com', 'mail2april.com', 'mail2aquarius.com', 'mail2arabia.com', 'mail2arabic.com', 'mail2architect.com', 'mail2ares.com', 'mail2argentina.com', 'mail2aries.com', 'mail2arizona.com', 'mail2arkansas.com', 'mail2armenia.com', 'mail2army.com', 'mail2arnold.com', 'mail2art.com', 'mail2arthur.com', 'mail2artist.com', 'mail2ashley.com', 'mail2ask.com', 'mail2astronomer.com', 'mail2athena.com', 'mail2athlete.com', 'mail2atlas.com', 'mail2atom.com', 'mail2attitude.com', 'mail2auction.com', 'mail2aunt.com', 'mail2australia.com', 'mail2austria.com', 'mail2azerbaijan.com', 'mail2baby.com', 'mail2bahamas.com', 'mail2bahrain.com', 'mail2ballerina.com', 'mail2ballplayer.com', 'mail2band.com', 'mail2bangladesh.com', 'mail2bank.com', 'mail2banker.com', 'mail2bankrupt.com', 'mail2baptist.com', 'mail2bar.com', 'mail2barbados.com', 'mail2barbara.com', 'mail2barter.com', 'mail2basketball.com', 'mail2batter.com', 'mail2beach.com', 'mail2beast.com', 'mail2beatles.com', 'mail2beauty.com', 'mail2becky.com', 'mail2beijing.com', 'mail2belgium.com', 'mail2belize.com', 'mail2ben.com', 'mail2bernard.com', 'mail2beth.com', 'mail2betty.com', 'mail2beverly.com', 'mail2beyond.com', 'mail2biker.com', 'mail2bill.com', 'mail2billionaire.com', 'mail2billy.com', 'mail2bio.com', 'mail2biologist.com', 'mail2black.com', 'mail2blackbelt.com', 'mail2blake.com', 'mail2blind.com', 'mail2blonde.com', 'mail2blues.com', 'mail2bob.com', 'mail2bobby.com', 'mail2bolivia.com', 'mail2bombay.com', 'mail2bonn.com', 'mail2bookmark.com', 'mail2boreas.com', 'mail2bosnia.com', 'mail2boston.com', 'mail2botswana.com', 'mail2bradley.com', 'mail2brazil.com', 'mail2breakfast.com', 'mail2brian.com', 'mail2bride.com', 'mail2brittany.com', 'mail2broker.com', 'mail2brook.com', 'mail2bruce.com', 'mail2brunei.com', 'mail2brunette.com', 'mail2brussels.com', 'mail2bryan.com', 'mail2bug.com', 'mail2bulgaria.com', 'mail2business.com', 'mail2buy.com', 'mail2ca.com', 'mail2california.com', 'mail2calvin.com', 'mail2cambodia.com', 'mail2cameroon.com', 'mail2canada.com', 'mail2cancer.com', 'mail2capeverde.com', 'mail2capricorn.com', 'mail2cardinal.com', 'mail2cardiologist.com', 'mail2care.com', 'mail2caroline.com', 'mail2carolyn.com', 'mail2casey.com', 'mail2cat.com', 'mail2caterer.com', 'mail2cathy.com', 'mail2catlover.com', 'mail2catwalk.com', 'mail2cell.com', 'mail2chad.com', 'mail2champaign.com', 'mail2charles.com', 'mail2chef.com', 'mail2chemist.com', 'mail2cherry.com', 'mail2chicago.com', 'mail2chile.com', 'mail2china.com', 'mail2chinese.com', 'mail2chocolate.com', 'mail2christian.com', 'mail2christie.com', 'mail2christmas.com', 'mail2christy.com', 'mail2chuck.com', 'mail2cindy.com', 'mail2clark.com', 'mail2classifieds.com', 'mail2claude.com', 'mail2cliff.com', 'mail2clinic.com', 'mail2clint.com', 'mail2close.com', 'mail2club.com', 'mail2coach.com', 'mail2coastguard.com', 'mail2colin.com', 'mail2college.com', 'mail2color.com', 'mail2colorado.com', 'mail2columbia.com', 'mail2comedian.com', 'mail2composer.com', 'mail2computer.com', 'mail2computers.com', 'mail2concert.com', 'mail2congo.com', 'mail2connect.com', 'mail2connecticut.com', 'mail2consultant.com', 'mail2convict.com', 'mail2cook.com', 'mail2cool.com', 'mail2cory.com', 'mail2costarica.com', 'mail2country.com', 'mail2courtney.com', 'mail2cowboy.com', 'mail2cowgirl.com', 'mail2craig.com', 'mail2crave.com', 'mail2crazy.com', 'mail2create.com', 'mail2croatia.com', 'mail2cry.com', 'mail2crystal.com', 'mail2cuba.com', 'mail2culture.com', 'mail2curt.com', 'mail2customs.com', 'mail2cute.com', 'mail2cutey.com', 'mail2cynthia.com', 'mail2cyprus.com', 'mail2czechrepublic.com', 'mail2dad.com', 'mail2dale.com', 'mail2dallas.com', 'mail2dan.com', 'mail2dana.com', 'mail2dance.com', 'mail2dancer.com', 'mail2danielle.com', 'mail2danny.com', 'mail2darlene.com', 'mail2darling.com', 'mail2darren.com', 'mail2daughter.com', 'mail2dave.com', 'mail2dawn.com', 'mail2dc.com', 'mail2dealer.com', 'mail2deanna.com', 'mail2dearest.com', 'mail2debbie.com', 'mail2debby.com', 'mail2deer.com', 'mail2delaware.com', 'mail2delicious.com', 'mail2demeter.com', 'mail2democrat.com', 'mail2denise.com', 'mail2denmark.com', 'mail2dennis.com', 'mail2dentist.com', 'mail2derek.com', 'mail2desert.com', 'mail2devoted.com', 'mail2devotion.com', 'mail2diamond.com', 'mail2diana.com', 'mail2diane.com', 'mail2diehard.com', 'mail2dilemma.com', 'mail2dillon.com', 'mail2dinner.com', 'mail2dinosaur.com', 'mail2dionysos.com', 'mail2diplomat.com', 'mail2director.com', 'mail2dirk.com', 'mail2disco.com', 'mail2dive.com', 'mail2diver.com', 'mail2divorced.com', 'mail2djibouti.com', 'mail2doctor.com', 'mail2doglover.com', 'mail2dominic.com', 'mail2dominica.com', 'mail2dominicanrepublic.com', 'mail2don.com', 'mail2donald.com', 'mail2donna.com', 'mail2doris.com', 'mail2dorothy.com', 'mail2doug.com', 'mail2dough.com', 'mail2douglas.com', 'mail2dow.com', 'mail2downtown.com', 'mail2dream.com', 'mail2dreamer.com', 'mail2dude.com', 'mail2dustin.com', 'mail2dyke.com', 'mail2dylan.com', 'mail2earl.com', 'mail2earth.com', 'mail2eastend.com', 'mail2eat.com', 'mail2economist.com', 'mail2ecuador.com', 'mail2eddie.com', 'mail2edgar.com', 'mail2edwin.com', 'mail2egypt.com', 'mail2electron.com', 'mail2eli.com', 'mail2elizabeth.com', 'mail2ellen.com', 'mail2elliot.com', 'mail2elsalvador.com', 'mail2elvis.com', 'mail2emergency.com', 'mail2emily.com', 'mail2engineer.com', 'mail2english.com', 'mail2environmentalist.com', 'mail2eos.com', 'mail2eric.com', 'mail2erica.com', 'mail2erin.com', 'mail2erinyes.com', 'mail2eris.com', 'mail2eritrea.com', 'mail2ernie.com', 'mail2eros.com', 'mail2estonia.com', 'mail2ethan.com', 'mail2ethiopia.com', 'mail2eu.com', 'mail2europe.com', 'mail2eurus.com', 'mail2eva.com', 'mail2evan.com', 'mail2evelyn.com', 'mail2everything.com', 'mail2exciting.com', 'mail2expert.com', 'mail2fairy.com', 'mail2faith.com', 'mail2fanatic.com', 'mail2fancy.com', 'mail2fantasy.com', 'mail2farm.com', 'mail2farmer.com', 'mail2fashion.com', 'mail2fat.com', 'mail2feeling.com', 'mail2female.com', 'mail2fever.com', 'mail2fighter.com', 'mail2fiji.com', 'mail2filmfestival.com', 'mail2films.com', 'mail2finance.com', 'mail2finland.com', 'mail2fireman.com', 'mail2firm.com', 'mail2fisherman.com', 'mail2flexible.com', 'mail2florence.com', 'mail2florida.com', 'mail2floyd.com', 'mail2fly.com', 'mail2fond.com', 'mail2fondness.com', 'mail2football.com', 'mail2footballfan.com', 'mail2found.com', 'mail2france.com', 'mail2frank.com', 'mail2frankfurt.com', 'mail2franklin.com', 'mail2fred.com', 'mail2freddie.com', 'mail2free.com', 'mail2freedom.com', 'mail2french.com', 'mail2freudian.com', 'mail2friendship.com', 'mail2from.com', 'mail2fun.com', 'mail2gabon.com', 'mail2gabriel.com', 'mail2gail.com', 'mail2galaxy.com', 'mail2gambia.com', 'mail2games.com', 'mail2gary.com', 'mail2gavin.com', 'mail2gemini.com', 'mail2gene.com', 'mail2genes.com', 'mail2geneva.com', 'mail2george.com', 'mail2georgia.com', 'mail2gerald.com', 'mail2german.com', 'mail2germany.com', 'mail2ghana.com', 'mail2gilbert.com', 'mail2gina.com', 'mail2girl.com', 'mail2glen.com', 'mail2gloria.com', 'mail2goddess.com', 'mail2gold.com', 'mail2golfclub.com', 'mail2golfer.com', 'mail2gordon.com', 'mail2government.com', 'mail2grab.com', 'mail2grace.com', 'mail2graham.com', 'mail2grandma.com', 'mail2grandpa.com', 'mail2grant.com', 'mail2greece.com', 'mail2green.com', 'mail2greg.com', 'mail2grenada.com', 'mail2gsm.com', 'mail2guard.com', 'mail2guatemala.com', 'mail2guy.com', 'mail2hades.com', 'mail2haiti.com', 'mail2hal.com', 'mail2handhelds.com', 'mail2hank.com', 'mail2hannah.com', 'mail2harold.com', 'mail2harry.com', 'mail2hawaii.com', 'mail2headhunter.com', 'mail2heal.com', 'mail2heather.com', 'mail2heaven.com', 'mail2hebe.com', 'mail2hecate.com', 'mail2heidi.com', 'mail2helen.com', 'mail2hell.com', 'mail2help.com', 'mail2helpdesk.com', 'mail2henry.com', 'mail2hephaestus.com', 'mail2hera.com', 'mail2hercules.com', 'mail2herman.com', 'mail2hermes.com', 'mail2hespera.com', 'mail2hestia.com', 'mail2highschool.com', 'mail2hindu.com', 'mail2hip.com', 'mail2hiphop.com', 'mail2holland.com', 'mail2holly.com', 'mail2hollywood.com', 'mail2homer.com', 'mail2honduras.com', 'mail2honey.com', 'mail2hongkong.com', 'mail2hope.com', 'mail2horse.com', 'mail2hot.com', 'mail2hotel.com', 'mail2houston.com', 'mail2howard.com', 'mail2hugh.com', 'mail2human.com', 'mail2hungary.com', 'mail2hungry.com', 'mail2hygeia.com', 'mail2hyperspace.com', 'mail2hypnos.com', 'mail2ian.com', 'mail2ice-cream.com', 'mail2iceland.com', 'mail2idaho.com', 'mail2idontknow.com', 'mail2illinois.com', 'mail2imam.com', 'mail2in.com', 'mail2india.com', 'mail2indian.com', 'mail2indiana.com', 'mail2indonesia.com', 'mail2infinity.com', 'mail2intense.com', 'mail2iowa.com', 'mail2iran.com', 'mail2iraq.com', 'mail2ireland.com', 'mail2irene.com', 'mail2iris.com', 'mail2irresistible.com', 'mail2irving.com', 'mail2irwin.com', 'mail2isaac.com', 'mail2israel.com', 'mail2italian.com', 'mail2italy.com', 'mail2jackie.com', 'mail2jacob.com', 'mail2jail.com', 'mail2jaime.com', 'mail2jake.com', 'mail2jamaica.com', 'mail2james.com', 'mail2jamie.com', 'mail2jan.com', 'mail2jane.com', 'mail2janet.com', 'mail2janice.com', 'mail2japan.com', 'mail2japanese.com', 'mail2jasmine.com', 'mail2jason.com', 'mail2java.com', 'mail2jay.com', 'mail2jazz.com', 'mail2jed.com', 'mail2jeffrey.com', 'mail2jennifer.com', 'mail2jenny.com', 'mail2jeremy.com', 'mail2jerry.com', 'mail2jessica.com', 'mail2jessie.com', 'mail2jesus.com', 'mail2jew.com', 'mail2jeweler.com', 'mail2jim.com', 'mail2jimmy.com', 'mail2joan.com', 'mail2joann.com', 'mail2joanna.com', 'mail2jody.com', 'mail2joe.com', 'mail2joel.com', 'mail2joey.com', 'mail2john.com', 'mail2join.com', 'mail2jon.com', 'mail2jonathan.com', 'mail2jones.com', 'mail2jordan.com', 'mail2joseph.com', 'mail2josh.com', 'mail2joy.com', 'mail2juan.com', 'mail2judge.com', 'mail2judy.com', 'mail2juggler.com', 'mail2julian.com', 'mail2julie.com', 'mail2jumbo.com', 'mail2junk.com', 'mail2justin.com', 'mail2justme.com', 'mail2kansas.com', 'mail2karate.com', 'mail2karen.com', 'mail2karl.com', 'mail2karma.com', 'mail2kathleen.com', 'mail2kathy.com', 'mail2katie.com', 'mail2kay.com', 'mail2kazakhstan.com', 'mail2keen.com', 'mail2keith.com', 'mail2kelly.com', 'mail2kelsey.com', 'mail2ken.com', 'mail2kendall.com', 'mail2kennedy.com', 'mail2kenneth.com', 'mail2kenny.com', 'mail2kentucky.com', 'mail2kenya.com', 'mail2kerry.com', 'mail2kevin.com', 'mail2kim.com', 'mail2kimberly.com', 'mail2king.com', 'mail2kirk.com', 'mail2kiss.com', 'mail2kosher.com', 'mail2kristin.com', 'mail2kurt.com', 'mail2kuwait.com', 'mail2kyle.com', 'mail2kyrgyzstan.com', 'mail2la.com', 'mail2lacrosse.com', 'mail2lance.com', 'mail2lao.com', 'mail2larry.com', 'mail2latvia.com', 'mail2laugh.com', 'mail2laura.com', 'mail2lauren.com', 'mail2laurie.com', 'mail2lawrence.com', 'mail2lawyer.com', 'mail2lebanon.com', 'mail2lee.com', 'mail2leo.com', 'mail2leon.com', 'mail2leonard.com', 'mail2leone.com', 'mail2leslie.com', 'mail2letter.com', 'mail2liberia.com', 'mail2libertarian.com', 'mail2libra.com', 'mail2libya.com', 'mail2liechtenstein.com', 'mail2life.com', 'mail2linda.com', 'mail2linux.com', 'mail2lionel.com', 'mail2lipstick.com', 'mail2liquid.com', 'mail2lisa.com', 'mail2lithuania.com', 'mail2litigator.com', 'mail2liz.com', 'mail2lloyd.com', 'mail2lois.com', 'mail2lola.com', 'mail2london.com', 'mail2looking.com', 'mail2lori.com', 'mail2lost.com', 'mail2lou.com', 'mail2louis.com', 'mail2louisiana.com', 'mail2lovable.com', 'mail2love.com', 'mail2lucky.com', 'mail2lucy.com', 'mail2lunch.com', 'mail2lust.com', 'mail2luxembourg.com', 'mail2luxury.com', 'mail2lyle.com', 'mail2lynn.com', 'mail2madagascar.com', 'mail2madison.com', 'mail2madrid.com', 'mail2maggie.com', 'mail2mail4.com', 'mail2maine.com', 'mail2malawi.com', 'mail2malaysia.com', 'mail2maldives.com', 'mail2mali.com', 'mail2malta.com', 'mail2mambo.com', 'mail2man.com', 'mail2mandy.com', 'mail2manhunter.com', 'mail2mankind.com', 'mail2many.com', 'mail2marc.com', 'mail2marcia.com', 'mail2margaret.com', 'mail2margie.com', 'mail2marhaba.com', 'mail2maria.com', 'mail2marilyn.com', 'mail2marines.com', 'mail2mark.com', 'mail2marriage.com', 'mail2married.com', 'mail2marries.com', 'mail2mars.com', 'mail2marsha.com', 'mail2marshallislands.com', 'mail2martha.com', 'mail2martin.com', 'mail2marty.com', 'mail2marvin.com', 'mail2mary.com', 'mail2maryland.com', 'mail2mason.com', 'mail2massachusetts.com', 'mail2matt.com', 'mail2matthew.com', 'mail2maurice.com', 'mail2mauritania.com', 'mail2mauritius.com', 'mail2max.com', 'mail2maxwell.com', 'mail2maybe.com', 'mail2mba.com', 'mail2me4u.com', 'mail2mechanic.com', 'mail2medieval.com', 'mail2megan.com', 'mail2mel.com', 'mail2melanie.com', 'mail2melissa.com', 'mail2melody.com', 'mail2member.com', 'mail2memphis.com', 'mail2methodist.com', 'mail2mexican.com', 'mail2mexico.com', 'mail2mgz.com', 'mail2miami.com', 'mail2michael.com', 'mail2michelle.com', 'mail2michigan.com', 'mail2mike.com', 'mail2milan.com', 'mail2milano.com', 'mail2mildred.com', 'mail2milkyway.com', 'mail2millennium.com', 'mail2millionaire.com', 'mail2milton.com', 'mail2mime.com', 'mail2mindreader.com', 'mail2mini.com', 'mail2minister.com', 'mail2minneapolis.com', 'mail2minnesota.com', 'mail2miracle.com', 'mail2missionary.com', 'mail2mississippi.com', 'mail2missouri.com', 'mail2mitch.com', 'mail2model.com', 'mail2mom.com', 'mail2monaco.com', 'mail2money.com', 'mail2mongolia.com', 'mail2monica.com', 'mail2montana.com', 'mail2monty.com', 'mail2moon.com', 'mail2morocco.com', 'mail2morpheus.com', 'mail2mors.com', 'mail2moscow.com', 'mail2moslem.com', 'mail2mouseketeer.com', 'mail2movies.com', 'mail2mozambique.com', 'mail2mp3.com', 'mail2mrright.com', 'mail2msright.com', 'mail2museum.com', 'mail2music.com', 'mail2musician.com', 'mail2muslim.com', 'mail2my.com', 'mail2myboat.com', 'mail2mycar.com', 'mail2mycell.com', 'mail2mygsm.com', 'mail2mylaptop.com', 'mail2mymac.com', 'mail2mypager.com', 'mail2mypalm.com', 'mail2mypc.com', 'mail2myphone.com', 'mail2myplane.com', 'mail2namibia.com', 'mail2nancy.com', 'mail2nasdaq.com', 'mail2nathan.com', 'mail2nauru.com', 'mail2navy.com', 'mail2neal.com', 'mail2nebraska.com', 'mail2ned.com', 'mail2neil.com', 'mail2nelson.com', 'mail2nemesis.com', 'mail2nepal.com', 'mail2netherlands.com', 'mail2network.com', 'mail2nevada.com', 'mail2newhampshire.com', 'mail2newjersey.com', 'mail2newmexico.com', 'mail2newyork.com', 'mail2newzealand.com', 'mail2nicaragua.com', 'mail2nick.com', 'mail2nicole.com', 'mail2niger.com', 'mail2nigeria.com', 'mail2nike.com', 'mail2no.com', 'mail2noah.com', 'mail2noel.com', 'mail2noelle.com', 'mail2normal.com', 'mail2norman.com', 'mail2northamerica.com', 'mail2northcarolina.com', 'mail2northdakota.com', 'mail2northpole.com', 'mail2norway.com', 'mail2notus.com', 'mail2noway.com', 'mail2nowhere.com', 'mail2nuclear.com', 'mail2nun.com', 'mail2ny.com', 'mail2oasis.com', 'mail2ohio.com', 'mail2ok.com', 'mail2oklahoma.com', 'mail2oliver.com', 'mail2oman.com', 'mail2one.com', 'mail2onfire.com', 'mail2online.com', 'mail2oops.com', 'mail2open.com', 'mail2ophthalmologist.com', 'mail2optometrist.com', 'mail2oregon.com', 'mail2oscars.com', 'mail2oslo.com', 'mail2painter.com', 'mail2pakistan.com', 'mail2pan.com', 'mail2panama.com', 'mail2paraguay.com', 'mail2paralegal.com', 'mail2paris.com', 'mail2park.com', 'mail2parker.com', 'mail2party.com', 'mail2passion.com', 'mail2pat.com', 'mail2patricia.com', 'mail2patrick.com', 'mail2patty.com', 'mail2paul.com', 'mail2paula.com', 'mail2pay.com', 'mail2peace.com', 'mail2pediatrician.com', 'mail2peggy.com', 'mail2pennsylvania.com', 'mail2perry.com', 'mail2persephone.com', 'mail2persian.com', 'mail2peru.com', 'mail2pete.com', 'mail2peter.com', 'mail2pharmacist.com', 'mail2phil.com', 'mail2philippines.com', 'mail2phoenix.com', 'mail2phonecall.com', 'mail2phyllis.com', 'mail2pickup.com', 'mail2pilot.com', 'mail2pisces.com', 'mail2planet.com', 'mail2platinum.com', 'mail2plato.com', 'mail2pluto.com', 'mail2pm.com', 'mail2podiatrist.com', 'mail2poet.com', 'mail2poland.com', 'mail2policeman.com', 'mail2policewoman.com', 'mail2politician.com', 'mail2pop.com', 'mail2pope.com', 'mail2popular.com', 'mail2portugal.com', 'mail2poseidon.com', 'mail2potatohead.com', 'mail2power.com', 'mail2presbyterian.com', 'mail2president.com', 'mail2priest.com', 'mail2prince.com', 'mail2princess.com', 'mail2producer.com', 'mail2professor.com', 'mail2protect.com', 'mail2psychiatrist.com', 'mail2psycho.com', 'mail2psychologist.com', 'mail2qatar.com', 'mail2queen.com', 'mail2rabbi.com', 'mail2race.com', 'mail2racer.com', 'mail2rachel.com', 'mail2rage.com', 'mail2rainmaker.com', 'mail2ralph.com', 'mail2randy.com', 'mail2rap.com', 'mail2rare.com', 'mail2rave.com', 'mail2ray.com', 'mail2raymond.com', 'mail2realtor.com', 'mail2rebecca.com', 'mail2recruiter.com', 'mail2recycle.com', 'mail2redhead.com', 'mail2reed.com', 'mail2reggie.com', 'mail2register.com', 'mail2rent.com', 'mail2republican.com', 'mail2resort.com', 'mail2rex.com', 'mail2rhodeisland.com', 'mail2rich.com', 'mail2richard.com', 'mail2ricky.com', 'mail2ride.com', 'mail2riley.com', 'mail2rita.com', 'mail2rob.com', 'mail2robert.com', 'mail2roberta.com', 'mail2robin.com', 'mail2rock.com', 'mail2rocker.com', 'mail2rod.com', 'mail2rodney.com', 'mail2romania.com', 'mail2rome.com', 'mail2ron.com', 'mail2ronald.com', 'mail2ronnie.com', 'mail2rose.com', 'mail2rosie.com', 'mail2roy.com', 'mail2rudy.com', 'mail2rugby.com', 'mail2runner.com', 'mail2russell.com', 'mail2russia.com', 'mail2russian.com', 'mail2rusty.com', 'mail2ruth.com', 'mail2rwanda.com', 'mail2ryan.com', 'mail2sa.com', 'mail2sabrina.com', 'mail2safe.com', 'mail2sagittarius.com', 'mail2sail.com', 'mail2sailor.com', 'mail2sal.com', 'mail2salaam.com', 'mail2sam.com', 'mail2samantha.com', 'mail2samoa.com', 'mail2samurai.com', 'mail2sandra.com', 'mail2sandy.com', 'mail2sanfrancisco.com', 'mail2sanmarino.com', 'mail2santa.com', 'mail2sara.com', 'mail2sarah.com', 'mail2sat.com', 'mail2saturn.com', 'mail2saudi.com', 'mail2saudiarabia.com', 'mail2save.com', 'mail2savings.com', 'mail2school.com', 'mail2scientist.com', 'mail2scorpio.com', 'mail2scott.com', 'mail2sean.com', 'mail2search.com', 'mail2seattle.com', 'mail2secretagent.com', 'mail2senate.com', 'mail2senegal.com', 'mail2sensual.com', 'mail2seth.com', 'mail2sevenseas.com', 'mail2sexy.com', 'mail2seychelles.com', 'mail2shane.com', 'mail2sharon.com', 'mail2shawn.com', 'mail2ship.com', 'mail2shirley.com', 'mail2shoot.com', 'mail2shuttle.com', 'mail2sierraleone.com', 'mail2simon.com', 'mail2singapore.com', 'mail2single.com', 'mail2site.com', 'mail2skater.com', 'mail2skier.com', 'mail2sky.com', 'mail2sleek.com', 'mail2slim.com', 'mail2slovakia.com', 'mail2slovenia.com', 'mail2smile.com', 'mail2smith.com', 'mail2smooth.com', 'mail2soccer.com', 'mail2soccerfan.com', 'mail2socialist.com', 'mail2soldier.com', 'mail2somalia.com', 'mail2son.com', 'mail2song.com', 'mail2sos.com', 'mail2sound.com', 'mail2southafrica.com', 'mail2southamerica.com', 'mail2southcarolina.com', 'mail2southdakota.com', 'mail2southkorea.com', 'mail2southpole.com', 'mail2spain.com', 'mail2spanish.com', 'mail2spare.com', 'mail2spectrum.com', 'mail2splash.com', 'mail2sponsor.com', 'mail2sports.com', 'mail2srilanka.com', 'mail2stacy.com', 'mail2stan.com', 'mail2stanley.com', 'mail2star.com', 'mail2state.com', 'mail2stephanie.com', 'mail2steve.com', 'mail2steven.com', 'mail2stewart.com', 'mail2stlouis.com', 'mail2stock.com', 'mail2stockholm.com', 'mail2stockmarket.com', 'mail2storage.com', 'mail2store.com', 'mail2strong.com', 'mail2student.com', 'mail2studio.com', 'mail2studio54.com', 'mail2stuntman.com', 'mail2subscribe.com', 'mail2sudan.com', 'mail2superstar.com', 'mail2surfer.com', 'mail2suriname.com', 'mail2susan.com', 'mail2suzie.com', 'mail2swaziland.com', 'mail2sweden.com', 'mail2sweetheart.com', 'mail2swim.com', 'mail2swimmer.com', 'mail2swiss.com', 'mail2switzerland.com', 'mail2sydney.com', 'mail2sylvia.com', 'mail2syria.com', 'mail2taboo.com', 'mail2taiwan.com', 'mail2tajikistan.com', 'mail2tammy.com', 'mail2tango.com', 'mail2tanya.com', 'mail2tanzania.com', 'mail2tara.com', 'mail2taurus.com', 'mail2taxi.com', 'mail2taxidermist.com', 'mail2taylor.com', 'mail2taz.com', 'mail2teacher.com', 'mail2technician.com', 'mail2ted.com', 'mail2telephone.com', 'mail2tenderness.com', 'mail2tennessee.com', 'mail2tennis.com', 'mail2tennisfan.com', 'mail2terri.com', 'mail2terry.com', 'mail2test.com', 'mail2texas.com', 'mail2thailand.com', 'mail2therapy.com', 'mail2think.com', 'mail2tickets.com', 'mail2tiffany.com', 'mail2tim.com', 'mail2time.com', 'mail2timothy.com', 'mail2tina.com', 'mail2titanic.com', 'mail2toby.com', 'mail2todd.com', 'mail2togo.com', 'mail2tom.com', 'mail2tommy.com', 'mail2tonga.com', 'mail2tony.com', 'mail2touch.com', 'mail2tourist.com', 'mail2tracey.com', 'mail2tracy.com', 'mail2tramp.com', 'mail2travel.com', 'mail2traveler.com', 'mail2travis.com', 'mail2trekkie.com', 'mail2trex.com', 'mail2triallawyer.com', 'mail2trick.com', 'mail2trillionaire.com', 'mail2troy.com', 'mail2truck.com', 'mail2trump.com', 'mail2try.com', 'mail2tunisia.com', 'mail2turbo.com', 'mail2turkey.com', 'mail2turkmenistan.com', 'mail2tv.com', 'mail2tycoon.com', 'mail2tyler.com', 'mail2u4me.com', 'mail2uae.com', 'mail2uganda.com', 'mail2uk.com', 'mail2ukraine.com', 'mail2uncle.com', 'mail2unsubscribe.com', 'mail2uptown.com', 'mail2uruguay.com', 'mail2usa.com', 'mail2utah.com', 'mail2uzbekistan.com', 'mail2v.com', 'mail2vacation.com', 'mail2valentines.com', 'mail2valerie.com', 'mail2valley.com', 'mail2vamoose.com', 'mail2vanessa.com', 'mail2vanuatu.com', 'mail2venezuela.com', 'mail2venous.com', 'mail2venus.com', 'mail2vermont.com', 'mail2vickie.com', 'mail2victor.com', 'mail2victoria.com', 'mail2vienna.com', 'mail2vietnam.com', 'mail2vince.com', 'mail2virginia.com', 'mail2virgo.com', 'mail2visionary.com', 'mail2vodka.com', 'mail2volleyball.com', 'mail2waiter.com', 'mail2wallstreet.com', 'mail2wally.com', 'mail2walter.com', 'mail2warren.com', 'mail2washington.com', 'mail2wave.com', 'mail2way.com', 'mail2waycool.com', 'mail2wayne.com', 'mail2web.com', 'mail2webmaster.com', 'mail2webtop.com', 'mail2webtv.com', 'mail2weird.com', 'mail2wendell.com', 'mail2wendy.com', 'mail2westend.com', 'mail2westvirginia.com', 'mail2whether.com', 'mail2whip.com', 'mail2white.com', 'mail2whitehouse.com', 'mail2whitney.com', 'mail2why.com', 'mail2wilbur.com', 'mail2wild.com', 'mail2willard.com', 'mail2willie.com', 'mail2wine.com', 'mail2winner.com', 'mail2wired.com', 'mail2wisconsin.com', 'mail2woman.com', 'mail2wonder.com', 'mail2world.com', 'mail2worship.com', 'mail2wow.com', 'mail2www.com', 'mail2wyoming.com', 'mail2xfiles.com', 'mail2xox.com', 'mail2yachtclub.com', 'mail2yahalla.com', 'mail2yemen.com', 'mail2yes.com', 'mail2yugoslavia.com', 'mail2zack.com', 'mail2zambia.com', 'mail2zenith.com', 'mail2zephir.com', 'mail2zeus.com', 'mail2zipper.com', 'mail2zoo.com', 'mail2zoologist.com', 'mail2zurich.com', 'mailandftp.com', 'mailas.com', 'mailbolt.com', 'mailc.net', 'mailcan.com', 'mail-central.com', 'mailcity.com', 'mailexcite.com', 'mailforce.net', 'mailftp.com', 'mailhaven.com', 'mailingaddress.org', 'mailite.com', 'mailmight.com', 'mailnew.com', 'mail-page.com', 'mailsent.net', 'mailservice.ms', 'mailup.net', 'mailworks.org', 'me.com', 'mindspring.com', 'ml1.net', 'mm.st', 'msn.com', 'msnhotmail.com', 'munich.com', 'mweb.co.za', 'my.att.net', 'myfastmail.com', 'mymacmail.com', 'naver.com', 'netaddress.com', 'netscape.aol.com', 'netscape.com', 'netscape.net', 'netzero.com', 'netzero.net', 'newmail.ru', 'nicholastse.net', 'nicolastse.com', 'nm.ru', 'no.yahoo.com', 'nomorespamemails.com', 'norikomail.com', 'norwaymail.com', 'no-spam.ws', 'nospammail.net', 'notmailinator.com', 'nowmymail.com', 'ntlworld.com', 'nycap.rr.com', 'nz.yahoo.com', 'oath.com', 'omanmail.com', 'one.net.au', 'onebox.com', 'onet.eu', 'onet.pl', 'online.no', 'online.ru', 'op.pl', 'operamail.com', 'optimum.net', 'optonline.net', 'optusnet.com.au', 'optuszoo.com.au', 'orange.es', 'otakumail.com', 'ownmail.net', 'ozemail.com.au', 'pacific.net.sg', 'palestinemail.com', 'pandora.be', 'pcconnect.co.nz', 'personal.ro', 'petml.com', 'pisem.net', 'plusmail.com.br', 'poczta.fm', 'poczta.onet.eu', 'poczta.onet.pl', 'popstar.com', 'portugalmail.com', 'portugalmail.pt', 'postinbox.com', 'postino.ch', 'postpro.net', 'proinbox.com', 'promessage.com', 'ptd.net', 'qprfans.com', 'quickinbox.com', 'quik.co.nz', 'qwest.com', 'qwest.net', 'rambler.ru', 'ranmamail.com', 'rcn.com', 'realemail.net', 'reallyfast.biz', 'reallyfast.info', 'rediff.com', 'rediffmail.com', 'rochester.rr.com', 'rocketmail.com', 'rol.ru', 'rushpost.com', 'safe-mail.net', 'safetymail.info', 'safetypost.de', 'sammimail.com', 'satyam.net.in', 'saudia.com', 'se.yahoo.com', 'sent.as', 'sent.at', 'sent.com', 'serwus.pl', 'sesmail.com', 'shaw.ca', 'shitmail.me', 'shootmail.com', 'sify.com', 'sina.com', 'singnet.com.sg', 's-mail.com', 'sneakemail.com', 'sofort-mail.de', 'softhome.net', 'spam.lv', 'spam.su', 'spambog.com', 'spambog.de', 'spambog.ru', 'speedpost.net', 'speedymail.org', 'sprintmail.com', 'ssl-mail.com', 'stribmail.com', 'sunumail.sn', 'super.net.pk', 'supergreatmail.com', 'suremail.info', 'surimail.com', 'swift-mail.com', 'swissmail.net', 'sympatico.ca', 'syriamail.com', 'takas.lt', 'talk21.com', 'tampabay.rr.com', 'techemail.com', 'telecom.one.net.au', 'telepolis.com', 'telkom.net', 'telus.net', 'telusplanet.net', 'tempemail.net', 'tempinbox.com', 'temporarioemail.com.br', 'terra.cl', 'terra.com', 'terra.com.ar', 'terra.com.br', 'terra.es', 'the-fastest.net', 'theinternetemail.com', 'the-quickest.com', 'tin.it', 'tiscalinet.it', 'tmailinator.com', 't-online.de', 'tradermail.info', 'trashmail.ws', 'tudominio.com', 'tudominio.es', 'tudominio.org', 'tut.by', 'tw.yahoo.com', 'twcny.rr.com', 'uk2k.com', 'uk7.net', 'uk8.net', 'ukr.net', 'ukrpost.net', 'uol.com.br', 'usa.net', 'uswest.net', 'uymail.com', 'vahoo.com', 'verizon.net', 'veryfast.biz', 'veryrealemail.com', 'veryspeedy.net', 'videotron.ca', 'vip.interia.pl', 'vipmail.ru', 'virgilio.it', 'virgin.net', 'vodafone.co.nz', 'volcanomail.com', 'voyager.net', 'vp.pl', 'vsnl.com', 'wanadoo.es', 'warpmail.net', 'wave.co.nz', 'web.de', 'web20.a.ua', 'webmail.co.za', 'webmail.ntlworld.com', 'webmails.com', 'websurfer.co.za', 'whipmail.com', 'windowslive.com', 'windstream.net', 'worldnet.att.net', 'xsmail.com', 'xtra.co.nz', 'yahoo.at', 'yahoo.ba', 'yahoo.ca', 'yahoo.cn', 'yahoo.co.in', 'yahoo.co.jp', 'yahoo.co.kr', 'yahoo.co.nz', 'yahoo.co.th', 'yahoo.co.uk', 'yahoo.com', 'yahoo.com.ar', 'yahoo.com.au', 'yahoo.com.br', 'yahoo.com.cn', 'yahoo.com.es', 'yahoo.com.hk', 'yahoo.com.kr', 'yahoo.com.mx', 'yahoo.com.my', 'yahoo.com.ph', 'yahoo.com.ru', 'yahoo.com.sg', 'yahoo.com.tw', 'yahoo.de', 'yahoo.dk', 'yahoo.es', 'yahoo.fr', 'yahoo.gr', 'yahoo.ie', 'yahoo.in', 'yahoo.it', 'yahoo.jp', 'yahoo.kr', 'yahoo.ru', 'yahoo.se', 'yahoomail.com', 'yandex.ru', 'yeah.net', 'yemenmail.com', 'yepmail.net', 'ymail.com', 'yopmail.com', 'yougotemail.com', 'your-mail.com', 'yyhmail.com', 'zapak.com', 'zdnet.co.uk', 'zdnet.com', 'zdnetonebox.com', 'zebra.lt', 'zeenext.com', 'zehnminutenmail.de', 'zipmail.com.br', 'zippymail.info', 'zita.be', 'zmail.ru', 'znajomi.pl'];

    var blacklistedDomains = ['24timezones.com', '2findlocal.com', '360cities.net', '4-city-information.com', '800wesleys.com', 'a2zgorge.info', 'aaroads.com', 'aboutgreenwoodms.com', 'acadiamagic.com', 'accessesmeralda.com', 'activerain.com', 'adoptapet.com', 'agency.governmentjobs.com', 'aircriticalcare.com', 'airnav.com', 'alabama.hometownlocator.com', 'alibris.com', 'allhomesforsalejacksonvillenc.com', 'all-oregon.com', 'amazon.com', 'americantowns.com', 'amlegal.com', 'angelfire.com', 'answers.yahoo.com', 'apartmentfinder.com', 'apartmenthomeliving.com', 'apartmentratings.com', 'apartments.com', 'apartments-in-ri.com', 'archiplanet.org', 'architecturefirmswilmington.com', 'archive.org', 'area-codes.com', 'areavibes.com', 'arkansas.hometownlocator.com', 'ashevilleguidebook.com', 'auburnalabama.org', 'autos.aol.com', 'autos.yahoo.com', 'b2byellowpages.com', 'barharborinfo.com', 'barharbormagic.com', 'barrington.patch.com', 'baysidecottagerentals.com', 'bedandbreakfast.com', 'beenverified.com', 'bendoregonrealestate.com', 'besthomepro.com', 'bestparttimejob.net', 'bestplaces.net', 'bestrhodeislandweddings.com', 'biddefordmillsmuseum.org', 'bizfinder.registerguard.com', 'bloglines.com', 'bloomberg.com', 'bnbstar.com', 'boatinfoworld.com', 'booking.com', 'books.google.com', 'boston.backpage.com', 'brokencc.com', 'browsevegashomes.com', 'budgetvision.com', 'bulkyitems.cityofws.org', 'business.intuit.com', 'businessfinder.gulflive.com', 'businessfinder.oregonlive.com', 'california.hometownlocator.com', 'camdenmainevacation.com', 'cardcow.com', 'cardetailingwilmingtonnc.com', 'caring.com', 'caselaw.findlaw.com', 'cemeteries.cityofws.org', 'cemeterycensus.com', 'censusviewer.com', 'century21.com', 'chacha.com', 'chamberofcommerce.com', 'chamberorganizer.com', 'cheapflights.com', 'childcarecenter.us', 'chilis.com', 'chrisedwardsgroup.com', 'churchangel.com', 'citiesandvillages.com', 'citizensbank.com', 'city.statelawyers.com', 'citylatitudelongitude.com', 'citymelt.com', 'cityofchicago.org', 'citypictures.info', 'cityprofile.com', 'citysquares.com', 'citytowninfo.com', 'city-usa.net', 'clevelandmschamber.com', 'climate.fizber.com', 'clrsearch.com', 'cmdrmark.com', 'coastaloregon.worldweb.com', 'codeapollo.com', 'codepublishing.com', 'columbiariverimages.com', 'community.lawyers.com', 'companies.findthecompany.com', 'countryhomesofmississippi.com', 'countryhomesofnevada.com', 'countryhomesofnorthcarolina.com', 'countryhomesoforegon.com', 'countryhomesofrhodeisland.com', 'cranstonpolice.com', 'crcpropertyinfo.com', 'creditunionsonline.com', 'crossroadscars.com', 'crossroadsfordsanford.com', 'crossroadskc.com', 'crossroadsokc.com', 'cubitplanning.com', 'dailymail.co.uk', 'data.visionappraisal.com', 'deedrecords.com', 'development.cityofws.org', 'dexknows.com', 'dictionary.reference.com', 'digital.library.unlv.edu', 'distancebetweencities.net', 'distancecalculator.globefeed.com', 'distance-cities.com', 'distancescalculator.com', 'districts.teachade.com', 'docstoc.com', 'doctor.webmd.com', 'doctorhelps.com', 'dominos.com', 'doostang.com', 'dover-foxcroft.org', 'downeast.com', 'dumpstersofamerica.com', 'eachtown.com', 'earthcam.com', 'easternoregon.worldweb.com', 'easystreetrealty-charlotte.com', 'easystreetrealty-raleighdurham.com', 'easystreetrealty-vegas.com', 'ebay.com', 'echo-oregon.com', 'ecode360.com', 'ediblearrangements.com', 'education.jobs-in-oregon.com', 'ehealthscores.com', 'ehow.com', 'elkorose.schopine.com', 'elocalexterminators.com', 'en.db-city.com', 'en.wikipedia.org', 'epodunk.com', 'estately.com', 'everytrail.com', 'examiner.com', 'expedia.com', 'exploreforums.com', 'exploringnevada.com', 'facebook.com', 'factbites.com', 'factsanswer.com', 'faqs.org', 'faremeasure.com', 'farmfresh.org', 'find.hamptonroads.com', 'findagrave.com', 'findamuralist.com', 'finddataentryjobs.com', 'finddogtrainers.com', 'finditonline.com', 'findlocalweather.com', 'findmeglutenfree.com', 'findnotary.com', 'findnursingjobs.net', 'findretailjobs.net', 'firedepartmentdirectory.com', 'firedepartments.net', 'firehouse.com', 'firenews.net', 'fivebelow.com', 'fizber.com', 'flights.expedia.com', 'flipkey.com', 'florist-flowers-roses-delivery.com', 'flowerdeliveryexpress.com', 'forgottennevada.org', 'forlocations.com', 'forms.cityofws.org', 'forrent.com', 'fortwiki.com', 'forums.ghosttowns.com', 'freebase.com', 'freedomspeaks.com', 'freedownloadb.com', 'freenevadamove.com', 'friendlyforecast.com', 'friendsofcolonialpemaquid.org', 'frontdoor.com', 'fuelmeup.com', 'funeral-homes.net', 'gasprices.mapquest.com', 'genforum.genealogy.com', 'geody.com', 'geology.com', 'georgia.hometownlocator.com', 'gesswhoto.com', 'getinsurancejobs.net', 'getlegaljobs.net', 'getofficejobs.net', 'getphysicians.net', 'getrestaurantjobs.net', 'gettruckerjobs.com', 'ghosttownexplorers.org', 'ghosttowngallery.com', 'ghosttowns.com', 'glassdoor.com', 'globalindex.com', 'gluedideas.com', 'go.hubbiz.com', 'goby.com', 'golflink.com', 'gomonroe.org', 'government.jobs-in-oregon.com', 'govlisted.com', 'govsites.org', 'great-maine-vacations.com', 'greatnonprofits.org', 'greatschools.org', 'greensboroareahomes.com', 'groupon.com', 'happyzebra.com', 'healthgrades.com', 'healthtrax.com', 'heraldnews.com', 'hikercentral.com', 'historic-structures.com', 'history.nevadanorthernrailway.net', 'history.rays-place.com', 'homefinder.com', 'homegain.com', 'homehealthcarewilsonnc.com', 'homeinsurancewilson.com', 'homelessshelterdirectory.org', 'homes.com', 'homes.org', 'homesforsaleinjacksonville-nc.com', 'hometownlocator.com', 'hometownusa.com', 'hookandbullet.com', 'hopstop.com', 'hotel.net', 'hotelguides.com', 'hotelplanner.com', 'hotels.com', 'hotfrog.com', 'hotpads.com', 'hotspringsenthusiast.com', 'hoursmap.com', 'houseofnames.com', 'housesforsalelists.com', 'houstonculture.org', 'idaho.hometownlocator.com', 'ilawconnect.com', 'imdb.com', 'imortuary.com', 'indeed.com', 'indexpost.com', 'infomi.com', 'infomine.com', 'info-nc.com', 'insiderpages.com', 'insuranceproviders.com', 'intelius.com', 'itouchmap.com', 'jobcircle.com', 'jobdango.com', 'jobinventory.com', 'jobs.aol.com', 'jobs.monster.com', 'jobs2careers.com', 'jobsinme.com', 'jobswithcities.com', 'junk-car.org', 'justclicklocal.com', 'keepmecurrent.com', 'knmap.com', 'kvcog.org', 'lakesofmaine.org', 'landsat.com', 'landsoforegon.com', 'landwatch.com', 'lasr.net', 'lat-long.com', 'lawcrossing.com', 'lawyers.com', 'lawyersbystate.net', 'learnnc.org', 'legendsofamerica.com', 'lifescript.com', 'linkedin.com', 'livingnewdeal.berkeley.edu', 'livingplaces.com', 'local.answers.com', 'local.commercialappeal.com', 'local.dailyadvance.com', 'local.mapquest.com', 'local.post-gazette.com', 'local.stltoday.com', 'local.triangle411.com', 'local.yahoo.com', 'localbusiness.dailycomet.com', 'localbusiness.ocala.com', 'localbusiness.the-dispatch.com', 'localcrimenews.com', 'localdirectory.wdam.com', 'localdirectory.wect.com', 'localdirectory.wlbt.com', 'localdirectory.wlox.com', 'localdirectory.wmctv.com', 'localism.com', 'localrestaurant411.com', 'localschooldirectory.com', 'localscout.com', 'localsearch.dailytarheel.com', 'local-worship.com', 'locategrave.org', 'loopnet.com', 'lovemyzip.com', 'magicyellow.com', 'maine.hometownlocator.com', 'maine.info', 'maineanencyclopedia.com', 'mainecoastproperties.biz', 'mainegenealogy.net', 'maineguide.com', 'mainememory.net', 'mainetrailfinder.com', 'mainevacation.com', 'mainevacations.net', 'maine-white-pages.com', 'mainstreetmaps.com', 'manta.com', 'mapcarta.com', 'mappery.com', 'mapquest.com', 'maps.cityofreno.net', 'maps-n-stats.com', 'mapsofworld.com', 'maptechnica.com', 'marinas.com', 'massachusetts.hometownlocator.com', 'me.postcodebase.com', 'medicinenet.com', 'memorialflorists.com', 'merchantcircle.com', 'metrolyrics.com', 'michigan.org', 'milebymile.com', 'mines.findthedata.org', 'miningartifacts.org', 'minnesota.hometownlocator.com', 'mississippi.hometownlocator.com', 'mississippi-landsource.com', 'mississippi-phone-book.com', 'moapavalley.travelnevada.com', 'moreheadcitymove.com', 'moreheadcityrestaurants.com', 'mountainproject.com', 'move.com', 'movingideas.org', 'movingtruck.com', 'movoto.com', 'mrwhatis.com', 'mscgr.homestead.com', 'ms-directory.hometownlocator.com', 'msgw.org', 'mslifeteam.com', 'museums.nevadaculture.org', 'music.yahoo.com', 'mycprcertificationonline.com', 'mylife.com', 'mynewplace.com', 'myspace.com', 'myyp.com', 'names.whitepages.com', 'namesandnumbers.com', 'narragansett.patch.com', 'national.citysearch.com', 'nationaljobs.washingtonpost.com', 'nationsonline.org', 'nchistoricsites.org', 'neighborcity.com', 'neighborhoodlink.com', 'neighborhoods.homeseekers.com', 'neighborhoodscout.com', 'nevada.firedepartments.net', 'nevada.hometownlocator.com', 'nevadacounty4sale.com', 'nevadadot.com', 'nevadanewsbureau.com', 'nevadanuggethunters.myfreeforum.org', 'nevadaobserver.com', 'nevada-outback-gems.com', 'nevadatravel.net', 'nevadaweb.com', 'newbernhomeguide.com', 'newcastlemaine.us', 'newenglandmoves.com', 'newenglandsite.com', 'newhomes.move.com', 'newportrischools.org', 'news.hometownusa.com', 'newsbytown.com', 'new-york.educationbug.org', 'newyork.hometownlocator.com', 'nklibrary.org', 'nonprofitfacts.com', 'northcarolina.hometownlocator.com', 'north-carolina.schooltree.org', 'northcarolinacountymaps.com', 'northcarolina-genealogy.com', 'northcarolina-realestate.com', 'northcarolinavacation.com', 'northcoastmaine.worldweb.com', 'nsla.nevadaculture.org', 'nv.postcodebase.com', 'nvghosttowns.topcities.com', 'nvmasons.org', 'nwrealty.com', 'offendex.com', 'offerrunway.com', 'ohwy.com', 'onlineimpactpanel.com', 'onlinenevada.org', 'ontheradio.net', 'oocities.org', 'openhouses.com', 'open-public-records.com', 'oregon.hometownlocator.com', 'oregonbeachvacations.com', 'oregoncities.us', 'oregongenealogy.com', 'oregonhotsprings.immunenet.com', 'oregontravels.com', 'orinfrastructure.org', 'orthopages.com', 'ourparents.com', 'owners.com', 'paddling.net', 'panoramio.com', 'papajohns.com', 'paybill.com', 'pdflike.com', 'pennsylvania.hometownlocator.com', 'peoplefinders.com', 'people--search.org', 'peopleshistory.org', 'petfinder.com', 'pinegrovetreatment.com', 'pizzahut.com', 'placenames.com', 'pointfacts.com', 'police-records.us', 'portlandme.citysearch.com', 'portsmouthri.com', 'postal-code.org', 'powerprofiles.com', 'pressherald.com', 'priceline.com', 'prlog.org', 'propertiesunltd.com', 'propertycrunch.com', 'providencerealestatehomes.com', 'publiclibraries.com', 'publicnotices.portlandtribune.com', 'publicrecordcenter.com', 'publicrecords.com', 'publicrecords.onlinesearches.com', 'public-school-districts.findthedata.org', 'publicschoolreview.com', 'public-schools.findthebest.com', 'questdiagnostics.com', 'quoddyloop.com', 'qwikcast.com', 'radiationthreats.org', 'radio-locator.com', 'radioshack.com', 'raleighrealestatehomes.com', 'ratemyprofessors.com', 'rchurch.com', 'rci-nv.com', 'realestate.aol.com', 'realestate.findportlandoregonhomes.com', 'realestate.gulflive.com', 'realestate.oregonlive.com', 'real-estate-cary.com', 'realtor.com', 'realtyexperts.us', 'recordspedia.com', 'recreationparks.net', 'remax.com', 'reno-laketahoe.worldweb.com', 'renovateyourworld.com', 'rent.com', 'rentals.com', 'residentialproperties.com', 'retail.jobs-in-oregon.com', 'retrove.com', 'rhodeisland.firedepartments.net', 'rhodeisland.hometownlocator.com', 'ricemeteries.tripod.com', 'ricentral.com', 'rihousehunt.com', 'ripleysghosttowns.com', 'roadsideamerica.com', 'roadsidethoughts.com', 'rockymountainprofiles.com', 'rootsweb.ancestry.com', 'rvparkreviews.com', 'salarylist.com', 'satelliteviews.net', 'sawbuck.com', 'schoolbug.org', 'schools.fizber.com', 'schools.publicschoolsreport.com', 'seacoast.com', 'seagrant.gso.uri.edu', 'search.natchezdemocrat.com', 'sebec.lakesonline.com', 'section-8-housing.findthebest.com', 'security4homes.com', 'seeraleighhomes.com', 'seeyprofile.com', 'seniorhousingnet.com', 'serviceslisted.com', 'shortdrives.com', 'silverstateghosttowns.com', 'sites.google.com', 'skyways.org', 'snagajob.com', 'southcarolina.hometownlocator.com', 'southcoastmaine.worldweb.com', 'southnevada.worldweb.com', 'spoke.com', 'spokeo.com', 'sportsbars.com', 'staples.com', 'starbucks.com', 'starkvilledailynews.com', 'statelawyers.com', 'statelocalgov.net', 'stateparks.com', 'stayandplayinthesmokies.com', 'summitpost.org', 'sunsetcities.com', 'superpages.com', 'surnames.meaning-of-names.com', 'switchboard.com', 'taxexemptworld.com', 'terravistarealty.com', 'texas.hometownlocator.com', 'texasroadhouse.com', 'thedirectory.org', 'thefreedictionary.com', 'thegolfnexus.com', 'thepublicrecords.com', 'therapists.psychologytoday.com', 'therealplaces.com', 'therockerbox.com', 'theus50.com', 'the-webcam-network.com', 'ticketmaster.com', 'tides.mobilegeographics.com', 'timetemperature.com', 'tiptopglobe.com', 'tivertonfourcorners.com', 'tonopahnevada.com', 'topix.com', 'topix.net', 'topoquest.com', 'topozone.com', 'totsandtravel.com', 'touristdb.com', 'town-court.com', 'townofbelgrade.com', 'traderjoes.com', 'traillink.com', 'trails.com', 'travel.yahoo.com', 'travela.priceline.com', 'travel-maine.info', 'travelmath.com', 'travelnevada.com', 'traveloregon.com', 'traveltips.u.com', 'tributes.com', 'tripadvisor.com', 'triptrivia.com', 'trulia.com', 'tvtrip.com', 'twitter.com', 'ucomparehealthcare.com', 'unitedelectricalservices.com', 'urbandictionary.com', 'us.jobrapido.com', 'usa.com', 'usacitiesonline.com', 'usanimalcontrol.com', 'usa-people-search.com', 'usatravelparks.blogspot.com', 'usbanklocations.com', 'usbeacon.com', 'uscitydirectories.com', 'us-city-home.com', 'userinstinct.com', 'usgwtombstones.org', 'u-s-history.com', 'usidentify.com', 'us-places.com', 'uspostcards.com', 'usps.com', 'usspecbook.com', 'utah.com', 'utilities.cityofws.org', 'vacationrentals.com', 'vacationrentals411.com', 'verizonwireless.com', 'viewcarolinahomes.com', 'viewphotos.org', 'virginia.hometownlocator.com', 'virginiacitynews.com', 'visitlubecmaine.com', 'visitmaine.com', 'visitmaine.net', 'visitnc.com', 'vitals.com', 'voices.yahoo.com', 'walmart.com', 'washington.hometownlocator.com', 'waymarking.com', 'weather.weatherbug.com', 'weatherbase.com', 'weatherforyou.com', 'weatherstreet.com', 'web.userinstinct.com', 'web1.userinstinct.com', 'web2.userinstinct.com', 'webpages.charter.net', 'webpanda.com', 'webspacecreations.com', 'weplay.com', 'werelate.org', 'wesleyberryflowers.com', 'westcottproperties.com', 'whitepages.com', 'widget.24timezones.com', 'wiki.answers.com', 'wikimapia.org', 'wikitravel.org', 'wmrw.org', 'woonsocketfire.org', 'woonsocketpolice.com', 'woonsocketschools.com', 'worldcasinodirectory.com', 'worldrover.com', 'worldweatheronline.com', 'wpnet.org', 'www1.marshallsonline.com', 'www2.globalscholar.com', 'wyzant.com', 'xphomestation.com', 'xroadschurch.us', 'yardsalesearch.com', 'yellowbook.com', 'yellowbot.com', 'yellownationaldirectory.com', 'yellowpages.foxcharlotte.com', 'yellowpages.norwichbulletin.com', 'yellowpages.washingtonpost.com', 'yellowpagesgoesgreen.org', 'yellowusapages.com', 'yelp.com', 'yelp.com.au', 'youinweb.com', 'yourroadmaptohome.com', 'yp.nevadaappeal.com', 'yp.ocregister.com', 'zetify.com', 'zillow.com', 'zipareacode.net', 'zipcode.org', 'zip-codes.com', 'zipperpages.com'];

    var suspiciousDomains = ['salesforce.com', 'asp.net', 'youtube.com', 'wordpress.com', 'twitter.com'];

    blacklistedDomains.push('google.com');

    var aboutPages = ['leadership', 'leaders', 'bios', 'management', 'team', 'board', 'executive', 'directors', 'personnel'];

    var debug = 'contact-utility.js';

    var self = {

        addContacts: null, // call as function (contacts, company, donotsave)

        contacts: [],

        parseSocialVenu: function (url) {
            if (!url) { return 'other'; }
            url = url.toLowerCase();
            for (var index in socialDomains) {
                if (url.indexOf(socialDomains[index].domain) > -1) { return socialDomains[index].venue; }
            }
            return 'other';
        },
        getSocialIcon: function (socialVenu) {
            if (!socialVenu) { return undefined; }
            return 'images/social/' + socialVenu + '.jpg';
        },

        createNewContact: function () {

            var C = function () {

                this.c = new Date();
                //this.c2 = this._createdon.getTime();
                this._dived = false;
                this._enhanced = false;
                this._enhancing = false;
                this._hidden = false;
                this._new = true;

                this.id = null;
                this.flags = null;
                this.phone1src = null;
                this.mark = null;
                this.sourceurl = '';

                this.first = '';
                this.last = '';
                this.jobtitle = '';
                this.company = '';
                this.email = '';
                this.phone = '';
                this.phone2 = '';
                this.website = '';
                this.bio = '';

                this.address1 = '';
                this.address2 = '';
                this.city = '';
                this.state = '';
                this.zip = '';
                this.country = '';

            };

            return new C();

        },

        contactToBlXml: function (c) {
            var contact = [];

            var fields = [];
            xmlUtility.encodeWrapPush(c.id + '', 'Handle', fields, true);
            xmlUtility.encodeWrapPush(c.last, 'LastName', fields, true);
            xmlUtility.encodeWrapPush(c.middle, 'MiddleName', fields, true);
            xmlUtility.encodeWrapPush(c.first, 'FirstName', fields, true);
            xmlUtility.encodeWrapPush(c.jobtitle, 'JobTitle', fields, true);
            xmlUtility.encodeWrapPush(c.email, 'Email', fields, true);
            xmlUtility.encodeWrapPush(c.website, 'Website', fields, true);
            xmlUtility.encodeWrapPush(c.sourceurl, 'SourceURL', fields, true);
            xmlUtility.encodeWrapPush(c.company, 'CompanyName', fields, true);
            xmlUtility.encodeWrapPush(c.bio, 'Biography', fields, true);

            var address = [];
            xmlUtility.encodeWrapPush(c.address1, 'AddressLine1', address, true);
            xmlUtility.encodeWrapPush(c.address2, 'AddressLine2', address, true);
            xmlUtility.encodeWrapPush(c.city, 'City', address, true);
            xmlUtility.encodeWrapPush(c.state, 'State', address, true);
            xmlUtility.encodeWrapPush(c.zip, 'PostalCode', address, true);
            xmlUtility.encodeWrapPush(c.country, 'Country', address, true);
            //  Wrap address in as a field
            xmlUtility.wrapAndPush(address.join(''), 'MainAddress', fields, true);

            //  Wrap fields into contact
            xmlUtility.wrapAndPush(fields.join(''), 'Fields', contact, true);
            var i;
            var lists = [];
            var phones = [];
            if (c.phone) { phones.push(xmlUtility.tag(xmlUtility.encodeAndWrap(c.phone, 'Text'), 'Phone')); }
            if (c.phone2) { phones.push(xmlUtility.tag(xmlUtility.encodeAndWrap(c.phone2, 'Text'), 'Phone')); }

            if (c.phones) {
                for (i = 0; i < c.phones.length; i++) {
                    var phone = xmlUtility.encodeAndWrap(c.phones[i].text, 'Text');
                    var type = xmlUtility.encodeAndWrap(c.phones[i].type, 'Type');
                    phones.push(xmlUtility.tag([phone, type].join(''), 'Phone'));
                }
            }

            if (phones.length) {
                //  Wrap phones into contact
                //xmlUtility.wrapAndPush(xmlUtility.tag(phones.join(''), 'Phones'), 'Lists', lists, true);
                lists.push(xmlUtility.tag(phones.join(''), 'Phones'));
            }
            if (c.venues) {
                var venues = [];
                for (i = 0; i < c.venues.length; i++) {
                    var text = xmlUtility.encodeAndWrap(c.venues[i].website, 'Text');
                    var vtype = xmlUtility.encodeAndWrap(c.venues[i].type, 'Type');
                    var venueparts = [text, vtype];
                    venues.push(xmlUtility.tag(venueparts.join(''), 'Venue'));
                }
                if (venues.length) {
                    //  Wrap phones into contact
                    lists.push(xmlUtility.tag(venues.join(''), 'Venues'));
                }
            }
            if (c.addresses) {
                var addresses = [];
                for (i = 0; i < c.addresses.length; i++) {
                    var address1 = xmlUtility.encodeAndWrap(c.addresses[i].address1, 'AddressLine1');
                    var address2 = xmlUtility.encodeAndWrap(c.addresses[i].address2, 'AddressLine2');
                    //var tag = xmlUtility.encodeAndWrap(c.addresses[i].tag, 'AddressTag');
                    var city = xmlUtility.encodeAndWrap(c.addresses[i].city, 'City');
                    var country = xmlUtility.encodeAndWrap(c.addresses[i].country, 'Country');
                    var zip = xmlUtility.encodeAndWrap(c.addresses[i].zip, 'PostalCode');
                    var state = xmlUtility.encodeAndWrap(c.addresses[i].state, 'State');
                    addresses.push(xmlUtility.tag([address1, address2, city, country, zip, state].join(''), 'Address'));
                }
                if (addresses.length) {
                    lists.push(xmlUtility.tag(addresses.join(''), 'AdditionalAddresses'));
                }
            }
            if (c.emails || c.email2) {
                var emails = [];
                if (c.email2) {
                    var email2 = xmlUtility.encodeAndWrap(c.email2, 'Email');
                    emails.push(email2);
                }
                if (c.emails) {
                    for (i = 0; i < c.emails.length; i++) {
                        var email = xmlUtility.encodeAndWrap(c.emails[i], 'Email');
                        emails.push(email);
                    }
                }
                if (emails.length) {
                    lists.push(xmlUtility.tag(emails.join(''), 'AdditionalEmails'));
                }
            }
            if (lists.length) {
                xmlUtility.wrapAndPush(lists.join(''), 'Lists', contact, true);
            }
            return xmlUtility.tag(contact.join(''), 'Contact');
        },
        contactsToBlXml: function (c) {
            var contacts = [];
            for (var index in c) {
                contacts.push(this.contactToBlXml(c[index]));
            }
            return xmlUtility.tag(contacts.join(''), 'Contacts');
        },

        contactsToBlJson: function (contacts) {

            var i,
                c,
                a,
                aa = [];

            if (contacts) {
                for (i = 0; i < contacts.length; i++) {

                    c = contacts[i];

                    if (!c) {
                        continue;
                    }

                    a = {};

                    if (c.id) {
                        a.Handle = [c.id];
                    }
                    if (c.last) {
                        a.LastName = [c.last];
                    }
                    if (c.middle) {
                        a.MiddleName = [c.middle];
                    }
                    if (c.first) {
                        a.FirstName = [c.first];
                    }
                    if (c.jobtitle) {
                        a.JobTitle = [c.jobtitle];
                    }
                    if (c.website) {
                        a.Website = [c.website];
                    }
                    if (c.company) {
                        a.CompanyName = [c.company];
                    }
                    if (c.address1) {
                        a.AddressLine1 = [c.address1];
                    }
                    if (c.address2) {
                        a.AddressLine2 = [c.address2];
                    }
                    if (c.city) {
                        a.City = [c.city];
                    }
                    if (c.state) {
                        a.State = [c.state];
                    }
                    if (c.zip) {
                        a.PostalCode = [c.zip];
                    }
                    if (c.country) {
                        a.Country = [c.country];
                    }

                    if (c.phone) {
                        a.Phone = [c.phone];
                        if (c.phone2) {
                            a.Phone.push(c.phone2);
                        }
                    }

                    a.RecordType = ['Person'];

                    aa.push(a);
                }
            }
            return aa;
        },

        //     apply overriding contact data to each contact
        applyOverrides: function (contacts, overridingContact) {
            if (!overridingContact) { return; }
            if (!contacts) { return; }
            if (contacts.length === 0) { return; }

            for (var contactIndex in contacts) {
                var contact = contacts[contactIndex];
                for (var fieldKey in contact) {
                    if (!overridingContact[fieldKey]) { continue; }
                    contact[fieldKey] = overridingContact[fieldKey];
                }
            }
        },

        fixUrl: function (url, preserveCase) {
            // drops http and www, lowercases and trims
            var u = url;
            if (u) {
                //console.log('***************** fixing url: ' + u);
                if (!preserveCase) {
                    u = u.toLowerCase();
                }
                u = u.trim();
                if (u.indexOf('://') >= 0) {
                    u = u.substring(u.indexOf('://') + 3);
                }
                if (u.indexOf('www.') === 0) {
                    u = u.substring(4);
                }
                if (u.lastIndexOf('/') === (u.length - 1)) {
                    u = u.substring(0, u.length - 1);
                }
                //console.log('***************** fixed url: ' + u);
            }
            return u;
        },

        sortVenues: function (contact) {
            try {

                contact.venues = contact.venues || [];

                contact.linkedin = self.getVenue(contact, 'linkedin.com');
                contact.twitter = self.getVenue(contact, 'twitter.com');
                contact.facebook = self.getVenue(contact, 'facebook.com');
                contact.employeesAvg = self.getEmployeesAvg(contact.employees);
                contact.revenueAvg = self.getRevenueAvg(contact.revenue);
                contact._hasOtherVenues = false;

                contact.website = self.fixUrl(contact.website);
                contact.full = self.fixFullName('', contact.first, contact.last, contact.middle);
                contact.emailverbool = parseInt(contact.emailver) > 1;
                contact.email2verbool = parseInt(contact.email2ver) > 1;

                var i = contact.venues.length;
                while (i--) {
                    var w = contact.venues[i].website || '';
                    if (w.indexOf(contact.facebook) >= 0 || w.indexOf(contact.linkedin) >= 0 || w.indexOf(contact.twitter) >= 0) {
                        contact.venues[i].top = true;
                    } else {
                        contact.venues[i].top = false;
                        contact._hasOtherVenues = true;
                    }
                    contact.venues[i].personal = self.isIndividualProfile(w, contact.company, contact.first, contact.last);
                    // Delete company website form the list of venues
                    if (w === contact.website) {
                        console.warn('Deleting venue', angular.copy(contact.venues[i]));
                        contact.venues.splice(i, 1);
                    }
                }

                // Sort: facebook, linkedin, twiiter, others
                var pos = 0;
                var copy = null;
                if (contact.facebook) {
                    angular.forEach(contact.venues, function (venue, index) {
                        if (venue.website === contact.facebook) {
                            if (index !== pos) {
                                copy = angular.copy(venue);
                                contact.venues.splice(index, 1);
                                contact.venues.splice(pos, 0, copy);
                            }
                            pos++;
                        }
                    });
                }
                if (contact.linkedin) {
                    angular.forEach(contact.venues, function (venue, index) {
                        if (venue.website === contact.linkedin) {
                            if (index !== pos) {
                                copy = angular.copy(venue);
                                contact.venues.splice(index, 1);
                                contact.venues.splice(pos, 0, copy);
                            }
                            pos++;
                        }
                    });
                }
                if (contact.twitter) {
                    angular.forEach(contact.venues, function (venue, index) {
                        if (venue.website === contact.twitter) {
                            if (index !== pos) {
                                copy = angular.copy(venue);
                                contact.venues.splice(index, 1);
                                contact.venues.splice(pos, 0, copy);
                            }
                            pos++;
                        }
                    });
                }

            } catch (e) {
                console.error('Calculate Fields > ', e.message);
            }
        },

        endsWith: function (str, suffix) {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        },

        stripCompanyName: function (value) {

            if (!value) { return value; }

            var k = '';
            try {
                k = ', Inc.'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ', Inc'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' Inc.'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' Inc'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ', LLC'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' LLC'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ', The'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' LTD'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' Co'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' Corporation'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' Corp'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' GmbH'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' Group'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' PLC'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
                k = ' LLP'; if (self.endsWith(value, k) > 0) { return value.substring(0, value.length - k.length); }
            } catch (e) {
                console.log('ERROR in stripCompanyName value:', value, ' error:' + e.message);
            }


            return value;
        },

        abbreviate: function (company) {
            var a = '';

            if (company && company.length > 0) {
                var first = true;
                for (var i = 0; i < company.length; i++) {
                    var c = company[i];
                    if (c.match(/[a-z]/i)) {
                        if (first) {
                            a = a + c;
                        }
                        first = false;
                    } else {
                        first = true;
                    }
                }
            }

            return a;
        },

        firstWord: function (company) {
            var a = '';

            if (company && company.length > 0) {
                var first = true;
                for (var i = 0; i < company.length; i++) {
                    var c = company[i];
                    if (c.match(/[a-z]/i)) {
                        if (first) {
                            a = a + c;
                        }
                    } else {
                        first = false;
                        break;
                    }
                }
            }

            return a;
        },

        isLinkedInIndividualProfile: function (url) {
            if (!url) { return false; }
            url = url.toLowerCase();
            if (url.indexOf('linkedin.com/in/') >= 0) { return true; }
            if (url.indexOf('linkedin.com/pub/') >= 0 && url.indexOf('inkedin.com/pub/dir/') < 0) { return true; }
            if (url.indexOf('linkedin.com/profile/') >= 0) { return true; }
            return false;
        },

        isTwitterIndividualProfile: function (url, company, first, last) {
            if (!url) { return false; }
            url = url.toLowerCase();
            if (url.indexOf('twitter.com/') >= 0) {

                var abbr = self.abbreviate(company).toLowerCase();
                if (abbr.length > 1 && url.indexOf('twitter.com/' + abbr) >= 0) {
                    return false;
                }

                var firstWord = self.firstWord(company).toLowerCase();
                if (firstWord.length > 0 && url.indexOf('twitter.com/' + firstWord) >= 0) {
                    return false;
                }

                first = (first || '').toLowerCase();
                if (first.length > 0 && url.indexOf(first, url.indexOf('.com/') + 4) > 0) {
                    return true;
                }

                last = (last || '').toLowerCase();
                if (last.length > 0 && url.indexOf(last, url.indexOf('.com/') + 4) > 0) {
                    return true;
                }

                return false;
            }
            return false;
        },

        isFacebookIndividualProfile: function (url, company, first, last) {
            if (!url) { return false; }
            url = url.toLowerCase();
            if (url.indexOf('facebook.com/') >= 0) {

                var abbr = self.abbreviate(company).toLowerCase();
                if (abbr.length > 1 && url.indexOf('facebook.com/' + abbr) >= 0) {
                    return false;
                }

                var firstWord = self.firstWord(company).toLowerCase();
                if (firstWord.length > 0 && url.indexOf('facebook.com/' + firstWord) >= 0) {
                    return false;
                }

                first = (first || '').toLowerCase();
                if (first.length > 0 && url.indexOf(first, url.indexOf('.com/') + 4) > 0) {
                    return true;
                }

                last = (last || '').toLowerCase();
                if (last.length > 0 && url.indexOf(last, url.indexOf('.com/') + 4) > 0) {
                    return true;
                }

                return false;
            }
            return false;
        },

        isIndividualProfile: function (url, company, first, last) {
            const functionName = 'Is Individual Profile';
            try {
                if (!url) { return false; }
                url = url.toLowerCase();
                var abbr = self.abbreviate(company).toLowerCase();
                var firstWord = self.firstWord(company).toLowerCase();
                first = (first || '').toLowerCase();
                last = (last || '').toLowerCase();

                var checkDomain = function (domain) {
                    if (url.indexOf(domain) >= 0) {
                        if (abbr.length > 1 && url.indexOf(domain + abbr) >= 0) {
                            return false;
                        }
                        if (firstWord.length > 0 && url.indexOf(domain + firstWord) >= 0) {
                            return false;
                        }
                        if (first.length > 0 && url.indexOf(first, url.indexOf(domain) + 4) > 0) {
                            return true;
                        }
                        if (last.length > 0 && url.indexOf(last, url.indexOf(domain) + 4) > 0) {
                            return true;
                        }
                    }
                    return null;
                };
                var domainResult = null;
                domainResult = checkDomain('.com/'); if (domainResult !== null) { return domainResult; }
                domainResult = checkDomain('.so/'); if (domainResult !== null) { return domainResult; }
                domainResult = checkDomain('.net/'); if (domainResult !== null) { return domainResult; }
                domainResult = checkDomain('.org/'); if (domainResult !== null) { return domainResult; }
                domainResult = checkDomain('.me/'); if (domainResult !== null) { return domainResult; }
                domainResult = checkDomain('user/'); if (domainResult !== null) { return domainResult; }
                domainResult = checkDomain(''); if (domainResult !== null) { return domainResult; }
            } catch (e) {
                console.error(functionName, e.message);
            }
            return false;
        },

        addAddress: function (contact, address) {
            contact.addresses = contact.addresses || [];
            if (address) {
                var i = contact.addresses.length;
                while (i--) {
                    if (
                        (contact.addresses[i].address1 || '').toLowerCase() === (address.address1 || '').toLowerCase() &&
                        (contact.addresses[i].address2 || '').toLowerCase() === (address.address2 || '').toLowerCase() &&
                        (contact.addresses[i].city || '').toLowerCase() === (address.city || '').toLowerCase() &&
                        (contact.addresses[i].state || '').toLowerCase() === (address.state || '').toLowerCase() &&
                        (contact.addresses[i].zip || '').toLowerCase() === (address.zip || '').toLowerCase() &&
                        (contact.addresses[i].country || '').toLowerCase() === (address.country || '').toLowerCase()
                        ) {
                        //console.log('EQUAL', angular.copy(address), angular.copy(contact.addresses[i]));
                        return;
                    }
                    else {
                        //console.log('NOT EQUAL', angular.copy(address), angular.copy(contact.addresses[i]));
                    }
                }
                if (debug) { console.log(debug + 'addAddress', address); }
                contact.addresses.push(address);
            }
        },

        composeFullAddress: function (contact, separator) {

            if (!contact) { return ''; }

            separator = separator || ' ';

            var a = ((contact.address1 || '') + ' ' + (contact.address2 || '')).trim();
            var b = (contact.city || '').trim();
            var b2 = (contact.state || '').trim();
            var c = (contact.zip || '').trim();
            var d = (contact.country || '').trim();

            if (b && b2) { b = b + ', ' + b2; }
            if (b && c) { c = ' ' + c; }
            if (a && (b || c || d)) { a = a + separator; }
            if (d && (b || c)) { d = separator + d; }

            return a + b + c + d;
        },

        isNumber: function (n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        },

        getEmployeesAvg: function (range) {
            const functionName = 'Get Employees Average';
            try {
                if (!range) { return null; }
                if (self.isNumber(range)) { return range; }
                var sides = range.split('-');

                if (sides.length === 2) {
                    var low = parseInt(sides[0].trim().replace(/,/g, ''), 10);
                    var high = parseInt(sides[1].trim().replace(/,/g, ''), 10);
                    if (low >= 0 && high > 0) {
                        var avg = Math.round((low + high) / 2);
                        return avg;
                    }
                } else {
                    // over, under, <, >
                    sides = range.split(' ');
                    var i = sides.length;
                    while (i--) {
                        var num = parseInt(sides[i].trim().replace(/,/g, ''), 10);
                        if (num > 0) { return num; }
                    }
                }
            } catch (e) {
                console.error(functionName, e.message);
            }
            return null;
        },

        // Convert string currency (Ex: "$25.0B") to int
        parseCurrency: function (value) {
            if (!value) { return null; }
            value = value.trim();
            if (value.indexOf('$') === 0) {
                value = value.substring(1);
            }
            var correction = 1;
            if (value.indexOf('B') === (value.length - 1)) {
                value = value.substring(0, value.length - 1);
                correction = 1000000000;
            }
            if (value.indexOf('M') === (value.length - 1)) {
                value = value.substring(0, value.length - 1);
                correction = 1000000;
            }
            if (value.indexOf('K') === (value.length - 1)) {
                value = value.substring(0, value.length - 1);
                correction = 1000;
            }
            var num = parseInt(value);
            //console.warn(value, ' => ', num);
            if (value[value.length - 1] === '9') {
                num++;
            }
            num *= correction;
            return num;
        },

        formatCurrency: function (num) {
            if (num >= 1000000000) {
                num = Math.round(num / 1000000000);
                return '$' + num + 'B';
            } else if (num >= 1000000) {
                num = Math.round(num / 1000000);
                return '$' + num + 'M';
            } else if (num >= 1000) {
                num = Math.round(num / 1000);
                return '$' + num + 'K';
            } else {
                return num;
            }
        },

        fixHighRange: function (high, low) {
            while (high < low && high > 0) {
                var s = '' + high;
                var last = s[s.length - 1];
                s = '' + s + last;
                high = parseInt(s);
            }
            return high;
        },

        getRevenueAvg: function (range) {
            const functionName = 'Get Revenue Average';
            try {
                if (!range) { return null; }
                if (self.isNumber(range)) { return range; }
                var separator = ' to ';
                if (range.indexOf(separator) < 0) {
                    separator = '-';
                }
                var sides = range.split(separator);

                if (sides.length === 2) {
                    //var low = parseInt(sides[0].trim().replace(/\$/g, ''), 10);
                    //var high = parseInt(sides[1].trim().replace(/\$/g, ''), 10);
                    var low = self.parseCurrency(sides[0]);
                    var high = self.parseCurrency(sides[1]);
                    high = self.fixHighRange(high, low);
                    if (low >= 0 && high > 0) {
                        var avg = Math.round((low + high) / 2);
                        return avg;
                    } else if (high > 0) {
                        return high;
                    } else if (low > 0) {
                        return low;
                    }
                } else {
                    // over, under, <, >
                    sides = range.split(' ');
                    var i = sides.length;
                    while (i--) {
                        var num = parseInt(sides[i].trim().replace(/\$/g, ''), 10);
                        if (num > 0) { return num; }
                    }
                }
            } catch (e) {
                console.error(functionName, e.message);
            }
            return null;
        },

        fixCompany: function (company) {
            var pos1;

            // check for parenthesis in company name
            if (company) {

                pos1 = company.indexOf('(');
                if (pos1 > 1) {
                    company = company.substring(0, pos1).trim();
                }

                pos1 = company.indexOf(' - ');
                if (pos1 >= 0) {
                    company = company.substring(0, pos1).trim();
                }

                pos1 = company.indexOf(';');
                if (pos1 > 1) {
                    company = company.substring(0, pos1).trim();
                }
            }

            return company;
        },

        fixTitle: function (title, company) {

            if (title && company) {
                // check for title ending with company name
                var p = title.indexOf(company);
                if (p > 1 && p >= (title.length - company.length - 2)) {
                    title = title.substring(0, p - 1).trim();
                }
            }

            if (title) {
                var l = title.length;

                // ends with  "(...)"
                var checkAgain = true;
                while (checkAgain && title[l - 1] === ')') {
                    checkAgain = false;
                    var x = title.lastIndexOf('(');
                    if (x) {
                        title = title.substring(0, x).trim();
                        checkAgain = l !== title.length;
                        l = title.length;
                    }
                }

                if (l > 0) {
                    if (title[l - 1] === ',') { title = title.substring(0, l - 1).trim(); }
                    else if (title[l - 1] === '@') { title = title.substring(0, l - 1).trim(); }
                    else if (l > 4 && title.substring(l - 3, l) === ' at') { title = title.substring(0, l - 3).trim(); }
                }

                ////console.log('lrm removal:' + title[0]+'|'+ title.charCodeAt(0));
                //if (title.charCodeAt(0) === 8206) {
                //    title = title.substring(1);
                //    //console.log('lrm removed' + '|' + title.charCodeAt(0));
                //}

                var cleanTitle = [];
                for (var i = 0, len = title.length; i < len; i++) {
                    if (title.charCodeAt(i) !== 8206) {
                        cleanTitle.push(title[i]);
                    }
                }
                title = cleanTitle.join('');
            }
            //console.log('fixed title=' + title + '|company=' + company + "|")

            // remove "clouds", etc.
            //title = title.replace(/([^a-z\&.,- ]+)/ig, '').trim();

            return title;
        },

        getEmail: function (text, first, last, website) {

            var t = text;
            var f = first;
            var l = last;
            //var d = this.getDomain(website);

            if (!t) { return ''; }

            var regex = /([a-z0-9._]+)@([a-z0-9-]+)([.]([a-z]{1,3})(?![a-z])){1,2}/igm;

            //var matches = text.match(regex);
            //console.log('email', matches);

            var e = regex.exec(text);
            if (e && e.length > 0) {
                //console.log('email', e);
                e = e[0].toLowerCase();
            }

            return e;
        },

        getDomain: function (website) {
            var regex = /([a-z0-9-]+)([.]([a-z]{1,3})(?![a-z-])){1,2}/ig;
            var d = regex.exec(website);
            if (d && d.length > 0) { d = d[0]; }
            if (d && d.length > 0) { d = d.toLowerCase(); }
            //console.log('domain', d, 'website', website);
            return d;
        },

        getPhone: function (text) {
            var regex = /([0-9]{3})-([0-9]{3})-([0-9]{4})/ig;
            var d = regex.exec(text);
            if (d && d.length > 0) {
                d = d[0];
                console.log('PHONE', d);
            } else {
                regex = /(\({1})([0-9]{3})(\({1})(\s*)([0-9]{3})-([0-9]{4})/ig;
                d = regex.exec(text);
                if (d && d.length > 0) {
                    d = d[0];
                    console.log('PHONE (2)', d);
                }
            }
            return d;
        },

        isFreeEmailDomain: function (emaildomain) {
            if (!emaildomain) { return false; }

            var e = emaildomain.trim().toLowerCase();

            var suffix = '.rr.com';
            if (e.indexOf(suffix, this.length - suffix.length) !== -1)
            { return true; }

            //var d = [];
            //d.push('gmail.com', 'yahoo.com', 'facebook.com', 'live.com', 'hotmail.com', 'aol.com');

            return freeEmailDomains.indexOf(e) >= 0;
        },

        isBlacklistedDomain: function (domain) {
            if (!domain) { return false; }
            var e = domain.trim().toLowerCase();
            return blacklistedDomains.indexOf(e) >= 0;
        },

        isSuspiciousDomain: function (domain) {
            if (!domain) { return false; }
            var e = domain.trim().toLowerCase();
            return suspiciousDomains.indexOf(e) >= 0;
        },

        isAboutPage: function (url) {
            if (!url) { return false; }
            var domain = this.getDomain(url);
            var path = url.trim().toLowerCase().split(domain)[1];
            if (!path) { return false; }
            var i = aboutPages.length;
            while (i--) {
                if (path.indexOf(aboutPages[i]) >= 0) {
                    return true;
                }
            }
            return false;
            //var e = url.trim().toLowerCase();
            //return aboutPages.indexOf(e) >= 0;
        },

        isTitle: function (title) {

            //console.log('IS TITLE', title);

            if (!title)
            { return false; }

            if (title.toLowerCase().indexOf('seeking') > -1)
            { return false; }
            if (title.toLowerCase().indexOf('unemployed') > -1)
            { return false; }

            return true;
        },

        fixFullName: function (fullname, first, last, middle) {

            var full, pos1, pos2, suffixStr;
            var stuffInTheMiddle = false;

            full = fullname || '';
            first = first || '';
            last = last || '';
            middle = middle || '';

            pos1 = first.indexOf('('); if (pos1 >= 0) { first = first.substring(0, pos1).trim(); stuffInTheMiddle = true; }
            pos1 = first.indexOf('['); if (pos1 >= 0) { first = first.substring(0, pos1).trim(); stuffInTheMiddle = true; }
            pos1 = last.indexOf('('); if (pos1 >= 0) { last = last.substring(0, pos1).trim(); stuffInTheMiddle = true; }
            pos1 = last.indexOf('['); if (pos1 >= 0) { last = last.substring(0, pos1).trim(); stuffInTheMiddle = true; }

            if (!full || stuffInTheMiddle) {
                full = (((first ? first : '') + ' ' + (middle ? middle : '')).trim() + ' ' + (last ? last : '')).trim();
            }

            pos1 = full.indexOf('(');
            if (pos1 >= 0) {
                suffixStr = '';
                pos2 = full.indexOf(')', pos1 + 1);
                if (pos2 >= 0 && pos2 < (full.length - 1)) {
                    suffixStr = full.substring(pos2 + 1).trim();
                    if (suffixStr.length > 0) { suffixStr = ' ' + suffixStr; }
                }
                full = full.substring(0, pos1).trim() + suffixStr;
            }

            pos1 = full.indexOf('[');
            if (pos1 >= 0) {
                suffixStr = '';
                pos2 = full.indexOf(']', pos1 + 1);
                if (pos2 >= 0 && pos2 < (full.length - 1)) {
                    suffixStr = full.substring(pos2 + 1).trim();
                    if (suffixStr.length > 0) { suffixStr = ' ' + suffixStr; }
                }
                full = full.substring(0, pos1).trim() + suffixStr;
            }

            pos1 = full.indexOf('{');
            if (pos1 >= 0) {
                suffixStr = '';
                pos2 = full.indexOf('}', pos1 + 1);
                if (pos2 >= 0 && pos2 < (full.length - 1)) {
                    suffixStr = full.substring(pos2 + 1).trim();
                    if (suffixStr.length > 0) { suffixStr = ' ' + suffixStr; }
                }
                full = full.substring(0, pos1).trim() + suffixStr;
            }

            pos1 = full.indexOf('"');
            if (pos1 >= 0) {
                pos2 = full.indexOf('"', pos1 + 1);
                if (pos2 > pos1) {
                    full = full.substring(0, pos1).trim() + ' ' + full.substring(pos2 + 1).trim();
                }
            }

            pos1 = full.indexOf('='); if (pos1 >= 0) { full = full.substring(0, pos1).trim(); }
            pos1 = full.indexOf('|'); if (pos1 >= 0) { full = full.substring(0, pos1).trim(); }
            pos1 = full.indexOf(';'); if (pos1 >= 0) { full = full.substring(0, pos1).trim(); }
            pos1 = full.indexOf('Interactive'); if (pos1 >= 0) { full = full.replace(/Interactive/gi, ''); }
            pos1 = full.indexOf('TopLinked'); if (pos1 >= 0) { full = full.replace(/TopLinked/gi, ''); }

            pos1 = full.indexOf(',');
            if (pos1 >= 0) {
                pos2 = full.indexOf(' ');
                if (pos2 < pos1) {
                    full = full.substring(0, pos1).trim();
                } else {
                    full = full.substring(pos1 + 1).trim() + ' ' + full.substring(0, pos1).trim();
                }
            }

            pos1 = full.indexOf('- ');
            if (pos1 >= 0) {
                pos2 = full.indexOf(' ');
                if (pos2 > 0 && pos2 < pos1) {
                    full = full.substring(0, pos1).trim();
                }
            }

            full = full.replace(/([^-a-z\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC ]+)/ig, '').trim();

            return full;
        },

        splitFullName: function (full) {

            var res = { full: full, last: '', first: '', middle: '' };

            if (full.indexOf(' ') >= 0) {
                var parts = full.split(' ');
                if (parts.length === 2) {
                    res.first = parts[0];
                    res.middle = '';
                    res.last = parts[1];
                } else if (parts.length === 3) {
                    res.first = parts[0];
                    res.middle = parts[1];
                    res.last = parts[2];
                } if (parts.length > 3) {
                    res.first = '';
                    for (var i = 0; i < parts.length - 2; i++) {
                        res.first += parts[i] + ' ';
                    }
                    res.first = res.first.trim();
                    res.middle = parts[parts.length - 2];
                    res.last = parts[parts.length - 1];
                }
            }
            else {
                res.first = '';
                res.middle = '';
                res.last = full;
            }

            return res;
        },

        readPatternRecord: function (record, contact) {

            //console.log('reading record', angular.copy(record));
            if (record) {
                for (var j = 0; j < record.length; j++) {
                    this.readPatternField(record[j], contact);
                    if (record[j].Data)
                    { this.readPatternRecord(record[j].Data, contact); }
                }
            }

            self.sortVenues(contact);

        },

        scanText: function (text, contact) {

            var emailStr, websiteStr, phoneStr, p1, p2;

            //console.log('scanning', text, this);

            emailStr = this.getEmail(text, contact.first, contact.last, contact.website);
            if (emailStr) {
                if (!contact.email) { contact.email = emailStr; }
                else if (!contact.email2 && contact.email.toLowerCase() !== emailStr.toLowerCase()) { contact.email2 = emailStr; }
            }

            websiteStr = this.getDomain(text);
            if (websiteStr) {
                if (!contact.website) {
                    if (!this.isFreeEmailDomain(websiteStr) && !this.isSuspiciousDomain(websiteStr))
                    { contact.website = websiteStr; }
                }
            }

            phoneStr = this.getPhone(text);
            if (phoneStr) {
                if (!contact.phone) { contact.phone = this.formatPhone(phoneStr); }
                else if (!contact.phone2 && contact.phone.toLowerCase() !== phoneStr.toLowerCase()) {
                    p1 = contact.phone.replace(/[^0-9]+/g, '');
                    p2 = phoneStr.replace(/[^0-9]+/g, '');
                    console.log('PHONE', p1, p2);
                    if (p1.length < 10 || p2.length < 10 || p1.indexOf(p2) < 0)
                    { contact.phone2 = this.formatPhone(phoneStr); }
                }
            }
        },

        readPatternField: function (field, contact) {

            var storeUnstructuredData = function () {
                try {
                    if (!contact.data) { contact.data = []; }
                    contact.data.push({ Name: field.Name, Value: field.Value });
                } catch (e) {
                    console.log('ERROR', e.message);
                }
            };

            if (field.Name === 'Company') {
                if (field.Value && !contact.company)
                { contact.company = this.fixCompany(field.Value); }
            }
            else if (field.Name === 'Title') {
                if (field.Value && !contact.jobtitle && this.isTitle(field.Value))
                { contact.jobtitle = this.fixTitle(field.Value); }
            }
            else if (field.Name === 'Location') {
                if (field.Value && !contact.city)
                { contact.city = field.Value; }
            }
            else if (field.Name === 'FullName') {
                if (field.Value && !contact.last && !contact.first) {
                    var fullNameStr = this.fixFullName(field.Value, '', '', '');
                    var fullNameObj = this.splitFullName(fullNameStr);
                    contact.last = fullNameObj.last;
                    contact.first = fullNameObj.first;
                    contact.middle = fullNameObj.middle;
                }
            }
            else if (field.Name === 'FirstName') {
                if (field.Value && !contact.first)
                { contact.first = field.Value; }
            }
            else if (field.Name === 'MiddleName') {
                if (field.Value && !contact.middle)
                { contact.middle = field.Value; }
            }
            else if (field.Name === 'LastName') {
                if (field.Value && !contact.last)
                { contact.last = this.fixFullName(field.Value, '', '', ''); }
            }
            else if (field.Name === 'Handle') {
                if (field.Value && !contact.handle)
                { contact.handle = field.Value; }
            }
            else if (field.Name === 'BIO' || field.Name === 'Bio') {
                if (field.Value) {
                    if (!contact.bio)
                    { contact.bio = field.Value; }
                    this.scanText(field.Value, contact);
                }
            }
            else if (field.Name === 'Website' || field.Name === 'WebSite') {
                if (field.Value && field.Value.indexOf('Company Website') === -1) {
                    var domain = this.getDomain(field.Value);

                    if (!contact.website && !this.isSuspiciousDomain(domain))
                    { contact.website = field.Value; }
                    else {
                        this.addVenue(contact, { website: field.Value, type: 'website' });
                        //if (!contact.venues) { contact.venues = []; }
                        //contact.venues.push({ website: field.Value, type: 'website' });
                    }
                }
            }
            else if (field.Name.indexOf('Email') === 0) {
                if (field.Value) {
                    if (!contact.email)
                    { contact.email = field.Value; }
                    else if (!contact.email2 && contact.email.toLowerCase() !== field.Value.toLowerCase())
                    { contact.email2 = field.Value; }
                }
            }
            else if (field.Name.indexOf('Phone') === 0) {
                if (field.Value) {
                    if (!contact.phone)
                    { contact.phone = this.formatPhone(field.Value); }
                    else if (!contact.phone2 && !this.isTheSamePhone(contact.phone, field.Value)) // contact.phone.toLowerCase() !== field.Value.toLowerCase())
                    { contact.phone2 = this.formatPhone(field.Value); }
                }
            }
            else if (field.Name === 'Twitter') {
                if (field.Value) {
                    //if (!contact.venues) { contact.venues = []; }
                    //contact.venues.push({ website: 'https://twitter.com/' + field.Value, type: 'social' });
                    this.addVenue(contact, { website: 'https://twitter.com/' + field.Value, type: 'social' });
                }
            }
            else if (field.Name === 'LinkedIn') {
                //if (field.Value)
                //{ contact.sourceurl = field.Value; }
                if (field.Value) {
                    this.addVenue(contact, { website: field.Value, type: 'social' });
                }
            }
            else if (field.Name === 'SocialVenue') {
                if (field.Value) {
                    //if (!contact.venues) { contact.venues = []; }
                    //contact.venues.push({ website: field.Value, type: 'social' });
                    this.addVenue(contact, { website: field.Value, type: 'social' });
                }
            }
            else if (field.Name === 'SourceUrl') {
                if (field.Value)
                { contact.sourceurl = field.Value; }
            }
            else if (field.Name === 'Contact') {
                if (field.Value)
                { this.scanText(field.Value, contact); }
            }
            else if (field.Name === 'Address') {
                if (field.Value && !contact.address1) {
                    contact.address1 = field.Value;
                    //TODO: Parse the address out

                    //contactUtility.address
                }
            }
            else if (field.Name === 'School') {
                if (field.Value) { contact.education = (contact.education || '') + field.Name + ': ' + field.Value + '\n'; storeUnstructuredData(); }
            } // Under "Educations"
            else if (field.Name === 'Degree') {
                if (field.Value) { contact.education = (contact.education || '') + field.Name + ': ' + field.Value + '\n'; storeUnstructuredData(); }
            } // Under "Educations"
            else if (field.Name === 'Tenior') {
                if (field.Value) { contact.experience = (contact.experience || '') + field.Name + ': ' + field.Value + '\n'; storeUnstructuredData(); }
            } // Under "Positions"
            else if (field.Name === 'TeniorLocation') {
                if (field.Value) { contact.experience = (contact.experience || '') + field.Name + ': ' + field.Value + '\n'; storeUnstructuredData(); }
            } // Under "Positions"
            else if (field.Name === 'Description') {
                if (field.Value) { contact.experience = (contact.experience || '') + field.Name + ': ' + field.Value + '\n'; storeUnstructuredData(); }
            } // Under "Positions"
            else if (field.Name === 'CompanyTitle') {
                if (field.Value) { contact.experience = (contact.experience || '') + field.Name + ': ' + field.Value + '\n'; storeUnstructuredData(); }
            }
            else {
                if (field.Value) {
                    console.log('Unsupported field', field.Name, angular.copy(field));
                    storeUnstructuredData();
                }
            }
        },

        isTheSamePhone: function (phone1, phone2) {
            if (!phone1 || !phone2)
            { return false; }

            var p1 = phone1.replace(/[^0-9]/ig, '');
            var p2 = phone2.replace(/[^0-9]/ig, '');

            if (p1.length === 11 && p1[0] === '1')
            { p1 = p1.substring(1); }
            if (p2.length === 11 && p2[0] === '1')
            { p2 = p2.substring(1); }

            console.log('COMPARE PHONES', p1, p2, p1 === p2, phone1, phone2);

            return p1 === p2;
        },

        formatPhone: function (phone) {

            if (!phone)
            { return ''; }

            var p = phone.replace(/[^0-9]/ig, '');

            if (p.length === 11 && p[0] === '1')
            { p = p.substring(1); }

            var s = phone;

            if (p.length === 10)
            { s = '(' + p.substring(0, 3) + ') ' + p.substring(3, 6) + '-' + p.substring(6); }

            console.log('FORMAT PHONES', phone, s);

            return s;

        },

        formatCountry: function (country) {

            if (!country)
            { return ''; }

            if (typeof country !== 'string')
            { return country; }

            var c = country.toLowerCase();

            if (c === 'united states' || c === 'usa' || c === 'u.s.' || c === 'u.s.a.' || c === 'united states of america') {
                country = 'US';
            }

            return country;
        },

        isTheSameFirstName: function (firstName1, firstName2) {

            var isTheSame = function (s1, s2) {

                s1 = s1.toLowerCase().trim();
                s2 = s2.toLowerCase().trim();

                if (s1 === s2) { return true; }

                var result = firstNameGraphDriver.compareFirstNames(s1, s2);
                return result;

                /*
        
                if (s1 === 'abraham' && s2 === 'abe') { return true; }
                else if (s1 === 'alan' && s2 === 'al') { return true; }
                else if (s1 === 'albert' && s2 === 'al') { return true; }
                else if (s1 === 'alexander' && s2 === 'alex') { return true; }
                else if (s1 === 'alexandra' && s2 === 'alex') { return true; }
                else if (s1 === 'alfred' && s2 === 'al') { return true; }
                else if (s1 === 'alice' && s2 === 'ali') { return true; }
                else if (s1 === 'alison' && s2 === 'ali') { return true; }
                else if (s1 === 'allan' && s2 === 'al') { return true; }
                else if (s1 === 'allen' && s2 === 'al') { return true; }
                else if (s1 === 'allison' && s2 === 'alli') { return true; }
                else if (s1 === 'allison' && s2 === 'allie') { return true; }
                else if (s1 === 'allyson' && s2 === 'ally') { return true; }
                else if (s1 === 'aloysius' && s2 === 'al') { return true; }
                else if (s1 === 'andrew' && s2 === 'andy') { return true; }
                else if (s1 === 'angela' && s2 === 'angie') { return true; }
                else if (s1 === 'ann' && s2 === 'annie') { return true; }
                else if (s1 === 'anne' && s2 === 'annie') { return true; }
                else if (s1 === 'anthony' && s2 === 'tony') { return true; }
                else if (s1 === 'archibald' && s2 === 'arch') { return true; }
                else if (s1 === 'archibald' && s2 === 'archie') { return true; }
                else if (s1 === 'arthur' && s2 === 'art') { return true; }
                else if (s1 === 'august' && s2 === 'auggie') { return true; }
                else if (s1 === 'august' && s2 === 'augie') { return true; }
                else if (s1 === 'augustus' && s2 === ' auggie') { return true; }
                else if (s1 === 'augustus' && s2 === 'augie') { return true; }
                else if (s1 === 'barbara' && s2 === 'babs') { return true; }
                else if (s1 === 'barbara' && s2 === 'barbie') { return true; }
                else if (s1 === 'barbara' && s2 === 'barb') { return true; }
                else if (s1 === 'benjamin' && s2 === 'benny') { return true; }
                else if (s1 === 'benjamin' && s2 === 'ben') { return true; }
                else if (s1 === 'bernard' && s2 === 'bernie') { return true; }
                else if (s1 === 'beverly' && s2 === 'bev') { return true; }
                else if (s1 === 'bill' && s2 === 'billy') { return true; }
                else if (s1 === 'bob' && s2 === 'bobby') { return true; }
                else if (s1 === 'bradley' && s2 === 'brad') { return true; }
                else if (s1 === 'burton' && s2 === 'burt') { return true; }
                else if (s1 === 'calvin' && s2 === 'cal') { return true; }
                else if (s1 === 'cassandra' && s2 === 'sandy') { return true; }
                else if (s1 === 'catherine' && s2 === 'cathy') { return true; }
                else if (s1 === 'charles' && s2 === 'chas') { return true; }
                else if (s1 === 'charles' && s2 === 'chuck') { return true; }
                else if (s1 === 'charles' && s2 === 'chucky') { return true; }
                else if (s1 === 'charles' && s2 === 'charlie') { return true; }
                else if (s1 === 'chester' && s2 === 'chet') { return true; }
                else if (s1 === 'chris' && s2 === 'chrissy') { return true; }
                else if (s1 === 'chuck' && s2 === 'chucky') { return true; }
                else if (s1 === 'cynthia' && s2 === 'cindy') { return true; }
                else if (s1 === 'dan' && s2 === 'danny') { return true; }
                else if (s1 === 'daniel' && s2 === 'danny') { return true; }
                else if (s1 === 'daniel' && s2 === 'dan') { return true; }
                else if (s1 === 'david' && s2 === 'davey') { return true; }
                else if (s1 === 'david' && s2 === 'davie') { return true; }
                else if (s1 === 'david' && s2 === 'dave') { return true; }
                else if (s1 === 'deborah' && s2 === 'deb') { return true; }
                else if (s1 === 'deborah' && s2 === 'debbie') { return true; }
                else if (s1 === 'dennis' && s2 === 'denny') { return true; }
                else if (s1 === 'dick' && s2 === 'dicky') { return true; }
                else if (s1 === 'don' && s2 === 'donny') { return true; }
                else if (s1 === 'don' && s2 === 'donnie') { return true; }
                else if (s1 === 'doug' && s2 === 'dougie') { return true; }
                else if (s1 === 'douglas' && s2 === 'doug') { return true; }
                else if (s1 === 'ed' && s2 === 'eddie') { return true; }
                else if (s1 === 'edgar' && s2 === 'eddie') { return true; }
                else if (s1 === 'edgar' && s2 === 'ed') { return true; }
                else if (s1 === 'edward' && s2 === 'eddie') { return true; }
                else if (s1 === 'edward' && s2 === 'ed') { return true; }
                else if (s1 === 'edwin' && s2 === 'eddie') { return true; }
                else if (s1 === 'edwin' && s2 === 'ed') { return true; }
                else if (s1 === 'elizabeth' && s2 === ' beth') { return true; }
                else if (s1 === 'elizabeth' && s2 === ' betsy') { return true; }
                else if (s1 === 'elizabeth' && s2 === ' betty') { return true; }
                else if (s1 === 'elizabeth' && s2 === ' libby') { return true; }
                else if (s1 === 'elizabeth' && s2 === ' liz') { return true; }
                else if (s1 === 'elizabeth' && s2 === 'beth') { return true; }
                else if (s1 === 'eugene' && s2 === 'gene') { return true; }
                else if (s1 === 'frances' && s2 === 'frannie') { return true; }
                else if (s1 === 'frances' && s2 === 'franny') { return true; }
                else if (s1 === 'frances' && s2 === 'fran') { return true; }
                else if (s1 === 'francine' && s2 === 'franny') { return true; }
                else if (s1 === 'francine' && s2 === 'fran') { return true; }
                else if (s1 === 'francis' && s2 === 'fran') { return true; }
                else if (s1 === 'fred' && s2 === 'freddie') { return true; }
                else if (s1 === 'fred' && s2 === 'freddy') { return true; }
                else if (s1 === 'frederic' && s2 === 'freddie') { return true; }
                else if (s1 === 'frederic' && s2 === 'freddy') { return true; }
                else if (s1 === 'frederic' && s2 === 'fred') { return true; }
                else if (s1 === 'frederick' && s2 === 'freddie') { return true; }
                else if (s1 === 'frederick' && s2 === 'freddy') { return true; }
                else if (s1 === 'frederick' && s2 === 'fred') { return true; }
                else if (s1 === 'gabriel' && s2 === 'gabe') { return true; }
                else if (s1 === 'gabriela' && s2 === 'gabbie') { return true; }
                else if (s1 === 'gabriella' && s2 === 'gabbie') { return true; }
                else if (s1 === 'gabrielle' && s2 === 'gabbie') { return true; }
                else if (s1 === 'geoffrey' && s2 === 'geoff') { return true; }
                else if (s1 === 'gerald' && s2 === ' gerry') { return true; }
                else if (s1 === 'gerald' && s2 === 'jerry') { return true; }
                else if (s1 === 'geraldine' && s2 === 'gerri') { return true; }
                else if (s1 === 'geraldine' && s2 === 'gerry') { return true; }
                else if (s1 === 'gordon' && s2 === 'gordy') { return true; }
                else if (s1 === 'gregory' && s2 === 'gregg') { return true; }
                else if (s1 === 'gregory' && s2 === 'greg') { return true; }
                else if (s1 === 'gwendolyn' && s2 === 'wendy') { return true; }
                else if (s1 === 'gwendolyn' && s2 === 'gwen') { return true; }
                else if (s1 === 'gwenyth' && s2 === 'gwen') { return true; }
                else if (s1 === 'harold' && s2 === 'harry') { return true; }
                else if (s1 === 'henry' && s2 === 'hank') { return true; }
                else if (s1 === 'herbert' && s2 === 'herb') { return true; }
                else if (s1 === 'jacob' && s2 === 'jake') { return true; }
                else if (s1 === 'jacqueline' && s2 === 'jackie') { return true; }
                else if (s1 === 'james' && s2 === 'jimmy') { return true; }
                else if (s1 === 'james' && s2 === 'jim') { return true; }
                else if (s1 === 'jefferson' && s2 === 'jeff') { return true; }
                else if (s1 === 'jeffery' && s2 === 'jeff') { return true; }
                else if (s1 === 'jeffrey' && s2 === 'jeff') { return true; }
                else if (s1 === 'jen' && s2 === 'jenny') { return true; }
                else if (s1 === 'jenifer' && s2 === 'jenny') { return true; }
                else if (s1 === 'jenifer' && s2 === 'jen') { return true; }
                else if (s1 === 'jennifer' && s2 === 'jenny') { return true; }
                else if (s1 === 'jennifer' && s2 === 'jen') { return true; }
                else if (s1 === 'jessica' && s2 === 'jessi') { return true; }
                else if (s1 === 'jessica' && s2 === 'jessie') { return true; }
                else if (s1 === 'jessica' && s2 === 'jess') { return true; }
                else if (s1 === 'jim' && s2 === 'jimmy') { return true; }
                else if (s1 === 'joe' && s2 === 'joey') { return true; }
                else if (s1 === 'john' && s2 === 'johnny') { return true; }
                else if (s1 === 'john' && s2 === 'jack') { return true; }
                else if (s1 === 'jonathan' && s2 === 'jon') { return true; }
                else if (s1 === 'jonathon' && s2 === 'jon') { return true; }
                else if (s1 === 'joseph' && s2 === 'joey') { return true; }
                else if (s1 === 'joseph' && s2 === 'joe') { return true; }
                else if (s1 === 'joshua' && s2 === 'josh') { return true; }
                else if (s1 === 'katherine' && s2 === 'kate') { return true; }
                else if (s1 === 'katherine' && s2 === 'kathy') { return true; }
                else if (s1 === 'katherine' && s2 === 'katie') { return true; }
                else if (s1 === 'katherine' && s2 === 'kat') { return true; }
                else if (s1 === 'ken' && s2 === 'kenny') { return true; }
                else if (s1 === 'kenneth' && s2 === 'kenny') { return true; }
                else if (s1 === 'kenneth' && s2 === 'ken') { return true; }
                else if (s1 === 'kimberly' && s2 === 'kim') { return true; }
                else if (s1 === 'kristen' && s2 === 'kris') { return true; }
                else if (s1 === 'kristin' && s2 === 'kris') { return true; }
                else if (s1 === 'kristina' && s2 === 'kristi') { return true; }
                else if (s1 === 'kristina' && s2 === 'kristy') { return true; }
                else if (s1 === 'kristina' && s2 === 'kris') { return true; }
                else if (s1 === 'kristine' && s2 === ' kristi') { return true; }
                else if (s1 === 'kristine' && s2 === ' kristy') { return true; }
                else if (s1 === 'kristine' && s2 === 'kris') { return true; }
                else if (s1 === 'kristofer' && s2 === 'kris') { return true; }
                else if (s1 === 'kristopher' && s2 === 'kris') { return true; }
                else if (s1 === 'laurence' && s2 === 'larry') { return true; }
                else if (s1 === 'lawrence' && s2 === 'larry') { return true; }
                else if (s1 === 'leonard' && s2 === 'lenny') { return true; }
                else if (s1 === 'leonard' && s2 === 'len') { return true; }
                else if (s1 === 'marcus' && s2 === 'marc') { return true; }
                else if (s1 === 'martin' && s2 === 'marty') { return true; }
                else if (s1 === 'marvin' && s2 === 'marv') { return true; }
                else if (s1 === 'matthew' && s2 === 'matt') { return true; }
                else if (s1 === 'megan' && s2 === 'meg') { return true; }
                else if (s1 === 'michael' && s2 === ' mic') { return true; }
                else if (s1 === 'michael' && s2 === ' mick') { return true; }
                else if (s1 === 'michael' && s2 === ' mickey') { return true; }
                else if (s1 === 'michael' && s2 === ' mikey') { return true; }
                else if (s1 === 'michael' && s2 === 'mike') { return true; }
                else if (s1 === 'mick' && s2 === 'mickey') { return true; }
                else if (s1 === 'mike' && s2 === 'mikey') { return true; }
                else if (s1 === 'nathan' && s2 === 'nate') { return true; }
                else if (s1 === 'nathaniel' && s2 === 'nat') { return true; }
                else if (s1 === 'nathaniel' && s2 === 'nate') { return true; }
                else if (s1 === 'nicholas' && s2 === 'nicky') { return true; }
                else if (s1 === 'nicholas' && s2 === 'nick') { return true; }
                else if (s1 === 'nichole' && s2 === 'nicki') { return true; }
                else if (s1 === 'nichole' && s2 === 'nicky') { return true; }
                else if (s1 === 'nichole' && s2 === 'nikki') { return true; }
                else if (s1 === 'nick' && s2 === 'nicky') { return true; }
                else if (s1 === 'nicole' && s2 === 'nicky') { return true; }
                else if (s1 === 'nicole' && s2 === 'nikki') { return true; }
                else if (s1 === 'nicole' && s2 === 'nicki') { return true; }
                else if (s1 === 'norbert' && s2 === 'norb') { return true; }
                else if (s1 === 'norman' && s2 === 'norm') { return true; }
                else if (s1 === 'pamela' && s2 === 'pam') { return true; }
                else if (s1 === 'patricia' && s2 === 'patty') { return true; }
                else if (s1 === 'patricia' && s2 === 'tricia') { return true; }
                else if (s1 === 'patricia' && s2 === 'trish') { return true; }
                else if (s1 === 'patricia' && s2 === 'pat') { return true; }
                else if (s1 === 'patrick' && s2 === 'pat') { return true; }
                else if (s1 === 'philip' && s2 === 'phil') { return true; }
                else if (s1 === 'phillip' && s2 === 'phil') { return true; }
                else if (s1 === 'randall' && s2 === 'randy') { return true; }
                else if (s1 === 'raymond' && s2 === 'ray') { return true; }
                else if (s1 === 'rebecca' && s2 === 'becki') { return true; }
                else if (s1 === 'rebecca' && s2 === 'becky') { return true; }
                else if (s1 === 'reginald' && s2 === 'reg') { return true; }
                else if (s1 === 'reginald' && s2 === 'reggie') { return true; }
                else if (s1 === 'rich' && s2 === 'richie') { return true; }
                else if (s1 === 'richard' && s2 === 'dicky') { return true; }
                else if (s1 === 'richard' && s2 === 'rich') { return true; }
                else if (s1 === 'richard' && s2 === 'richie') { return true; }
                else if (s1 === 'richard' && s2 === 'rick') { return true; }
                else if (s1 === 'richard' && s2 === 'ricky') { return true; }
                else if (s1 === 'richard' && s2 === 'dick') { return true; }
                else if (s1 === 'rick' && s2 === 'ricky') { return true; }
                else if (s1 === 'rob' && s2 === ' robbie') { return true; }
                else if (s1 === 'rob' && s2 === 'robby') { return true; }
                else if (s1 === 'robert' && s2 === ' bobby') { return true; }
                else if (s1 === 'robert' && s2 === ' rob') { return true; }
                else if (s1 === 'robert' && s2 === ' robbie') { return true; }
                else if (s1 === 'robert' && s2 === ' robby') { return true; }
                else if (s1 === 'robert' && s2 === ' robt') { return true; }
                else if (s1 === 'robert' && s2 === 'bob') { return true; }
                else if (s1 === 'rodney' && s2 === 'rod') { return true; }
                else if (s1 === 'roger' && s2 === 'rog') { return true; }
                else if (s1 === 'ron' && s2 === ' ronnie') { return true; }
                else if (s1 === 'ron' && s2 === 'ronny') { return true; }
                else if (s1 === 'ronald' && s2 === 'ronnie') { return true; }
                else if (s1 === 'ronald' && s2 === 'ronny') { return true; }
                else if (s1 === 'ronald' && s2 === 'ron') { return true; }
                else if (s1 === 'russell' && s2 === 'russ') { return true; }
                else if (s1 === 'sam' && s2 === 'sammy') { return true; }
                else if (s1 === 'samantha' && s2 === 'sam') { return true; }
                else if (s1 === 'samuel' && s2 === 'sammy') { return true; }
                else if (s1 === 'samuel' && s2 === 'sam') { return true; }
                else if (s1 === 'sandra' && s2 === 'sandy') { return true; }
                else if (s1 === 'stephanie' && s2 === 'steph') { return true; }
                else if (s1 === 'stephen' && s2 === 'steve') { return true; }
                else if (s1 === 'susan' && s2 === 'susie') { return true; }
                else if (s1 === 'susan' && s2 === 'sue') { return true; }
                else if (s1 === 'susan' && s2 === 'suzi') { return true; }
                else if (s1 === 'susan' && s2 === 'suzie') { return true; }
                else if (s1 === 'suzanne' && s2 === 'sue') { return true; }
                else if (s1 === 'suzanne' && s2 === 'suzi') { return true; }
                else if (s1 === 'suzanne' && s2 === 'suzie') { return true; }
                else if (s1 === 'theodore' && s2 === ' theo') { return true; }
                else if (s1 === 'theodore' && s2 === 'ted') { return true; }
                else if (s1 === 'thomas' && s2 === 'tom') { return true; }
                else if (s1 === 'thomas' && s2 === 'tommy') { return true; }
                else if (s1 === 'thomas' && s2 === 'thom') { return true; }
                else if (s1 === 'tim' && s2 === 'timmy') { return true; }
                else if (s1 === 'timothy' && s2 === 'timmy') { return true; }
                else if (s1 === 'timothy' && s2 === 'tim') { return true; }
                else if (s1 === 'tom' && s2 === 'tommy') { return true; }
                else if (s1 === 'tricia' && s2 === 'trish') { return true; }
                else if (s1 === 'trisha' && s2 === 'trish') { return true; }
                else if (s1 === 'victor' && s2 === 'vic') { return true; }
                else if (s1 === 'victoria' && s2 === 'vicky') { return true; }
                else if (s1 === 'walter' && s2 === 'walt') { return true; }
                else if (s1 === 'walter' && s2 === 'wally') { return true; }
                else if (s1 === 'wesley' && s2 === 'wes') { return true; }
                else if (s1 === 'william' && s2 === 'billy') { return true; }
                else if (s1 === 'william' && s2 === 'will') { return true; }
                else if (s1 === 'william' && s2 === 'willie') { return true; }
                else if (s1 === 'william' && s2 === 'willy') { return true; }
                else if (s1 === 'william' && s2 === 'wm') { return true; }
                else if (s1 === 'william' && s2 === 'bill') { return true; }
                else if (s1 === 'zachary' && s2 === 'zack') { return true; }
                else if (s1 === 'zachary' && s2 === 'zach') { return true; }
        
                return false;*/
            };

            if (!firstName1 || !firstName2)
            { return false; }

            return isTheSame(firstName1, firstName2) || isTheSame(firstName2, firstName1);
        },

        addVenue: function (contact, venue) {
            const preserveCase = true;
            contact.venues = contact.venues || [];
            if (venue && venue.website) {
                venue.website = self.fixUrl(venue.website, preserveCase);
                var i = contact.venues.length;
                while (i--) {
                    if ((contact.venues[i].website || '').toLowerCase() === (venue.website || '').toLowerCase()) { return; }
                }
                contact.venues.push(venue);
            }
        },

        getVenue: function (contact, filterBy) {
            if (contact && contact.venues) {
                var i;
                for (i = 0; i < contact.venues.length; i++) {
                    var w = contact.venues[i].website;
                    if (w && w.indexOf(filterBy) >= 0) {

                        if (filterBy === 'linkedin.com') {
                            if (!self.isLinkedInIndividualProfile(w)) {
                                continue;
                            }
                        } else if (filterBy === 'twitter.com') {
                            if (!self.isTwitterIndividualProfile(w, contact.company, contact.first, contact.last)) {
                                continue;
                            }
                        } else if (filterBy === 'facebook.com') {
                            if (!self.isFacebookIndividualProfile(w, contact.company, contact.first, contact.last)) {
                                continue;
                            }
                        }

                        return w;
                    }
                }
            }
            return null;
        },

        daysBetween: function (date1, date2, keepsign) {

            // The number of milliseconds in one day
            var ONE_DAY = 1000 * 60 * 60 * 24;

            // Convert both dates to milliseconds
            var date1_ms = date1.getTime();
            var date2_ms = date2.getTime();

            // Calculate the difference in milliseconds
            var difference_ms;

            if (keepsign) {
                difference_ms = date1_ms - date2_ms;
            } else {
                difference_ms = Math.abs(date1_ms - date2_ms);
            }

            // Convert back to days and return
            return Math.round(difference_ms / ONE_DAY);

        },

        duplicateOf: function (candidate, contacts) {
            var i, j, contact,
                p1, p2, s1, s2,
                dup = null;

            var isIndividualProfile = function (url) {
                // Is this source URL an indinividual profile
                if (!url) { return false; }
                if (url.indexOf('#SELECTION') > 0) { return false; }
                if (url.indexOf('inkedin.com/in/') > 0) { return true; }
                if (url.indexOf('inkedin.com/pub/') > 0) { return true; }
                if (url.indexOf('inkedin.com/profile/') > 0) { return true; }
                return false;
            };

            var testUrls = function (url1, url2) {

                // For known sites with individual profiles
                if (isIndividualProfile(url1) && isIndividualProfile(candidate.sourceurl)) {

                    p1 = url1.indexOf('.com');
                    p2 = url2.indexOf('.com');

                    if (p1 > 0 && p2 > 0) {

                        s1 = url1.substring(p1);
                        s2 = url2.substring(p2);

                        if (s1.length > 9 && s1 === s2)
                        { return true; }

                    } else {

                        s1 = url1;
                        s2 = url2;

                        if (s1.length > 9 && s2.length > 9 && (s1.indexOf(s2) >= 0 || s2.indexOf(s1) >= 0))
                        { return true; }

                    }

                }

                return false;
            };

            for (i = 0; i < contacts.length; i++) {

                contact = contacts[i];

                if (contact.id > 0 && contact.id === candidate.id) { continue; }



                if (contact.last && contact.first && candidate.last && candidate.first) {

                    if (candidate.last === contact.last && this.isTheSameFirstName(candidate.first, contact.first)) {

                        if ((candidate.email && candidate.email === contact.email) ||
                            (candidate.email2 && candidate.email2 === contact.email) ||
                            (candidate.email && candidate.email === contact.email2) ||
                            (candidate.email2 && candidate.email2 === contact.email2) ||
                            (candidate.phone && candidate.phone === contact.phone) ||
                            (candidate.phone2 && candidate.phone2 === contact.phone) ||
                            (candidate.phone && candidate.phone === contact.phone2) ||
                            (candidate.phone2 && candidate.phone2 === contact.phone2) ||
                            (candidate.website && candidate.website === contact.website) ||
                            (candidate.company && candidate.company === contact.company) ||
                            (candidate.title && candidate.title === contact.title) ||
                            (!(candidate.email || candidate.email2 || candidate.phone || candidate.phone2 || candidate.website || candidate.company || candidate.title))
                            ) {

                            dup = contact;
                            if (debug) { console.log('dup! (1)', angular.copy(contact), angular.copy(candidate)); }
                            break;
                        }
                    }
                }



                if (!dup && ((contact.sourceurl || contact.venues) && (candidate.sourceurl || candidate.venues))) {

                    var l1 = [];
                    var l2 = [];

                    if (contact.sourceurl) { l1.push(contact.sourceurl); }
                    if (contact.venues) {
                        j = contact.venues.length;
                        while (j--)
                        { l1.push(contact.venues[j].website); }
                    }

                    if (candidate.sourceurl) { l2.push(candidate.sourceurl); }
                    if (candidate.venues) {
                        j = candidate.venues.length;
                        while (j--)
                        { l2.push(candidate.venues[j].website); }
                    }

                    for (var i1 = 0; i1 < l1.length; i1++) {
                        for (var i2 = 0; i2 < l2.length; i2++) {
                            if (testUrls(l1[i1], l2[i2])) {
                                dup = contact;
                                if (debug) { console.log('dup! (2)', angular.copy(contact), angular.copy(candidate)); }
                                break;
                            }
                        }
                        if (dup)
                        { break; }
                    }

                }

            }

            return dup;
        },

        validateEmail: function (email) {
            var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
            return re.test(email);
        }

    };

    return self;
}]);

'use strict';

/* global angular: false */

angular.module('utilities')
.factory('chromeUtility', [function () {
    var debug = 'chromeUtility->'; //debug = false;
    var store = {};
    var authToken = '';
    var cachedFields = {};

    var sendMessage = function (tab, method, data, successCallback, failureCallback) {
        if (debug) { console.log(debug + 'sendMessage...', { tab: tab, method: method, data: data }); }
        var timer = setTimeout(function () {
            if (debug) { console.log(debug + 'sendMessage: Timeout!'); }
            try { failureCallback('Something went wrong (Timeout). Please reload the page and try again.'); } catch (e) { }
        }, 5000);
        chrome.tabs.sendMessage(tab.id, { method: method, data: (data || {}) }, function (response) {
            if (debug) { console.log(debug + 'sendMessage: ', response); }
            clearTimeout(timer);
            if (response) {
                try { successCallback(response); } catch (e) { }
            } else {
                try { failureCallback('Please reload this page. Your Capture version has been upgraded since this page was last loaded.'); } catch (e) { }
            }

        });
    };

    var service = {

        isLoggedIn: function () {
            if (!store.authToken) { return false; }
            return (store.authToken.length > 0);
        },


        //  Login to the service
        login: function (interactive, successCallback, failureCallback) {

            if (debug) { console.log(debug + 'interactive?', interactive); }

            if (this.isLoggedIn()) {
                if (debug) { console.log(debug + 'already logged in'); }
                try { successCallback(store.authToken); } catch (e) { }
                return;
            }

            if (!chrome.identity) {
                console.log('ERROR chromeUtility.login->interactive: chrome.identity is not defined');
                try { failureCallback('Cannot access Chrome Identity API'); } catch (e) { } return;
            }

            chrome.identity.getAuthToken({ 'interactive': interactive }, function (token) {
                if (debug) { console.log(debug + 'token?', token); }
                if (token) {
                    store.authToken = token;
                    try { successCallback(store.authToken); } catch (e) { }
                    //return;
                } else {
                    if (chrome.runtime.lastError && chrome.runtime.lastError.message) {
                        console.log('ERROR in chrome.identity.getAuthToken', chrome.runtime.lastError.message);
                        try { failureCallback(chrome.runtime.lastError.message); } catch (e) { }
                    } else {
                        console.log('ERROR in chrome.identity.getAuthToken');
                        try { failureCallback('Unable to retrieve token'); } catch (e) { }
                    }

                }
            });
        },

        logOut: function () {
            store.authToken = '';
        },

        //  Getter
        getAuthToken: function () {
            return store.authToken;
        },
        setAuthToken: function (token) {
            store.authToken = token;
        },


        //  Get key/value from cloud
        getField: function (key, successCallback, failureCallback) {

            if (Array.isArray(key)) {

                console.log('**************** GET (array) ', key);
                var res = {};
                var notfoundKeys = [];

                var syncCallback = function (response) {

                    if (chrome.runtime.lastError) {
                        console.log('********************* ERROR reading from Chrome Sync storage:', { key: notfoundKeys, error: chrome.runtime.lastError });
                        try { failureCallback(chrome.runtime.lastError); } catch (e) { }
                        return;
                    }

                    for (var prop in response) {
                        if (response.hasOwnProperty(prop)) {
                            res.prop = response[prop];
                            cachedFields[prop] = response[prop];
                        }
                    }

                    try { successCallback(res); } catch (e) { }
                };

                for (var i = 0, arrayLength = key.length; i < arrayLength; i++) {
                    var k = key[i];
                    if (cachedFields[k]) {
                        res.k = cachedFields[k];
                    } else {
                        notfoundKeys.push(k);
                    }
                }

                if (notfoundKeys.length === 0) {
                    try { successCallback(res); } catch (e) { }
                } else {
                    if (!chrome.storage) {
                        try { failureCallback('Cannot access Chrome Cloud Storage'); } catch (e) { }
                        return;
                    }
                    // Not all keys were resolved locally --> Get data from the cloud
                    chrome.storage.sync.get(notfoundKeys, syncCallback);
                }


                return;
            }

            console.log('**************** GET ' + key);
            //  Try cache first to avoid all the crazy bandwidth
            if (cachedFields[key]) {
                try { successCallback(cachedFields[key]); } catch (e) { }
                return;
            }

            if (!chrome.storage)
            { try { failureCallback('Cannot access Chrome Cloud Storage'); } catch (e) { } return; }

            //  Get it from the cloud
            chrome.storage.sync.get(key, function (response) {
                if (chrome.runtime.lastError) {
                    console.log('********************* ERROR reading from Chrome Sync storage:', { key: key, error: chrome.runtime.lastError });
                    try { failureCallback(chrome.runtime.lastError); } catch (e) { }
                } else {
                    cachedFields[key] = response[key];
                    try { successCallback(response[key]); } catch (e) { }
                }
            });

        },
        //  Set key/value from cloud
        setField: function (key, data, successCallback, failureCallback) {
            console.log('**************** SET ' + key, angular.copy(data));
            var obj = {};
            obj[key] = data;
            //  Save it in cache for later use
            cachedFields[key] = data;

            if (!chrome.storage)
            { try { failureCallback('Cannot access Chrome Cloud Storage'); } catch (e) { } return; }

            chrome.storage.sync.set(obj, function () {
                if (chrome.runtime.lastError) {
                    console.log('********************* ERROR saving to Chrome Sync storage:', { obj: obj, error: chrome.runtime.lastError });
                    try { failureCallback(chrome.runtime.lastError); } catch (e) { }
                } else {
                    try { successCallback(); } catch (e) { }
                }
            });
        },

        //  Get key/value from local storage
        getFieldLocal: function (key, successCallback, failureCallback) {
            //  Try cache first to avoid all the crazy bandwidth
            if (cachedFields[key]) {
                try { successCallback(cachedFields[key]); } catch (e) { }
                return;
            }
            if (!chrome.storage)
            { try { failureCallback('Cannot access Chrome Local Storage'); } catch (e) { } return; }
            //  Get it from the local storage
            chrome.storage.local.get(key, function (response) {
                cachedFields[key] = response[key];
                try { successCallback(response[key]); } catch (e) { }
            });

        },
        //  Set key/value from cloud
        setFieldLocal: function (key, data, successCallback, failureCallback) {

            var obj = {};
            obj[key] = data;
            //  Save it in cache for later use
            cachedFields[key] = data;

            if (!chrome.storage)
            { try { failureCallback('Cannot access Chrome Local Storage'); } catch (e) { } return; }

            chrome.storage.local.set(obj, function () {
                if (chrome.runtime.lastError) {
                    if (debug) { console.log('Chrome set error:', { obj: obj, error: chrome.runtime.lastError }); }
                    try { failureCallback(); } catch (e) { }
                } else {
                    try { successCallback(); } catch (e) { }
                }
            });
        },

        //  Completely clears a key in chrome sync storage
        clearField: function (key) {
            this.setField(key, {});
        },

        getTabs: function (successCallback, failureCallback) {
            if (debug) { console.log(debug + 'getTabs...'); }
            chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
                function (tabs) {
                    if (debug) { console.log(debug + 'getTabs:', tabs); }
                    if (!tabs || !tabs.length) {
                        try { failureCallback('Chrome has no open tabs.'); } catch (e) { }
                    } else {
                        try { successCallback(tabs); } catch (e) { }
                    }
                });
        },
        getTab: function (successCallback, failureCallback) {
            if (debug) { console.log(debug + 'getTab...'); }
            this.getTabs(function (tabs) {
                if (debug) { console.log(debug + 'getTab:', tabs[0]); }
                try { successCallback(tabs[0]); } catch (e) { }
            }, failureCallback);
        },
        tabLoaded: function (successCallback, failureCallback) {
            if (debug) { console.log(debug + 'tabLoaded...'); }
            this.getTab(function (tab) {
                sendMessage(tab, 'ping', null, function (response) {
                    if (debug) { console.log(debug + 'tabLoaded:', response); }
                    try { successCallback(tab); } catch (e) { }
                }, failureCallback);
            }, failureCallback);
        },


        getCaptureInput: function (options, successCallback, failureCallback) {
            options = options || {};
            if (debug) { console.log(debug + 'getCaptureInput...', options); }
            var service = this;
            this.tabLoaded(function (tab) {
                if (options.selection) {
                    service.getTabSelection(tab, successCallback, failureCallback);
                } else {
                    service.getTabPageParent(tab, successCallback, failureCallback);
                }
            }, failureCallback);
        },

        getTabSelection: function (tab, successCallback, failureCallback) {
            if (debug) { console.log('Retrieving capture input selection...'); }
            var service = this;
            chrome.tabs.sendRequest(tab.id, { method: 'getSelection' },
               function (response) {
                   if (response && response.data && response.data.length > 1) {
                       if (debug) { console.log('Capture input selection found!'); }
                       successCallback({ data: response.data, url: tab.url + '#SELECTION' });
                       return;
                   }

                   failureCallback('Selection is empty or has no recognizable contact data');
                   return;
                   //service.getTabPageParent(tab, successCallback, failureCallback);
               }
            );
        },
        getTabPageParent: function (tab, successCallback, failureCallback) {
            if (debug) { console.log('Retrieving capture input parent page...'); }
            var service = this;
            chrome.tabs.sendRequest(tab.id, { method: 'getParentPage' }, function (response) {
                if (response && response.data && response.data.length > 1) {
                    if (debug) { console.log('Capture input parent page found!'); }
                    successCallback({ data: response.data, url: tab.url });
                    return;
                } else {
                    service.getTabPage(tab, successCallback, failureCallback);
                }

            });
        },

        getTabPage: function (tab, successCallback, failureCallback) {
            if (debug) { console.log('Retrieving capture input page...'); }
            chrome.tabs.sendRequest(tab.id, { method: 'getPage' }, function (response) {
                if (response && response.data && response.data.length > 1) {
                    if (debug) { console.log('Capture input page found!'); }
                    try { successCallback({ data: response.data, url: tab.url }); } catch (e) { }
                    return;
                } else {
                    if (debug) { console.log('page is not empty'); }
                    failureCallback('You must reload the page before it can be captured!');
                }

            });
        },

        doPatternCapture: function (patterns, successCallback, failureCallback) {

            if (debug) { console.log('Calling Pattern Capture...'); }
            var service = this;
            //chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT },
            //   function (tabs) {
            //       if(debug) {console.log('Received tabs:',tabs);}
            //       if (!tabs || tabs.length === 0) {
            //           if(debug) {console.log('no tabs');}
            //           failureCallback('You have no open tabs to capture.');
            //           return;
            //       }
            //       // call pattern capture
            //       chrome.tabs.sendRequest(tabs[0].id, { method: 'doPatternCapture', patterns: patterns }, function (response) {
            //           if (response && response.data) {
            //               if (debug) { console.log('Pattern Capture executed!', angular.copy(response)); }
            //               try { successCallback(response); } catch (e) { console.log(e); failureCallback(e.message); }
            //               return;
            //           } else {
            //               if (debug) { console.log('Pattern Capture returned no contacts', response); }
            //               failureCallback('Cannot capture this page.');
            //           }

            //       });

            //   });

            if (debug) { console.log(debug + 'doPatternCapture...', { patterns: patterns }); }
            this.tabLoaded(function (tab) {
                sendMessage(tab, 'patternParser', { patterns: patterns, options: { Retrieve: true } }, function (response) {
                    if (debug) { console.log(debug + 'doPatternCapture:', response); }
                    if (!response.layout) {
                        try { failureCallback('No pattern exists for this site.'); } catch (e) { }
                        return;
                    }
                    try { successCallback({ data: response }); } catch (e) { }
                }, failureCallback);

            }, failureCallback);
        },
        openLink: function (url, inCurrentTab) {
            if (!inCurrentTab)
            { chrome.tabs.create({ url: url }, function () { }); }
            else
            {
                chrome.tabs.query({ windowId: chrome.windows.WINDOW_ID_CURRENT, active: true }, function (tabs) {
                    if (!tabs || tabs.length === 0)
                    { chrome.tabs.create({ url: url }, function () { }); }
                    else
                    { chrome.tabs.update(tabs[0].id, { url: url }, function () { }); }
                });

            }
        }



    };
    return service;

}]);

'use strict';

/* global angular: false */

angular.module('utilities')
.factory('environmentUtility', ['$http', '$rootScope', function ($http, $rootScope) {
    //  Private
    var debug = false;
    var loaded = false;
    var loadCallbacks = [];
    var environmentJsonPath = 'components/environment.json';
    var environment = { release: 'local' };

    //  Execute load callbacks
    var loadedCallbacks = function(){
        for(var index in loadCallbacks){
            var callback = loadCallbacks[index];
            if(callback){ callback(); }
        }
    };

    var load = function(){
        if(debug){console.log('environmentUtility.load...:', environmentJsonPath);}
        $http.get(environmentJsonPath)
            .success(function(response){
                if(response) {
                    environment = response;
                    $rootScope.environment = environment;
                }
                if(debug){console.log('environmentUtility.load:', environment);}
                loaded = true;
                loadedCallbacks();
            });
    };


    var getReleaseIndexes = function( targetReleases ){
        var targetIndexes = [];
        for(var index in targetReleases){
            targetIndexes.push(environment.releases.indexOf(targetReleases[index]));
        }
        return targetIndexes;
    };

    load();

    //  Public
    var utility = {
        onLoaded: function(callback){
            if(loaded){
                try{callback();}catch(e){}
                return;
            }
            loadCallbacks.push(callback);
        },

        getRelease: function(){
            return environment.release;
        },
        getReleases: function(){
            return angular.copy(environment.releases);
        },
        isRelease: function(targetRelease){
            return (this.getRelease() === targetRelease);
        },
        releaseIsAbove: function(targetRelease){
            var indexes = getReleaseIndexes([targetRelease, this.getRelease()]);
            return (indexes[1] > indexes[0]);
        },
        releaseIsAtOrAbove: function(targetRelease){
            var indexes = getReleaseIndexes([targetRelease, this.getRelease()]);
            return (indexes[1] >= indexes[0]);
        }

    };
    return utility;
}]);

'use strict';

/* global angular: false */

angular.module('utilities')
.factory('settingsUtility', [function () {
   

    var debug = 'settings-utility.js->';

    return {

        readSettings: function (newSettings, defaultTarget) {

            var settings = null;
                 
            try {

                if (debug) {
                    console.log(debug + 'loaded settings', angular.copy(newSettings));
                }

                settings = angular.copy(newSettings);

                //var save = false;

                if (!settings) {
                    console.log('WARNING! Settings set to default value.');
                    settings = { target: defaultTarget || 'sf', exclusions: false, notifications: true, notificationsRestrictedDomain: 'crm.dynamics.com\nmarketo.com\npcrecruiter.net\nsalesforce.com\nzoho.com', openAfterExport: 'Always', deleteAfterExport: 'Never' };
                    //save = true;
                }

                if (!settings.target) {
                    console.log('WARNING! Target set to default value (Salesforce).');
                    settings.target = 'sf';
                    //save = true;
                }

                if (!settings.targetParams) {
                    settings.targetParams = {};
                    //save = true;
                } else if (Array.isArray(settings.targetParams)) {
                    // Convert from array to object
                    console.log('**** CONVERT TARGET PARAMS');
                    var ms = angular.copy(settings.targetParams.ms);
                    var zh = angular.copy(settings.targetParams.zh);
                    var pp = angular.copy(settings.targetParams.pp);
                    settings.targetParams = {};
                    settings.targetParams.ms = ms;
                    settings.targetParams.zh = zh;
                    settings.targetParams.pp = pp;
                }

                if (settings.targetUrl) {
                    console.log('**** CONVERT TARGET URL');
                    // convert to new way
                    settings.targetParams.ms = { url: settings.targetUrl };

                    try {
                        delete settings.targetUrl;
                    } catch (e) { }
                }

                if (debug) { console.log(debug + 'read settings', angular.copy(settings)); }

            } catch (e) {
                console.log('ERROR in loadSettings', e.message);
            }

            return settings;
        }

    };
}]);

'use strict';

/* global angular: false */

//     Create a namespace for our utilities (defined in untilites sub folder)
var utilitiesModule = angular.module('stores', []);
'use strict';

/* global angular: false */
//  The partials for this are in main.html

angular.module('stores')
.factory('patternStore', ['$http', 'chromeUtility', 'environmentUtility', function ($http, chromeUtility, environmentUtility) {
    var debug = 'pattern-store.js->';
    var local = {};

    var self = {
        getFactoryPatterns: function (source, successCallback, errorCallback) {
            var returnPatterns = function () {
                try { successCallback(angular.copy(local.factoryPatterns)); } catch (e) { }
            };

            //try { if (!source) { source = this.getDefaultSource(); } }
            //catch (e) { console.log(debug + 'Error getting default source ' + e.message); }

            if (!source) {
                console.log('ERROR getting patterns: source is null');
                return [];
            }

            var cachePrevention = '?ts=';
            try {
                var ts = (new Date()).getMilliseconds();
                cachePrevention += ts.toString();
            } catch (e) {
                console.log('***** ERsROR in get cachePrevention param', e.message);
                cachePrevention += '0';
            }

            var url = source.Url;
            try {
                var defaultSources = self.getDefaultSources();
                for (var i = 0; i < defaultSources.length; i++) {
                    if (url === defaultSources[i].Url) {
                        url += cachePrevention;
                        break;
                    }
                }
            } catch (e) {
                console.log('***** ERROR in set cachePrevention param', e.message);
            } 

            if (debug) { console.log(debug + 'Loading patterns from ' + url); }

            $http.get(url)
                .success(function (data) {
                    // valid?
                    try {

                        if (debug) { console.log(debug + 'Success loading patterns', data); }

                        if (!(Array.isArray(data) || typeof data === 'object')) // html?
                        { data = JSON.parse(data); }

                        angular.forEach(data, function (value, key) {
                            value.SourceName = source.Name;
                        });

                        local.factoryPatterns = data;
                        returnPatterns();

                    } catch (e) {
                        if (debug) { console.log(debug + 'Error parsing patterns', e); }
                        try { errorCallback(e.message); } catch (e) { }
                    }

                    //if (!data || data.indexOf('"UrlPatterns"') < 0)
                    //{ errorCallback(); }

                })
                .error(function (e) {
                    if (debug) { console.log(debug + 'Error loading patterns', e); }
                    try { errorCallback(); } catch (e) { }
                });
        },
        getDefaultSources: function () {
            var sources = [];
            var isProduction = false;
            var isBeta = false;

            try { isProduction = environmentUtility.isRelease('production'); }
            catch (e) { console.log(debug + 'ERROR getting isProduction' + e.message); }

            try { isBeta = environmentUtility.isRelease('beta'); }
            catch (e) { console.log(debug + 'ERROR getting isBeta' + e.message); }

            if (isProduction || isBeta)
            {
                sources.push({ Url: 'http://www.broadlook.com/capturecorepatterns1.0.txt', Name: 'Core' });
                sources.push({ Url: 'https://capture-patterns.s3.amazonaws.com/capture-community-patterns-1.0.txt', Name: 'Community' });
            }
            else
            {
                sources.push({ Url: 'http://www.broadlook.com/capturecorepatternsalpha.txt', Name: 'Core-Alpha' });
                sources.push({ Url: 'https://capture-patterns.s3.amazonaws.com/capture-community-patterns-alpha.txt', Name: 'Community-Alpha' });
            }

            return sources;
        },
        getPatterns: function (successCallback, errorCallback) {
            var returnPatterns = function () {
                try { successCallback(angular.copy(local.patterns), local.patterns_ts); } catch (e) { }
            };
            if (local.patterns) {
                returnPatterns();
                return;
            }
            chrome.storage.local.get(['patterns','patterns_ts'], function (response) {
                local.patterns = response.patterns;
                if(response.patterns_ts > 0)
                { local.patterns_ts = new Date(response.patterns_ts); }
                else 
                { local.patterns_ts = null; }
                returnPatterns();
            });
        },
        setPatterns: function (patterns) {
            var ts = (new Date()).getTime();
            chrome.storage.local.set({ patterns: patterns, patterns_ts: ts }, function () {
                if (chrome.runtime.lastError) {
                    console.log('Chrome set error:', { obj: { patterns: patterns }, error: chrome.runtime.lastError });
                }
            });

            local.patterns = angular.copy(patterns);
        },

        getSources: function (successCallback, errorCallback) {
            var returnSources = function () {
                try { successCallback(angular.copy(local.sources)); } catch (e) { }
            };
            if (local.sources) {
                returnSources();
                return;
            }
            chromeUtility.getField('patternSources', function (data) {
                local.sources = data;
                returnSources();
            }, function () {
                console.log('Chrome get error:', { error: chrome.runtime.lastError });
                local.sources = [];
                returnSources();
            });

        },
        setSources: function (sources) {
            chromeUtility.setField('patternSources', sources, function () { }, function () {
                console.log('Chrome set error:', { obj: { sources: sources }, error: chrome.runtime.lastError });
            });
            local.sources = angular.copy(sources);
        },
    };

    return self;
}]);

'use strict';

/* global angular: false */
/* global $: false */

angular.module('modals', []).factory('modals', ['$uibModal', '$q', function ($uibModal, $q) {

    //  Modal class constructor (creates a class for a modal)
    function createModal(controller, template) {
        var modal = function (modalParameters) {
            modalParameters = modalParameters || {};
            return function (modalInput) {
                var deferred = $q.defer();

                //  https://angular-ui.github.io/bootstrap/#/modal
                var modalInstance = $uibModal.open({
                    backdrop: modalParameters.backdrop || 'static',
                    template: template,
                    controller: ['$scope', '$uibModalInstance', 'modalParameters', 'modalInput', controller],
                    resolve: {
                        modalParameters: function () { return modalParameters; },
                        modalInput: function () { return modalInput; }
                    }
                });

                modalInstance.result.then(deferred.resolve, deferred.reject);

                return deferred.promise;
            };
        };

        return modal;
    }

    //  Basic controller for use with simple templates.  To create your own controller, use this as a base
    function basicController($scope, $uibModalInstance, modalParameters, modalInput) {
        $scope.modalParameters = modalParameters;
        $scope.modalInput = modalInput;
        $scope.ok = function (result) { $uibModalInstance.close(result); };
        $scope.cancel = function () { $uibModalInstance.dismiss('cancel'); };
    }

    //  Wrap template creation (utility)
    function createModalTemplate(header, body, footer) {
        header = (header ? '<div class="modal-header">' + header + '</div>' : '');
        body = (body ? '<div class="modal-body">' + body + '</div>' : '');
        footer = (footer ? '<div class="modal-footer">' + footer + '</div>' : '');
        return header + body + footer;
    }

    //  Some standard template parts
    var headerTitle = '<h3 class="modal-title">{{modalParameters.title}}</h3>';
    var bodyInput = '{{modalInput}}';
    var footerAcceptReject = '<button class="btn btn-primary" type="button" ng-click="ok(true)">Accept</button><button class="btn btn-default" type="button" ng-click="ok(false)">Reject</button>';
    var footerConfirmCancel = '<button class="btn btn-primary" type="button" ng-click="ok(modalResult)">Confirm</button><button class="btn btn-default" type="button" ng-click="cancel()">Cancel</button>';
    var footerCancel = '<button class="btn btn-default" type="button" ng-click="cancel()">Cancel</button>';
    var footerOk = '<button class="btn btn-default" type="button" ng-click="ok(modalInput)">OK</button>';


    //  Example template
    var exampleTemplate = `
        <ul ng-init="modalResult = modalInput[0]">
            <li ng-repeat="item in modalInput" >
                <a href="" ng-click="$parent.modalResult = item">{{ item }}</a>
            </li>
        </ul>
        Selected: <b>{{ modalResult }}</b>
    `;

    var exportTargetSelectorBody = `
        <div class="row" ng-repeat="target in modalInput">
            <div class ="col-xs-12"><p><div class ="btn btn-primary btn-block" ng-click="$parent.ok(target.target)">{{target.label}}</div></p></div>
        </div>
        <div class="row" ng-show="modalInput.length === 1">
            <div class ="col-xs-12"><p class ="text-muted" style="padding: 24px">Tip: Capture can export directly to your CRM.Please <a href="#/settings" ng-click="$parent.cancel()">visit Settings page</a> to set it up.</p></div>
        </div>
    `;

    var eulaSelectorBody = `

        <div ng-include="'components/modals/eula.html'"></div>

        `;
   
    //  Create each modal class here
    var factory = {
        example: createModal(basicController, createModalTemplate(headerTitle, exampleTemplate, footerConfirmCancel)),
        //  Simple confirmation
        confirm: createModal(basicController, createModalTemplate(headerTitle, null, footerConfirmCancel)),
        //  Simple alert
        alert: createModal(basicController, createModalTemplate(headerTitle, null, footerConfirmCancel)),
        //  Alert that displays the chain data as the body
        alertContent: createModal(basicController, createModalTemplate(headerTitle, bodyInput, footerOk)),
        exportTargetSelector: createModal(basicController, createModalTemplate(headerTitle, exportTargetSelectorBody, footerCancel)),
        eulaSelector: createModal(basicController, createModalTemplate(headerTitle, eulaSelectorBody, footerAcceptReject))
    };

    //  Usage:
    //      var items = ['item1', 'item2', 'item3'];
    //      $q.when(items)
    //          .then(modals.example({title:'This is an example modal'}))
    //          .then(someSuccessFunction)
    //          .catch(someCancelFunction);

    return factory;
}]);
'use strict';

/* global angular: false */
/* global $: false */

//angular.module('dialogs', [])
//.controller('dialogs', ['$scope', 'dialogs',
//    function ($scope, dialogs) {
//        //$scope.templates = dialogs.getTemplates();
//    }]);

//     Setup a namespace for our webservices (defined in webservices sub folder)
angular.module('dialogs', [])
.controller('dialogs', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        $scope.templates = dialogs.getTemplates();
    }])
.factory('dialogs', [function () {
    var debug = true;
    var templates = [];
    var dialogHelper = function( template ){
        templates.push(template);
        return {

            callback: {
                callbacks: {},
                add: function(key, callback){
                    this.callbacks[key] = callback;
                },
                execute: function(key, data){
                    try{ this.callbacks[key](data); }catch(e){}
                },
                reset: function(){
                    this.callbacks = {};
                },
                exists: function(key){
                    return this.callbacks[key];
                }

            },
            template: template,
            events: {
                show: function(){},
                hide: function(){},
                update: function(){}
            },
            modal: {
                show: function(selector){
                    $(selector).modal('show');
                },
                hide: function(selector){
                    $(selector).modal('hide');
                }
            },
            refresh: function(scope){
                if(!scope){ return; }
                if(!scope.$$phase) { scope.$apply(); }
            },

            show: function (data) { return this.events.show(data); },
            update: function (data) { return this.events.update(data); },
            hide: function(){ this.events.hide(); }
        };
    };

    var factory = {
        refreshScope: function(scope){ if (!scope.$$phase) { scope.$apply(); } },
        getTemplates: function() { return templates; },
        createHelper: function(template) { return dialogHelper(template); },

        //  -------- Add dialogs here --------  //
        alert: dialogHelper('components/dialogs/alert/view.html'),
        progress: dialogHelper('components/dialogs/progress/view.html'),
        text: dialogHelper('components/dialogs/text/view.html'),
        busy: dialogHelper('components/dialogs/busy/view.html'),
        confirm: dialogHelper('components/dialogs/confirm/view.html'),
        lookup: dialogHelper('components/dialogs/lookup/view.html'),
        list: dialogHelper('components/dialogs/list/view.html'),
        map: dialogHelper('components/dialogs/map/view.html'),
        select: dialogHelper('components/dialogs/select/view.html'),

        capture: {
            list: dialogHelper('components/dialogs/capture/list/view.html'),
            clipboard: dialogHelper('components/dialogs/capture/clipboard/view.html')
        },

        searches: {
            edit: dialogHelper('components/dialogs/searches/edit/view.html'),
            run:  dialogHelper('components/dialogs/searches/run/view.html')
        },

        contacts: {
            edit: dialogHelper('components/dialogs/contacts/edit/view.html'),
        }

    };
    return factory;
}]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.alert', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.alert;

        $scope.pre = false;

        //  Register available callback methods
        dialog.ok = function(callback){
            dialog.callback.add('ok', callback);
            return dialog;
        };

        //  Register show and hide methods
        dialog.events.show = function (message) {
            if (message && message.text) {
                $scope.message = message.text;
                $scope.pre = message.pre || false;
            }
            else {
                $scope.message = message;
                $scope.pre = false;
            }
            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };

        dialog.events.hide = function(){
            dialog.modal.hide($scope.modalSelector);
        };

        //  Expose callbacks to UI
        $scope.ok = function(){
            dialog.events.hide();
            dialog.callback.execute('ok');
        };
    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.progress', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.progress;

        $scope.min = 0;
        $scope.max = 100;
        $scope.value = 0;
        $scope.percent = 0;

        var calc = function () {
            var v = ($scope.value - $scope.min) / ($scope.max - $scope.min) * 100;
            $scope.percent = Math.round(v);
        };

        dialog.cancel = function(callback){
            dialog.callback.add('cancel', callback);
            return dialog;
        };

        dialog.events.show = function(data){
            $scope.message = data.message;
            $scope.min = (data.min ? data.min : 0);
            $scope.max = (data.max ? data.max : 100);
            $scope.value = (data.value ? data.value : 0);
            calc();
            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };

        dialog.events.update = function (data) {
            console.log('Updating progress', angular.copy(data));
            if (data.message) { $scope.message = data.message; }
            if (data.min) { $scope.min = data.min; }
            if (data.max) { $scope.max = data.max; }
            if (data.value) { $scope.value = data.value; }
            calc();
            dialog.refresh($scope);
        };

        dialog.events.hide = function(){
            dialog.modal.hide($scope.modalSelector);
        };

        $scope.cancel = function(){
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };
    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.busy', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.busy;

        dialog.visible = false;

        var debug = 'dialogs/busy/controller.js->'; debug = false;

        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };

        $scope.hasCallback = function (key) {
            return dialog.callback.exists(key);
        };

        dialog.events.show = function (message) {
            //console.warn('busy-show');
            $scope.message = message;
            if (debug) { console.log(debug + 'show->', $scope.message); }
            //if (dialog.visible) {
            //    dialog.visible = false;
            //    dialog.modal.hide($scope.modalSelector);
            //}
            if (!dialog.visible) {
                dialog.modal.show($scope.modalSelector);
                dialog.visible = true;
                //if (!$scope.$$phase) { $scope.$apply(); }
            }
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };

        dialog.events.hide = function () {
            //console.warn('busy-hide');
            if (debug) { console.log(debug + 'hide->', $scope.message); }
            if (dialog.visible) {
                dialog.visible = false;
                dialog.modal.hide($scope.modalSelector);
                //if (!$scope.$$phase) { $scope.$apply(); }
            }
        };

        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };
    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.text', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.text;

        //  Register available callback methods
        dialog.confirm = function (callback) {
            dialog.callback.add('confirm', callback);
            return dialog;
        };
        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };
        //  Register show and hide methods
        dialog.events.show = function (data) {
            $scope.message = data.message;
            $scope.value = (data.value ? data.value : '');
            $scope.placeholder = (data.placeholder ? data.placeholder : '');
            $scope.max = (data.max ? data.max : 100);
            $scope.required = (data.required ? data.required : false);
            $scope.readOnly = (data.readOnly ? data.readOnly : false);
            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();
            window.setTimeout(function () {
                var el = document.getElementById('dialog-text-input');
                if (el) { el.focus(); }
            }, 500);
            return dialog;
        };

        dialog.events.hide = function () {
            dialog.modal.hide($scope.modalSelector);
        };

        $scope.satisfied = function () {
            if ($scope.required && !$scope.value) {
                $scope.errorMessage = 'Value is required';
                return false;
            }
            $scope.errorMessage = '';
            return true;
        };
        //  Expose callbacks to UI
        $scope.confirm = function () {
            if ($scope.required && !$scope.value) { return $scope.required; }
            dialog.events.hide();
            dialog.callback.execute('confirm', $scope.value);
        };
        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };
    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.confirm', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.confirm;

        //  Register available callback methods
        dialog.confirm = function(callback){
            dialog.callback.add('confirm', callback);
            return dialog;
        };
        dialog.cancel = function(callback){
            dialog.callback.add('cancel', callback);
            return dialog;
        };

        //  Register show and hide methods
        dialog.events.show = function(message){
            $scope.message = message;
            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };
        dialog.events.hide = function(){
            dialog.modal.hide($scope.modalSelector);
        };

        //  Expose callbacks to UI
        $scope.confirm = function(){
            dialog.events.hide();
            dialog.callback.execute('confirm');
        };
        $scope.cancel = function(){
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };
    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.lookup', ['$scope', '$timeout', 'dialogs', 'chromeUtility', 'googleService', 'contactUtility',
    function ($scope, $timeout, dialogs, chromeUtility, googleService, contactUtility) {
        var dialog = dialogs.lookup;

        $scope.exportService = null;
        $scope.items = []; // [{label: '', link: ''}]
        $scope.searching = false;
        $scope.selectedIndex = 0;
        $scope.value = 0;
        $scope.allowNew = false;
        $scope.required = false;
        $scope.lookupDefinition = null;

        //  Register available callback methods
        dialog.select = function (callback) {
            dialog.callback.add('select', callback);
            return dialog;
        };
        //dialog.new = function (callback) {
        //    dialog.callback.add('new', callback);
        //    return dialog;
        //};
        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };


        //  Register show and hide methods
        dialog.events.show = function (data) {

            console.log('Show lookup for ', data);

            if (data.lookup) {
                $scope.message = data.lookup.message || ('Select value');
                $scope.type = data.lookup.type;
            } else {
                $scope.message = '';
                $scope.type = '';
            }

            $scope.message2 = (data.lookup && data.lookup.message2) || '';
            $scope.selectedIndex = 0;
            $scope.selectButtonLabel = (data.lookup && data.lookup.selectButtonLabel) || 'Continue';

            $scope.allowNew = data.lookup && data.lookup.allowNew;
            $scope.required = data.lookup && data.lookup.required;
            $scope.showGoogle = data.lookup && data.lookup.showGoogle;

            $scope.lookupDefinition = data.lookup;

            $scope.value = data.value;
            $scope.exportService = data.exportService;
            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();

            $scope.initChoices();

            //if (!$scope.value)
            //    $scope.value = '';


            $scope.find();


            return dialog;
        };
        dialog.events.hide = function () {
            dialog.modal.hide($scope.modalSelector);
        };

        $scope.initChoices = function () {
            $scope.items = [];
            if (!$scope.required) {
                $scope.items.push({
                    label:
                        $scope.lookupDefinition.noLabel ? $scope.lookupDefinition.noLabel :
                        ($scope.lookupDefinition.picklist ? 'No value' : 'No ' + ($scope.type || 'value')),
                    link: null,
                    id: null,
                    newName: null
                });
            }
            if ($scope.allowNew) {
                $scope.items.push({
                    label: 'Create new ' + $scope.type + ': ' + $scope.value,
                    link: null,
                    id: null,
                    newName: $scope.value
                });
            }
        };

        $scope.find = function () {

            $scope.searching = true;
            if (!$scope.$$phase) { $scope.$apply(); }
            $scope.initChoices();

            var offset = $scope.items.length;

            if ($scope.lookupDefinition.fixedlist) {
                $scope.searching = false;
                var k = 0;
                var list = $scope.lookupDefinition.fixedlist;
                while (k < list.length) {
                    var lookupObject = { label: list[k].label, id: list[k].value };
                    $scope.items.push(lookupObject);

                    if ($scope.value && lookupObject.id === $scope.value.id)
                    { $scope.selectedIndex = k + offset; }

                    k++;
                }
                if (!$scope.$$phase) { $scope.$apply(); }
                return;
            }

            if ($scope.lookupDefinition.picklist) {

                $scope.exportService.getFields($scope.lookupDefinition.type, function (list) {
                    console.log('getFields response', angular.copy(list));
                    $scope.searching = false;
                    var i = list.length;
                    while (i--) {
                        if (list[i].name === $scope.lookupDefinition.crmProperty) {
                            var j = 0;

                            while (j < list[i].values.length) {
                                var lookupObject = { label: list[i].values[j].label, id: list[i].values[j].value };

                                if ($scope.value && lookupObject.id === $scope.value.id)
                                { $scope.selectedIndex = j + offset; }

                                $scope.items.push(lookupObject);
                                j++;
                            }
                        }
                    }

                    if (!$scope.$$phase) { $scope.$apply(); }

                }, function (error) {
                    console.log('getFields error', error);
                    $scope.searching = false;
                    dialogs.alert.show(error);
                });

                return;
            }

            var successCallback = function (records) {
                console.log('RECORDS', records);
                $scope.searching = false;
                $scope.errorMessage = '';

                angular.forEach(records, function (value, index) {
                    var lookupObject = $scope.exportService.toLookupObject(value, $scope.type);
                    $scope.items.push(lookupObject);
                });

                //$scope.items = //[{ id: 1, label: 'Test', link: 'http://broadlook.com' }, { id: 2, label: 'Test 2', link: 'http://broadlook.com' }];
                if (!$scope.$$phase) { $scope.$apply(); }
            };

            var failCallback = function (msg) {
                $scope.items = [];
                $scope.searching = false;
                $scope.errorMessage = msg;

                if (!$scope.$$phase) { $scope.$apply(); }
            };


            var query = {};
            query[$scope.lookupDefinition.appProperty] = ($scope.value || '');
            //{ company: $scope.value }
            $scope.exportService.findRecord($scope.type, query, [$scope.lookupDefinition.appProperty], successCallback, failCallback);
        };

        //  Expose callbacks to UI
        $scope.select = function (selectedValue) {
            dialog.events.hide();
            dialog.callback.execute('select', selectedValue);
        };
        //$scope.new = function () {
        //    dialog.events.hide();
        //    dialog.callback.execute('new');
        //};
        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };

        $scope.openLink = function (link) {
            if (!link)
            { return; }
            if (link.indexOf('://') < 0)
            { link = 'http://' + link; }
            chromeUtility.openLink(link, true);
        };

        $scope.setValue = function (value) {
            console.log('Setting value: ', value);
            $scope.selectedIndex = value;
        };

        var isCompanyWebsite = function (url, title, searchstring) {
            var res = true;


            if (!url) {
                res = false;
            }

            // Second level domain
            if (res) {
                var domain = contactUtility.getDomain(url);
                var path = url.trim().toLowerCase().split(domain)[1];
                console.log('*** domain ', domain, path);
                if (path.length > 1) { res = false; }
            }


            console.log('*** www? ', res, url, title, searchstring);


            return res;
        };

        var parseGoogle = function () {

            chromeUtility.getCaptureInput({}, function (response) {
                console.log('Input:', response);
                var html = response.data;
                //var url = response.url;

                var results = googleService.parseGoogle(html);

                console.log('***** RESULT:', results);

                var searchstring = $scope.value;

                for (var i = 0; i < results.length; i++) {

                    var url = results[i].sourceurl;
                    var title = results[i].sourcetitle;

                    if (!isCompanyWebsite(url, title, searchstring)) {
                        continue;
                    }

                    var domain = contactUtility.getDomain(url);

                    $scope.items.push({
                        id: i,
                        label: domain + ' (' + title + ')',
                        link: domain
                    });
                }

                if (!$scope.$$phase) { $scope.$apply(); }

                //if (linkedinService.isProfile(html)) {
                //    console.log('Parsing linkedin....');
                //    successCallback(linkedinService.parseProfile(html, url));

                //} else if (googleService.isGoogle(html, url)) {
                //    console.log('Parsing google....');
                //    successCallback(googleService.parseGoogle(html));

                //} else {
                //    console.log('Calling parsing service...');
                //    parsingService.capture(html, url, 'text/html', successCallback, failureCallback);
                //}

            }, function (error) {

                console.log('ERROR::', error);
                //failureCallback(error);
            });


        };

        $scope.searchWeb = function () {

            var url = 'https://google.com/search?num=10&q=' + encodeURIComponent($scope.value || '');

            chromeUtility.openLink(url, true);

            $timeout(parseGoogle, 3000);
        };

        //environmentUtility.onLoaded(function () {
        //    $scope.isLocal = environmentUtility.isRelease('local');
        //    $scope.isAlpha = environmentUtility.isRelease('alpha');
        //    $scope.isBeta = environmentUtility.isRelease('beta');
        //    $scope.isProduction = environmentUtility.isRelease('production');
        //});

    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.list', ['$scope', 'dialogs', 'chromeUtility',
    function ($scope, dialogs, chromeUtility) {
        var dialog = dialogs.list;

        $scope.data = { setName: [], setPattern: [] }; 

        //  Register available callback methods
        dialog.select = function (callback) {
            dialog.callback.add('select', callback);
            return dialog;
        };

        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };

        //  Register show and hide methods
        dialog.events.show = function (data) {

            console.log('Show list', data);

            $scope.data = data;

            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();

            return dialog;
        };

        dialog.events.hide = function () {
            dialog.modal.hide($scope.modalSelector);
        };

        var removeA = function (arr) {
            var what, a = arguments, L = a.length, ax;
            while (L > 1 && arr.length) {
                what = a[--L];
                while ((ax = arr.indexOf(what)) !== -1) {
                    arr.splice(ax, 1);
                }
            }
            return arr;
        };

        $scope.deletePattern = function (item) {
            //$scope.data.setPattern.splice(index, 1);
            removeA($scope.data.setPattern, item);
        };

        $scope.deleteName = function (item) {
            //$scope.data.setName.splice(index, 1);
            removeA($scope.data.setName, item);
        };

        //  Expose callbacks to UI
        $scope.select = function () {
            dialog.events.hide();
            dialog.callback.execute('select', $scope.data);
        };

        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };

    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.map', ['$scope', 'dialogs', 'chromeUtility',
    function ($scope, dialogs, chromeUtility) {
        var dialog = dialogs.map;
        $scope.dialog = dialog;

        $scope.data = null;
        //$scope.map = null;
        //$scope.captureMap = null;
        $scope.defaultCaptureMap = {
            fields: [

                { captureField: 'address1', label: 'Address Line 1' },
                { captureField: 'address2', label: 'Address Line 2' },
                { captureField: 'address', label: 'Address Line 1 and 2' },
                { captureField: 'bio', label: 'Bio' },
                { captureField: 'city', label: 'City' },
                { captureField: 'company', label: 'Company Name' },
                { captureField: 'country', label: 'Country' },
                { captureField: 'countryCode', label: 'Country Code' },
                { captureField: 'email', label: 'Email' },
                { captureField: 'emailverbool', label: 'Email Verified' },
                { captureField: 'email2', label: 'Email 2' },
                { captureField: 'email2verbool', label: 'Email 2 Verified' },
                { captureField: 'employees', label: 'Employees (Range)' },
                { captureField: 'employeesAvg', label: 'Employees (Number)' },
                { captureField: 'facebook', label: 'Facebook' },
                { captureField: 'first', label: 'First Name' },
                { captureField: 'full', label: 'Full Name' },
                { captureField: 'industry', label: 'Industry' },
                { captureField: 'jobtitle', label: 'Job Title' },
                { captureField: 'last', label: 'Last Name' },
                { captureField: 'linkedin', label: 'LinkedIn' },
                { captureField: 'middle', label: 'Middle Name' },
                { captureField: 'phone', label: 'Phone' },
                { captureField: 'phone2', label: 'Phone 2' },
                { captureField: 'revenue', label: 'Revenue (Range)' },
                { captureField: 'revenueAvg', label: 'Revenue (Number)' },
                { captureField: 'state', label: 'State' },
                { captureField: 'stateCode', label: 'State Code' },
                { captureField: 'twitter', label: 'Twitter' },
                { captureField: 'website', label: 'Website' },
                { captureField: 'zip', label: 'Zip Code' },

                //{ captureField: 'first', label: 'First Name' },
                //{ captureField: 'middle', label: 'Middle Name' },
                //{ captureField: 'last', label: 'Last Name' },
                //{ captureField: 'full', label: 'Full Name' },
                //{ captureField: 'jobtitle', label: 'Job Title' },
                //{ captureField: 'company', label: 'Company Name' },
                //{ captureField: 'email', label: 'Email' },
                //{ captureField: 'email2', label: 'Email 2' },
                //{ captureField: 'phone', label: 'Phone' },
                //{ captureField: 'phone2', label: 'Phone 2' },
                //{ captureField: 'website', label: 'Website' },
                //{ captureField: 'bio', label: 'Bio' },
                //{ captureField: 'address', label: 'Address Line 1 and 2' },
                //{ captureField: 'address1', label: 'Address Line 1' },
                //{ captureField: 'address2', label: 'Address Line 2' },
                //{ captureField: 'city', label: 'City' },
                //{ captureField: 'state', label: 'State' },
                //{ captureField: 'stateCode', label: 'State Code' },
                //{ captureField: 'zip', label: 'Zip Code' },
                //{ captureField: 'country', label: 'Country' },
                //{ captureField: 'countryCode', label: 'Country Code' },
                //{ captureField: 'facebook', label: 'Facebook' },
                //{ captureField: 'linkedin', label: 'LinkedIn' },
                //{ captureField: 'twitter', label: 'Twitter' },
                //{ captureField: 'industry', label: 'Industry' },
                //{ captureField: 'employees', label: 'Employees (Range)' },
                //{ captureField: 'employeesAvg', label: 'Employees (Number)' },
                //{ captureField: 'revenue', label: 'Revenue' },
                //{ captureField: 'emailver', label: 'Email 1 Verified' },
                //{ captureField: 'email2ver', label: 'Email 2 Verified' }
            ]
        };

        //  Register available callback methods
        dialog.save = function (callback) {
            dialog.callback.add('save', callback);
            return dialog;
        };

        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };


        //  Register show and hide methods
        dialog.events.show = function (data) {

            console.log('Show map for ', data);

            // data structure:
            // 
            //  Current list of fields in CRM:
            //  data.availableFields [ { label, name, required }]
            //
            //  Previously saved map:
            //  data.entity { 
            //      label,
            //      map: { 
            //          fields: [ 
            //              target: { label, name, required }, 
            //              source: { type: 'capture|lookup|text', value: {...}}
            //          ] 
            //      } 
            //  }
            //
            // type: 'capture', value: { captureField: 'first', label: 'First Name' }
            // type: 'text', value: { text: 'Added by Capture! v1.2' }
            // type: 'lookup',   value: { appProperty: 'company', message: 'Select Account', type: 'Account', required: false, allowNew: true }

            $scope.label = angular.copy(data.entity.label);


            var fields = [];

            if (data.entity.map) {
                fields = angular.copy(data.entity.map.fields);
            }

            console.log('fields before step 1', angular.copy(fields));

            var i, j, found;

            // Step 1: Delete fields that are not in CRM anymore and update those that are.

            i = fields.length;
            while (i--) {

                if (fields[i].target && !fields[i].target.required) {
                    fields[i].target.required = false;
                }

                // Skip actions (e.g. Add to Campaign)
                //if (fields[i].target && fields[i].target.name && fields[i].target.name.length > 3 && fields[i].target.name.substring(0, 3) === '___') {
                if (fields[i].target && fields[i].target.type && fields[i].target.type === 'action') {
                    continue;
                }

                found = false;

                j = data.availableFields.length;
                while (j--) {
                    if (fields[i].target && fields[i].target.name === data.availableFields[j].name) {
                        found = true;
                        // Update definition
                        fields[i].target = data.availableFields[j];
                        break;
                    }
                }

                //if (!found) {
                //    // delete not found field
                //    fields.splice(i, 1);
                //}

            }

            console.log('fields after step 1', angular.copy(fields));

            // Step 2: Add fields that are not on the map

            i = data.availableFields.length;
            while (i--) {

                found = false;

                j = fields.length;
                while (j--) {
                    if (fields[j].target.name === data.availableFields[i].name) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    // add not found field
                    fields.push({ target: data.availableFields[i], source: { type: '', value: null } });
                }

            }

            console.log('fields after step 2', angular.copy(fields));

            $scope.fields = fields;
            $scope.availableEntities = data.availableEntities;

            //$scope.captureMap = angular.copy(captureMap);
            //$scope.map = angular.copy(data.entity.map.fields);

            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();

            return dialog;
        };
        dialog.events.hide = function () {
            dialog.modal.hide($scope.modalSelector);
        };


        //  Expose callbacks to UI
        $scope.save = function () {
            dialog.events.hide();
            console.log('map->save', $scope.captureMap, $scope.data);
            var f = [];
            var i = 0;
            while (i < $scope.fields.length) {
                if ($scope.fields[i].source.type) {
                    f.push($scope.fields[i]);
                }
                i++;
            }
            console.log('Mapped fields', angular.copy(f));
            dialog.callback.execute('save', f);
        };

        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };

    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.select', ['$scope', '$timeout', 'dialogs', 'chromeUtility', 'googleService', 'contactUtility',
    function ($scope, $timeout, dialogs, chromeUtility, googleService, contactUtility) {
        var dialog = dialogs.select;

        $scope.message = null;
        $scope.description = null;
        $scope.exportService = null;
        $scope.items = []; // [{label: '', link: ''}]
        $scope.searching = false;
        $scope.selectedIndex = 0;
        $scope.value = '';
        $scope.allowNew = false;
        $scope.required = false;
        $scope.lookupDefinition = null;

        $scope.currentPage = 0;
        $scope.pageSize = 5;
        $scope.numberOfPages = function () {
            return Math.ceil($scope.items.length / $scope.pageSize);
        };

        //  Register available callback methods
        dialog.select = function (callback) {
            dialog.callback.add('select', callback);
            return dialog;
        };
        dialog.select2 = function (callback) {
            dialog.callback.add('select2', callback);
            return dialog;
        };
        //dialog.new = function (callback) {
        //    dialog.callback.add('new', callback);
        //    return dialog;
        //};
        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };


        //  Register show and hide methods
        dialog.events.show = function (data) {
            const functionName = 'Show Select Dialog';
            try {
                console.log(functionName, data);

                $scope.message = data.message || 'Select values';
                $scope.description = data.description || '';
                $scope.selectButtonLabel = data.selectButtonLabel || 'Continue';
                $scope.items = data.items; // { value: '', selected: '' }

                dialog.modal.show($scope.modalSelector);
                dialog.refresh($scope);
                dialog.callback.reset();

            } catch (e) {
                console.log(functionName, e.message);
            }


            //if (data.lookup) {
            //    $scope.message = data.lookup.message || ('Select value');
            //    $scope.type = data.lookup.type;
            //    $scope.description = data.lookup.description || '';
            //} else {
            //    $scope.message = '';
            //    $scope.type = '';
            //    $scope.description = '';
            //}

            //$scope.selectedIndex = 0;
            //$scope.selectButtonLabel = (data.lookup && data.lookup.selectButtonLabel) || 'Continue';
            //$scope.selectButton2Label = (data.lookup && data.lookup.selectButton2Label) || '';

            //$scope.allowNew = data.lookup && data.lookup.allowNew;
            //$scope.required = data.lookup && data.lookup.required;
            //$scope.showGoogle = data.lookup && data.lookup.showGoogle;

            //$scope.lookupDefinition = data.lookup;

            //$scope.value = data.value || '';
            //$scope.website = data.website || ''; // Hack for account lookup
            //$scope.exportService = data.exportService;
            //dialog.modal.show($scope.modalSelector);
            //dialog.refresh($scope);
            //dialog.callback.reset();

            //$scope.initChoices();

            ////if (!$scope.value)
            ////    $scope.value = '';


            //$scope.find();


            return dialog;
        };
        dialog.events.hide = function () {
            dialog.modal.hide($scope.modalSelector);
        };

        $scope.initChoices = function () {
            $scope.items = [];
            if (!$scope.required) {
                $scope.items.push({
                    label:
                        $scope.lookupDefinition.noLabel ? $scope.lookupDefinition.noLabel :
                        ($scope.lookupDefinition.picklist ? 'No value' : 'No ' + ($scope.type || 'value')),
                    link: null,
                    id: null,
                    newName: null
                });
            }
            if ($scope.allowNew) {
                $scope.items.push({
                    label: 'Create new ' + $scope.type + ': ' + $scope.value,
                    link: null,
                    id: null,
                    newName: $scope.value
                });
            }
        };

        $scope.find = function () {

            $scope.searching = true;
            if (!$scope.$$phase) { $scope.$apply(); }
            $scope.initChoices();

            var offset = $scope.items.length;

            if ($scope.lookupDefinition.fixedlist) {
                $scope.searching = false;
                var k = 0;
                var list = $scope.lookupDefinition.fixedlist;
                while (k < list.length) {
                    var lookupObject = { label: list[k].label, id: list[k].value, link: list[k].link };
                    $scope.items.push(lookupObject);

                    if (lookupObject.id === $scope.value)
                    { $scope.selectedIndex = k + offset; }

                    k++;
                }
                if (!$scope.$$phase) { $scope.$apply(); }
                return;
            }

            if ($scope.lookupDefinition.picklist) {

                $scope.exportService.getFields($scope.lookupDefinition.type, function (list) {
                    console.log('getFields response', angular.copy(list));
                    $scope.searching = false;
                    var i = list.length;
                    while (i--) {
                        if (list[i].name === $scope.lookupDefinition.crmProperty) {
                            var j = 0;

                            while (j < list[i].values.length) {
                                var lookupObject = { label: list[i].values[j].label, id: list[i].values[j].value };

                                if (lookupObject.id === $scope.value)
                                { $scope.selectedIndex = j + offset; }

                                $scope.items.push(lookupObject);
                                j++;
                            }
                        }
                    }

                    if (!$scope.$$phase) { $scope.$apply(); }

                }, function (error) {
                    console.log('getFields error', error);
                    $scope.searching = false;
                    dialogs.alert.show(error);
                });

                return;
            }

            var successCallback = function (records) {
                console.log('RECORDS', records);
                $scope.searching = false;
                $scope.errorMessage = '';

                angular.forEach(records, function (value, index) {
                    var lookupObject = $scope.exportService.toLookupObject(value, $scope.type);
                    $scope.items.push(lookupObject);
                });

                //$scope.items = //[{ id: 1, label: 'Test', link: 'http://broadlook.com' }, { id: 2, label: 'Test 2', link: 'http://broadlook.com' }];
                if (!$scope.$$phase) { $scope.$apply(); }
            };

            var failCallback = function (msg) {
                $scope.items = [];
                $scope.searching = false;
                $scope.errorMessage = msg;

                if (!$scope.$$phase) { $scope.$apply(); }
            };


            var query = {};
            query[$scope.lookupDefinition.appProperty] = ($scope.value || '');
            if ($scope.website) {
                query.website = $scope.website;
            }
            //{ company: $scope.value }
            $scope.exportService.findRecord($scope.type, query, [$scope.lookupDefinition.appProperty], successCallback, failCallback);
        };

        //  Expose callbacks to UI
        $scope.select = function () {
            var value = $scope.items;
            console.log('Select Dialog Result > ', value);
            dialog.events.hide();
            dialog.callback.execute('select', value);
        };

        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };

        $scope.getLink = function (link) {
            if (link && link.indexOf('://') < 0)
            { link = 'http://' + link; }
            return link;
        };

        $scope.setValue = function (value) {
            console.log('Setting value: ', value);
            $scope.selectedIndex = value;
        };

        



    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.capture.list', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.capture.list;

        dialog.visible = false;

        var debug = 'dialogs/capture/list/controller.js->';

        dialog.ok = function (callback) {
            dialog.callback.add('ok', callback);
            return dialog;
        };

        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };

        dialog.events.show = function (data) {

            $scope.mergeDups = true;

            if (data) {
                //$scope.sameCompany = false;
                $scope.message = data.message;
                $scope.options = data.options;
                $scope.selected = data.selected;
                $scope.sameCompany = data.sameCompany || false;
                $scope.companyName = data.companyName;
                $scope.companyNames = data.companyNames;
                $scope.companyURL = data.companyURL;
                $scope.mergeDups = data.mergeDups || true;
            }

            if (!dialog.visible) {
                dialog.modal.show($scope.modalSelector);
                dialog.visible = true;
            }
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };

        dialog.events.hide = function () {
            dialog.visible = false;
            dialog.modal.hide($scope.modalSelector);
        };

        $scope.newListName = '';

        $scope.setName = function (newName) {
            $scope.companyName = newName;
        };

        $scope.ready = function () {

            if (!dialog.visible) { return false; }

            var res = true;

            if ($scope.selected === '<New List>') {

                if (('' + $scope.newListName) === '') {
                    res = false;
                } else {
                    angular.forEach($scope.options, function (option, index) {
                        if (option === $scope.newListName)
                        { res = false; }
                    });
                }
            }

            //if (debug) { console.log(debug + 'ready->', res); }

            return res;
        };

        $scope.ok = function(){
            var result = {
                option: $scope.selected,
                mergeDups: $scope.mergeDups
            };

            if (result.option === '<New List>')
            { result.option = $scope.newListName; }

            if($scope.sameCompany){
                result.companyName = $scope.companyName;
                result.companyURL = $scope.companyURL;
            }
            dialog.events.hide();

            dialog.callback.execute('ok',  result);
        };

        $scope.cancel = function () {
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };

    }]);
'use strict';

/* global angular: false */

angular.module('dialogs')
.controller('dialogs.capture.clipboard', ['$scope', 'dialogs',
    function ($scope, dialogs) {
        var dialog = dialogs.capture.clipboard;

        dialog.confirm = function (callback) {
            dialog.callback.add('confirm', callback);
            return dialog;
        };
        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };

        dialog.events.show = function(clipboardData, htmlFormatting){
            $scope.clipboardData = clipboardData;
            $scope.htmlFormatting = htmlFormatting;
            dialog.modal.show($scope.modalSelector);
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };

        dialog.events.hide = function(){
            dialog.modal.hide($scope.modalSelector);
        };

        $scope.confirm = function(){
            var result = {
                data: $scope.clipboardData,
                htmlFormatting: $scope.htmlFormatting
            };
            dialog.events.hide();
            dialog.callback.execute('confirm',  result);
        };
        $scope.cancel = function(){
            dialog.events.hide();
            dialog.callback.execute('cancel');
        };
    }]);
'use strict';

/* global angular: false */
/* global jQuery: false */

//angular.module('captureApp')
angular.module('dialogs')
.controller('searches.edit', ['$scope', 'searchesService','dialogs',
    function ($scope, searchesService, dialogs) {
        var dialog = dialogs.searches.edit;

        //  Show and hide
        var show = function(){ dialog.modal.show($scope.modalSelector); };
        var hide = function(){ dialog.modal.hide($scope.modalSelector); };

        //  Some stuff
        var getEngine = function(url, defaultEngine){
            for(var index in searchesService.engines){
                if (url === searchesService.engines[index].url) { return searchesService.engines[index].value; }
            }
            if(defaultEngine){ return defaultEngine; }
            return 'custom';
        };
        var getEngineUrl = function(value, defaultUrl){
            for(var index in searchesService.engines){
                if (value === searchesService.engines[index].value) { return searchesService.engines[index].url; }
            }
            return defaultUrl;
        };
        $scope.engines = searchesService.engines;
        $scope.engine = 'google';


        //  Register available callback methods
        dialog.cancel = function(callback){
            dialog.callback.add('cancel', callback);
            return dialog;
        };
        dialog.confirm = function(callback){
            dialog.callback.add('confirm', callback);
            return dialog;
        };

        //  Register show and hide methods
        dialog.events.show = function(search){
            $scope.search = search;
            $scope.engine = getEngine(search.searchEngine, 'google');
            show();
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };
        dialog.events.hide = hide;


        //  Expose callbacks to UI
        $scope.confirm = function(){
            if(!$scope.search.searchString){ return 'Search string is required'; }
            if(!$scope.search.name){ return 'Title is required'; }
            if($scope.engine==='custom' && !$scope.customEngine){ return 'Engine url is required'; }
            var search = $scope.search;
            search.searchEngine = getEngineUrl($scope.engine, $scope.customEngine);
            hide();
            dialogs.busy.show('Saving search...');
            searchesService.searches.save(search,
                function(search){
                    dialogs.busy.hide();
                    dialog.callback.execute('confirm', search);
                },
                function(error){
                    dialogs.busy.hide();
                    dialogs.alert.show(error, show);
                }
            );
        };
        $scope.cancel = function(){
            hide();
            dialog.callback.execute('cancel');
        };


        //  Other UI stuff
        $scope.execute = function(){
            if(!$scope.search.searchString){ return 'Search string is required'; }
            if(!$scope.search.name){ return 'Title is required'; }
            if($scope.engine==='custom' && !$scope.customEngine){ return 'Engine url is required'; }
            var search = $scope.search;
            search.searchEngine = getEngineUrl($scope.engine, $scope.customEngine);
            dialog.events.hide();
            dialogs.searches.run.show(search)
                .confirm(show)
                .cancel(show);
        };

    }]);
'use strict';

/* global angular: false */
/* global jQuery: false */
/* global bsn: false */

//angular.module('captureApp')
angular.module('dialogs')
.controller('searches.run', ['$scope', 'xmlUtility', 'dialogs', 'totangoService',
    function ($scope, xmlUtility, dialogs, totangoService) {
        var dialog = dialogs.searches.run;

        //  Show and hide
        var show = function () { dialog.modal.show($scope.modalSelector); };
        var hide = function () { dialog.modal.hide($scope.modalSelector); };

        //  Register available callback methods
        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };
        dialog.confirm = function (callback) {
            dialog.callback.add('confirm', callback);
            return dialog;
        };

        //  Register show and hide methods
        dialog.events.show = function (search) {
            $scope.search = search;

            //  Get all tags
            $scope.keywords = [];
            $scope.groups = [];
            var tags = xmlUtility.getTags(search.searchString);
            for (var index in tags) {
                var keyword = {};
                keyword.name = xmlUtility.getTagName(tags[index]);
                keyword.id = 'searchInput' + keyword.name.replace(/[^a-zA-Z]/g, '');
                keyword.value = '';
                keyword.tag = tags[index];
                if ((keyword.name || '').toLowerCase().indexOf('group:') !== 0)
                { $scope.keywords.push(keyword); }
                else {
                    var group = keyword;
                    // cut "<Group:"
                    var groupStr = group.tag.split(':')[1];
                    // cut ">"
                    groupStr = groupStr.substring(0, groupStr.length - 1);
                    group.values = groupStr.split(',');
                    $scope.groups.push(group);
                }
            }
            console.log('keywords:', $scope.keywords, 'groups:', $scope.groups, 'search:', search);

            show();

            window.setTimeout(function () {

                var vi = $scope.keywords.length;
                while (vi--) {
                    if ($scope.keywords[vi].name.toLowerCase() === 'linkedin location') {
                        new bsn.AutoSuggest($scope.keywords[vi].id, {
                            script: 'https://account.broadlook.com/api/v1/contact/suggest?t=location&',
                            varname: 's',
                            json: true,
                            maxresults: 35
                        });
                    }
                    else if ($scope.keywords[vi].name.toLowerCase() === 'linkedin industry') {
                        new bsn.AutoSuggest($scope.keywords[vi].id, {
                            script: 'https://account.broadlook.com/api/v1/contact/suggest?t=industry&',
                            varname: 's',
                            json: true,
                            maxresults: 35
                        });
                    }
                }

            }, 1000);
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };
        dialog.events.hide = hide;


        //  Expose callbacks to UI
        $scope.confirm = function () {
            $scope.$broadcast('event:force-model-update'); // to force Angular to read suggested values out of HTML input elements
            var url = $scope.search.searchEngine;
            var searchString = $scope.search.searchString;
            // replace all tags with values
            for (var index in $scope.keywords) {
                var keyword = $scope.keywords[index];
                searchString = searchString.replace(keyword.tag, keyword.value);
            }
            url += searchString;
            var checkTabs = function (tabs) {
                if (!tabs || tabs.length === 0) {
                    chrome.tabs.create({ url: url }, function () { });
                } else {
                    chrome.tabs.update(tabs[0].id, { url: url }, function () { });
                }
            };
            totangoService.sendEvent('search');
            hide();

            if ($scope.groups.length === 0) {
                // simple search
                chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT }, checkTabs);
            }
            else {

                //var first = true;
                var groupUrl = '';

                //var checkTabs2 = function (tabs) {
                //    chrome.tabs.update(tabs[0].id, { url: groupUrl }, function () { });
                //};

                //var tabIndex = 0;

                for (var groupIndex in $scope.groups) {

                    var group = $scope.groups[groupIndex];

                    for (var valueIndex in group.values) {

                        var value = group.values[valueIndex].trim();

                        groupUrl = angular.copy(url);
                        groupUrl = groupUrl.replace(group.tag, value);

                        //tabIndex++;

                        //if (first) {
                        //    first = false;
                        //    window.setTimeout(function () {
                        //        chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT }, checkTabs2);
                        //    };
                        //}
                        //else {
                            //window.setTimeout(function () {
                                chrome.tabs.create({ url: groupUrl });
                            //}, tabIndex * 200);
                        //}
                    }
                }

                // search with groups
                angular.forEach($scope.groups, function (group, index) {

                });
            }

            dialog.callback.execute('confirm', $scope.search);
        };
        $scope.cancel = function () {
            hide();
            dialog.callback.execute('cancel');
        };


        //  Other UI stuff
        $scope.edit = function () {
            hide();
            dialogs.searches.edit.show($scope.search)
                .confirm(dialog.events.show)
                .cancel(show);
        };




    }]);
'use strict';

/* global angular: false */
/* global jQuery: false */

//angular.module('captureApp')
angular.module('dialogs')
.controller('contacts.edit', ['$scope', 'contactUtility', 'dialogs', 'lookupService',
    function ($scope, contactUtility, dialogs, lookupService) {
        var dialog = dialogs.contacts.edit;

        //  Show and hide
        var show = function () { dialog.modal.show($scope.modalSelector); };
        var hide = function () { dialog.modal.hide($scope.modalSelector); };

        //  Register available callback methods
        dialog.cancel = function (callback) {
            dialog.callback.add('cancel', callback);
            return dialog;
        };
        dialog.confirm = function (callback) {
            dialog.callback.add('confirm', callback);
            return dialog;
        };

        //  Register show and hide methods
        dialog.events.show = function (contact) {
            console.log('contact:', contact);
            $scope.c = contact;
            if (contact && contact.last) {
                $scope.title = 'Edit Contact';
            } else {
                $scope.title = 'New Contact';
            }
            show();
            dialog.refresh($scope);
            dialog.callback.reset();
            return dialog;
        };
        dialog.events.hide = hide;

        //  Expose callbacks to UI
        $scope.confirm = function () {
            var errors = [];
            if (!$scope.c.first) { errors.push('First Name'); }
            if (!$scope.c.last) { errors.push('Last Name'); }
            if (!$scope.c.company) { errors.push('Company'); }
            //if (!$scope.c.company && !$scope.c.website) { errors.push('either Company Name or Website'); }
            if (errors.length > 0) {

                var msg = 'Please fill out ' + errors.join(', ');
                return msg;

            }

            if ($scope.c.email) {
                var res = contactUtility.validateEmail($scope.c.email);
                console.warn($scope.c.email, res);
                if (!res) {
                    errors.push('Email');
                }
            }

            if ($scope.c.email2) {
                var res2 = contactUtility.validateEmail($scope.c.email);
                console.warn($scope.c.email2, res2);
                if (!res2) {
                    errors.push('Secondary Email');
                }
            }

            if (errors.length > 0) {

                var msg2 = 'Please correct the following entries: ' + errors.join(', ');
                return msg2;

            }

            hide();
            dialog.callback.execute('confirm', $scope.c);
        };
        $scope.cancel = function () {
            hide();
            dialog.callback.execute('cancel');
        };


        //  Other UI stuff
        $scope.addVenue = function () {
            if (!$scope.c.venues) { $scope.c.venues = []; }
            $scope.c.venues.push({});
        };
        $scope.removeVenue = function (index) {
            $scope.c.venues.splice(index, 1);
        };
        $scope.getSocialIcon = function (url) {
            //console.log('venue: ' + url, contactUtility.parseSocialVenu(url));
            return contactUtility.parseSocialVenu(url);
        };

        $scope.lookupWebsite = function (contact) {
            try {
                //$scope.$parent.$parent.lookupWebsite(c);

                hide();

                var processWinner = function (website) {
                    console.log('SELECTED WINNER WEBSITE: ', website);
                    if (website && contact.website !== website) {

                        contact.website = website;

                        if (contact.company && contact.website) {
                            lookupService.logCompanyWebsite(contact.company, contact.website);
                        }

                    }

                    show();

                };

                var service = {

                    findRecord: function (recordType, query, fields, successCallback, failCallback) {

                        console.log('findRecord > query > ', angular.copy(query)); 

                        var companyName = query.company;

                        if (!companyName) {
                            successCallback([]);
                            return;
                        }

                        lookupService.lookupCompanyWebsite(
                                  companyName,
                                  function (rr) {

                                      var results = [];

                                      // Filter out outliers
                                      var i, r, max = 0, min = 0;
                                      for (i = 0; i < rr.results.length; i++) {
                                          r = rr.results[i];
                                          max = r.rank > max ? r.rank : max;
                                          min = r.rank < min || min === 0 ? r.rank : min;
                                      }

                                      var threshold = 0.75 * max;

                                      for (i = 0; i < rr.results.length; i++) {
                                          r = rr.results[i];
                                          if (r.rank >= threshold) {
                                              results.push(r);
                                          }
                                      }

                                      successCallback(results);
                                  },
                                  function (error) { failCallback(error); }
                               );

                        return [];
                    },

                    toLookupObject: function (value, type) {
                        //if (debug) { console.log(value); }
                        var lookupObject = {};
                        lookupObject.label = value.website + ' (' + (value.name || '') + ') ';
                        lookupObject.link = value.website;
                        lookupObject.id = value.website;
                        return lookupObject;
                    }

                };

                var displayDialog = function () {

                    dialogs.lookup
                        .show({ lookup: { message: 'Lookup Website', allowNew: false, required: false, appProperty: 'company', selectButtonLabel: 'Select Website', type: 'Website', showGoogle: true }, value: contact.company, exportService: service })
                        .select(
                            function (value) {
                                console.log('SELECTED WEBSITE: ', value);
                                processWinner((value && value.link) ? value.link : '');
                            }
                        )
                        .cancel(
                            function () {
                                console.warn('SELECTED WEBSITE: NONE');
                                show();
                            }
                        );
                };


                displayDialog();


            } catch (e) {
                console.error('Lookup Website > ', e.message);
            }

        };

    }]);
'use strict';

/* global angular: false */

/**
 * @class captureApp.webServices
 * @memberOf captureApp    
 */

//     Setup a namespace for our webservices (defined in webservices sub folder)
var webServicesModule = angular.module('webServices', ['utilities']);

'use strict';

/* global angular: false */

angular.module('webServices')
.factory('endpoints', ['environmentUtility', function (environmentUtility) {
    var onReadyCallbacks = [];
    var isReady = false;
    var ready = function () {
        isReady = true;
        for (var index in onReadyCallbacks) {
            onReadyCallbacks[index]();
        }

    };
    //  When environment is loaded, do our stuff!
    environmentUtility.onLoaded(ready);

    var mainApiServer = 'https://account.broadlook.com/';
    var stagingApiServer = 'https://account-staging.broadlook.com/';
    var devApiServer = 'https://account-staging.broadlook.com/';
    //var devApiServer = 'http://localhost:52000/';
    //var devApiServer = 'https://account.broadlook.com/';

    var localApiServer = devApiServer;
    var alphaApiServer = stagingApiServer;
    var betaApiServer = stagingApiServer;
    var productionApiServer = mainApiServer;


    return {
        broadlook: {
            account: {
                local: localApiServer,
                alpha: alphaApiServer,
                beta: betaApiServer,
                production: productionApiServer,
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            parser: {
                local: localApiServer + 'api/v1/contact/capture',
                alpha: alphaApiServer + 'api/v1/contact/capture',
                beta: betaApiServer + 'api/v1/contact/capture',
                production: productionApiServer + 'api/v1/contact/capture',
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            register: {
                local: localApiServer + 'api/v1/org/registerapp',
                alpha: alphaApiServer + 'api/v1/org/registerapp',
                beta: betaApiServer + 'api/v1/org/registerapp',
                production: productionApiServer + 'api/v1/org/registerapp',
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            diver: {
                local: localApiServer,
                alpha: alphaApiServer,
                beta: betaApiServer,
                production: productionApiServer,
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            research: {
                local: localApiServer,
                alpha: alphaApiServer,
                beta: betaApiServer,
                production: productionApiServer,
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            profiler: {
                local: {
                    accounts: localApiServer,
                    webProfiler: 'http://wprpc.broadlook.com/rpc2/'
                },
                alpha: {
                    accounts: alphaApiServer,
                    webProfiler: 'http://wprpc.broadlook.com/rpc2/'
                },
                beta: {
                    accounts: betaApiServer,
                    webProfiler: 'http://wprpc.broadlook.com/rpc2/'
                },
                production: {
                    accounts: productionApiServer,
                    webProfiler: 'http://wprpc.broadlook.com/rpc2/'
                },
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            searches: {
                local: {
                    searches: localApiServer
                },
                alpha: {
                    searches: alphaApiServer
                },
                beta: {
                    searches: betaApiServer
                },
                production: {
                    searches: productionApiServer
                },

                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            shield: {
                local: { v1: 'https://crmshield.broadlook.com/', v2: localApiServer + 'api/v1/shield/' },
                alpha: { v1: 'https://crmshield.broadlook.com/', v2: alphaApiServer + 'api/v1/shield/' },
                beta: { v1: 'https://crmshield.broadlook.com/', v2: betaApiServer + 'api/v1/shield/' },
                production: { v1: 'https://crmshield.broadlook.com/', v2: productionApiServer + 'api/v1/shield/' },
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            store: {
                local: {
                    store: localApiServer
                },
                alpha: {
                    store: alphaApiServer
                },
                beta: {
                    store: betaApiServer
                },
                production: {
                    store: productionApiServer
                },

                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            storage: {
                local: localApiServer + 'api/v1/storage/',
                alpha: alphaApiServer + 'api/v1/storage/',
                beta: betaApiServer + 'api/v1/storage/',
                production: productionApiServer + 'api/v1/storage/',
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            limit: {
                local: localApiServer + 'api/v1/org/',
                alpha: alphaApiServer + 'api/v1/org/',
                beta: betaApiServer + 'api/v1/org/',
                production: productionApiServer + 'api/v1/org/',
                current: function (release) { return this[environmentUtility.getRelease()]; }
            },
            stratus: {
                local: { api: 'https://dq.broadlook.com/api/v1/', web: 'https://dq.broadlook.com/#/' },
                alpha: { api: 'https://dq.broadlook.com/api/v1/', web: 'https://dq.broadlook.com/#/' },
                beta: { api: 'https://dq.broadlook.com/api/v1/', web: 'https://dq.broadlook.com/#/' },
                production: { api: 'https://dq.broadlook.com/api/v1/', web: 'https://dq.broadlook.com/#/' },
                current: function (release) { return this[environmentUtility.getRelease()]; }
            }
        },
        google: {
            local: 'https://www.googleapis.com/plus/v1/people/me',
            alpha: 'https://www.googleapis.com/plus/v1/people/me',
            beta: 'https://www.googleapis.com/plus/v1/people/me',
            production: 'https://www.googleapis.com/plus/v1/people/me',
            current: function () { return this.production; }
        },
        totango: {
            local: 'http://sdr.totango.com/pixel.gif/',
            alpha: 'http://sdr.totango.com/pixel.gif/',
            beta: 'http://sdr.totango.com/pixel.gif/',
            production: 'http://sdr.totango.com/pixel.gif/',
            current: function () { return this[environmentUtility.getRelease()]; }
        },

        //  Sometimes a service loads before the environment loads...  Register a callback when endpoints is ready here
        onReady: function (callback) {
            if (isReady) { callback(); }
            else { onReadyCallbacks.push(callback); }
        },

        accountService: function () { return this.broadlook.account.current(); },
        parsingService: function () { return this.broadlook.parser.current(); },
        registrationService: function () { return this.broadlook.register.current(); },
        googlePlusService: function () { return this.google.current(); },
        limitService: function () { return this.broadlook.limit.current(); },
        profilerService: function () { return this.broadlook.profiler.current(); },
        searchService: function () { return this.broadlook.searches.current(); },
        shieldService: function () { return this.broadlook.shield.current(); },
        storeService: function () { return this.broadlook.store.current(); },
        totangoService: function () { return this.totango.current(); },
        researchService: function () { return this.broadlook.research.current(); },
        storageService: function () { return this.broadlook.storage.current(); }

    };
}]);

'use strict';

/* global angular: false */
/* global X2JS: false */
/* global $: false */

var GoogleSpreadsheet, GoogleUrl;

angular.module('webServices')
.factory('driveService', ['$http', 'endpoints', 'chromeUtility', 'userInfoStore', function ($http, endpoints, chromeUtility, userInfoStore) {
    var debug = 'driveService->';
    var store = {};


    //var urls = endpoints.storeService();
    //var storeInterfaceUrl = urls.store + 'Store/List?appcode=LC&sitekey=';

    

    GoogleUrl = (function () {
        function GoogleUrl(sourceIdentifier) {
            this.sourceIdentifier = sourceIdentifier;
            if (this.sourceIdentifier.match(/http(s)*:/)) {
                this.url = this.sourceIdentifier;
                try {
                    this.key = this.url.match(/key=(.*?)&/)[1];
                } catch (error) {
                    this.key = this.url.match(/(cells|list)\/(.*?)\//)[2];
                }
            } else {
                this.key = this.sourceIdentifier;
            }
            this.jsonCellsUrl = 'https://spreadsheets.google.com/feeds/cells/' + this.key + '/od6/public/basic?alt=json-in-script';
            this.jsonListUrl = 'https://spreadsheets.google.com/feeds/list/' + this.key + '/od6/public/basic?alt=json-in-script';
            this.jsonUrl = this.jsonCellsUrl;
        }
        return GoogleUrl;
    })();

    GoogleSpreadsheet = (function () {
        function GoogleSpreadsheet() { }
        GoogleSpreadsheet.prototype.load = function (callback) {
            var intervalId, jsonUrl, safetyCounter, url, waitUntilLoaded;
            url = this.googleUrl.jsonCellsUrl + '&callback=GoogleSpreadsheet.callbackCells';
            $('body').append('<script src="' + url + '"/>');
            jsonUrl = this.jsonUrl;
            safetyCounter = 0;
            var result;
            waitUntilLoaded = function () {
                result = GoogleSpreadsheet.find({
                    jsonUrl: jsonUrl
                });
                if (safetyCounter++ > 20 || ((result !== null) && (result.data !== null))) {
                    clearInterval(intervalId);
                    return callback(result);
                }
            };
            intervalId = setInterval(waitUntilLoaded, 200);
            if (typeof result !== 'undefined' && result !== null) {
                return result;
            }
        };
        GoogleSpreadsheet.prototype.url = function (url) {
            return this.googleUrl(new GoogleUrl(url));
        };
        GoogleSpreadsheet.prototype.googleUrl = function (googleUrl) {
            if (typeof googleUrl === 'string') {
                throw 'Invalid url, expecting object not string';
            }
            this.url = googleUrl.url;
            this.key = googleUrl.key;
            this.jsonUrl = googleUrl.jsonUrl;
            this.googleUrl = googleUrl;
            return this.googleUrl;
        };
        GoogleSpreadsheet.prototype.save = function () {
            localStorage['GoogleSpreadsheet.' + this.type] = JSON.stringify(this);
            return localStorage['GoogleSpreadsheet.' + this.type];
        };
        return GoogleSpreadsheet;
    })();
    GoogleSpreadsheet.bless = function (object) {
        var key, result, value;
        result = new GoogleSpreadsheet();
        for (key in object) {
            value = object[key];
            result[key] = value;
        }
        return result;
    };
    GoogleSpreadsheet.find = function (params) {
        var item, itemObject, value;
        try {
            for (item in localStorage) {
                if (item.match(/^GoogleSpreadsheet\./)) {
                    itemObject = JSON.parse(localStorage[item]);
                    for (var key in params) {
                        value = params[key];
                        if (itemObject[key] === value) {
                            return GoogleSpreadsheet.bless(itemObject);
                        }
                    }
                }
            }
        } catch (error) {
            for (var _i = 0, _len = localStorage.length; _i < _len; _i++) {
                item = localStorage[_i];
                if (item.match(/^GoogleSpreadsheet\./)) {
                    itemObject = JSON.parse(localStorage[item]);
                    for (var key in params) {
                        value = params[key];
                        if (itemObject[key] === value) {
                            return GoogleSpreadsheet.bless(itemObject);
                        }
                    }
                }
            }
        }
        return null;
    };
    GoogleSpreadsheet.callbackCells = function (data) {
        var cell, googleSpreadsheet, googleUrl;
        googleUrl = new GoogleUrl(data.feed.id.$t);
        googleSpreadsheet = GoogleSpreadsheet.find({
            jsonUrl: googleUrl.jsonUrl
        });
        if (googleSpreadsheet === null) {
            googleSpreadsheet = new GoogleSpreadsheet();
            googleSpreadsheet.googleUrl(googleUrl);
        }
        googleSpreadsheet.data = (function () {
            var _i, _len, _ref, _results;
            _ref = data.feed.entry;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                cell = _ref[_i];
                _results.push(cell.content.$t);
            }
            return _results;
        })();
        googleSpreadsheet.save();
        return googleSpreadsheet;
    };

    /* TODO (Handle row based data)
    GoogleSpreadsheet.callbackList = (data) ->*/

    var service = {

        list: function (successCallback, failureCallback) {

            var service = this;

            //var url = endpoints.storageService() + 'get';
            var url = 'https://spreadsheets.google.com/feeds/spreadsheets/private/full';

            var params = {
                //keys: keys
            };

            var config = {
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json' }
            };
            if (debug) { console.log('driveService.get...', { url: url, params: params, config: config }); }

            $http.get(url)
                .success(function (response) {
                    //if (debug) { console.log(debug + 'get.success', response); }

                    var xml = response;
                    //var json = $.xml2json(xml);
                    var x2js = new X2JS();
                    var json = x2js.xml_str2json(xml);

                    var o = json;

                    //if (!response) {
                    //    if (debug) { console.log('Unknown storage service response:', response); }
                    //    try { failureCallback('Storage service is unavailable. Please try again later. Error code: SS-68.'); } catch (e) { }
                    //} else if (response.success) {
                    //    var o = {};
                    //    for (var i = 0; i < response.values.length; i++) {
                    //        var key = response.values[i].key;

                    //        var value = response.values[i].value;
                    //        if (value !== null && value !== '')
                    //        { value = JSON.parse(value); }

                    //        //var value = JSON.parse(response.values[i].value);
                    //        o[key] = value;
                    //    }
                    //    try { successCallback(o); } catch (e) { }
                    //} else {
                    //    try { failureCallback(response.message); } catch (e) { }
                    //}

                    try { successCallback(o); } catch (e) { }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log(debug + 'get.error:' + status, data); }
                    try { failureCallback('Service is not available. Error code: DS-61.'); } catch (e) { }
                });

        },

        appendSpreadsheet: function (docId, worksheetId, foo, handleSuccess) {


            /*
            <entry>
                <id>https://spreadsheets.google.com/feeds/spreadsheets/private/full/1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4</id>
                <updated>2015-04-11T20:45:36.981Z</updated>
                <category scheme='http://schemas.google.com/spreadsheets/2006' term='http://schemas.google.com/spreadsheets/2006#spreadsheet'/>
                <title type='text'>C! Before - Capture Sample Spreadsheet - Before</title>
                <content type='text'>C! Before - Capture Sample Spreadsheet - Before</content>
                <link rel='http://schemas.google.com/spreadsheets/2006#worksheetsfeed' type='application/atom+xml' href='https://spreadsheets.google.com/feeds/worksheets/1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4/private/values'/>
                <link rel='alternate' type='text/html' href='https://docs.google.com/a/ringlead.com/spreadsheets/d/1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4/edit'/>
                <link rel='self' type='application/atom+xml' href='https://spreadsheets.google.com/feeds/spreadsheets/private/full/1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4'/>
                <author><name>dd</name><email>dd@ringlead.com</email></author>
            </entry>
            */
            //Constructs the XML string to interface with the Spreadsheet API.
            //This function adds the value of the param foo to the cell in the first empty row in the column called 'columnTitle'. 
            //The Spreadsheet API will return an error if there isn't a column with that title.
            function constructAtomXML(foo) {
                var atom = ['<?xml version="1.0" encoding="UTF-8"?>',
                        '<entry xmlns="http://www.w3.org/2005/Atom" xmlns:gsx="http://schemas.google.com/spreadsheets/2006/extended">',//'--END_OF_PART\r\n',
                        '<gsx:columnTitle>', foo, '</gsx:columnTitle>',//'--END_OF_PART\r\n',
                        '</entry>'].join('');
                return atom;
            }

            var params = {
                'method': 'POST',
                'headers': {
                    'GData-Version': '3.0',
                    'Content-Type': 'application/atom+xml'
                },
                'body': constructAtomXML(foo)
            };

            //var docId //Get this from the spreadsheet URL or from the Google Drive API.
            worksheetId = worksheetId || 'od6'; //The worksheet Id for the first sheet is 'od6' by default.

            //https://docs.google.com/a/ringlead.com/spreadsheets/d/10Giyj2hXUBwSIwXiOlYIc_YjdLUYsHKZKKuke-yoqC0/edit?usp=sharing
            //https://spreadsheets.google.com/feeds/spreadsheets/private/full/1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4
            //https://spreadsheets.google.com/feeds/spreadsheets/private/full/1nsWAmRoHNM2LQSSp_X_qrT2WXu_yv6rM6jwOFwjkuP4
            var url = 'https://spreadsheets.google.com/feeds/list/' + docId + '/' + worksheetId + '/private/full';
            //var url = 'https://spreadsheets.google.com/feeds/spreadsheets/private/full/' + worksheetId + '';

            //sendSignedRequest(url, handleSuccess, params); //Use your OAuth2 lib

            //var config = {
            //    headers: { 'Content-type': 'application/atom+xml', 'Accept': 'application/atom+xml' }
            //};

            //$http.post(url, constructAtomXML(foo), config)
            //    .success(function (response) {
            //        if (debug) { console.log(debug + 'post.success', response); }
                

            //        try { handleSuccess(); } catch (e) { }
            //    })
            //    .error(function (data, status, headers, config) {
            //        if (debug) { console.log(debug + 'post..error:' + status, data); }
            //        try { failureCallback('Service is not available. Error code: DS-128.'); } catch (e) { }
            //    });


            var googleSpreadsheet = new GoogleSpreadsheet();
            googleSpreadsheet.url(url);
            googleSpreadsheet.load(function (result) {
                if (debug) { console.log(debug + 'lad.success', result); }
                //$('#results').html(JSON.stringify(result).replace(/,/g, ',\n'));

                try { handleSuccess(); } catch (e) { }
            });

        }

    };
    return service;
}]);


'use strict';

/* global angular: false */

angular.module('webServices')
.factory('storeService', ['$http', 'endpoints', 'chromeUtility', 'userInfoStore', function ($http, endpoints, chromeUtility, userInfoStore) {
    const consolePrefix = 'Store Service > ';
    var debug = true;
    //var store = {};



    var service = {
        open: function (siteKey, crmId) {
            var urls = endpoints.storeService();
            var storeInterfaceUrl = urls.store + 'Store/List?appcode=LC&sitekey=';
            var crmid = userInfoStore.getCrmId();           
            var url = storeInterfaceUrl + userInfoStore.getSiteKey() + '&crmid=' + crmid;
            if (crmid.indexOf('@ringlead.com') > 0) {
                url += '&test=1';
            }
            url = 'https://www.ringlead.com/capture-payments/?storeToken=' + encodeURIComponent(url);
            var props = { url: url };
            var callback = function () { };
            var f = function (tabs) {
                if (!tabs || tabs.length === 0)
                { chrome.tabs.create(props, callback); }
                else
                { chrome.tabs.update(tabs[0].id, props, callback); }
            };

            chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT }, f);
        }//,

        //getStoreUrl: function (siteKey, crmId) {
        //    var url = null;
        //    const functionName = 'Get Store Url';
        //    try {
        //        var urls = endpoints.storeService();
        //        var storeInterfaceUrl = urls.store + 'Store/List?appcode=LC&sitekey=';
        //        if (debug) { console.log(consolePrefix + functionName + ' > Sitekey > ', siteKey, ' > CrmID > ', crmId); }
        //        url = storeInterfaceUrl + userInfoStore.getSiteKey() + '&crmid=' + userInfoStore.getCrmId();
        //        if (debug) { console.log(consolePrefix + functionName + ' > Url > ', url); }
        //        url = 'https://www.ringlead.com/capture-payments/?storeToken=' + encodeURIComponent(url);
        //        if (debug) { console.log(consolePrefix + functionName + ' > Url (RL) > ', url); }
        //    } catch (e) {
        //        console.error(functionName, e.message);
        //    }
        //    return url;
        //}

    };
    return service;
}]);


'use strict';

/* global angular: false */

angular.module('webServices')
.factory('parsingService', ['$http', 'endpoints', 'xmlUtility', 'contactUtility', 'userInfoStore', function ($http, endpoints, xmlUtility, contactUtility, userInfoStore) {

    return {
        //uid, crmid, sitekey,
        capture: function (html, sourceUrl, format, successCallback, failureCallback) {
            console.log('Parsing service capture!');
            var url = endpoints.parsingService();

            var dataformat = 'text/html';
            dataformat = format;

            var params = '<?xml version="1.0"?>' +
                 '<request>' +
                 '<uid>' + xmlUtility.xmlencode(userInfoStore.getShieldId()) + '</uid>' +
                 '<crmid>' + xmlUtility.xmlencode(userInfoStore.getCrmId()) + '</crmid>' +
                 '<sitekey>' + xmlUtility.xmlencode(userInfoStore.getSiteKey()) + '</sitekey>' +
                 '<dataformat>' + xmlUtility.xmlencode(dataformat) + '</dataformat>' +
                 '<data>' + xmlUtility.xmlencode(html) + '</data>' +
                 '</request>';
            var config = {
                headers: { 'Content-type': 'application/xml', 'Accept': 'application/json' }
            };

            var merge = function (contacts) {
                var functionName = 'Merge';
                try {

                    if (Array.isArray(contacts) && contacts.length === 2) {

                        // Analyze if these two are really one
                        var shouldMerge = false;

                        if ((!contacts[0].LastName && contacts[1].LastName) || (contacts[0].LastName && !contacts[1].LastName)) {
                            shouldMerge = true;
                        }

                        console.log(functionName + ' > Should? > ', shouldMerge, angular.copy(contacts));

                        // Merge
                        if (shouldMerge) {
                            var merged = {};

                            angular.forEach(contacts, function (contact) {

                                for (var p in contact) {
                                    if (!contact.hasOwnProperty(p)) {
                                        continue;
                                    }
                                    if (!merged[p]) {
                                        merged[p] = contact[p];
                                    }
                                }

                            });

                            contacts = [merged];

                            console.log(functionName + ' > Result > ', shouldMerge, angular.copy(contacts));
                        }
                    }

                } catch (e) {
                    console.error(functionName, e.message);
                }
                return contacts;
            };

            var cleanStringValue = function (value) {
                if (typeof value === 'string' && value.length > 0) {

                    var valueWithoutTags = xmlUtility.removeTags(value);

                    // xmlUtility.removeTags function does not remove partial tags!

                    if (valueWithoutTags.indexOf('>') >= 0) {
                        valueWithoutTags = valueWithoutTags.substring(valueWithoutTags.indexOf('>') + 1);
                    }

                    if (valueWithoutTags.indexOf('<') > 0) {
                        valueWithoutTags = valueWithoutTags.substring(0, valueWithoutTags.indexOf('<'));
                    }

                    if (valueWithoutTags !== value) {
                        console.log('New value > ', valueWithoutTags, ' > Replaced value > ', value);
                        value = valueWithoutTags;
                    }

                }
                return value;
            };

            var cleanValue = function (value) {
                if (typeof value === 'string') {
                    value = cleanStringValue(value);
                } else if (Array.isArray(value)) {
                    var i = value.length;
                    while (i--) {
                        value[i] = cleanValue(value[i]);
                    }
                }
                return value;
            };

            var clean = function (contacts) {
                var functionName = 'Clean';
                try {

                    angular.forEach(contacts, function (contact) {

                        for (var p in contact) {
                            if (!contact.hasOwnProperty(p)) {
                                continue;
                            }
                            contact[p] = cleanValue(contact[p]);
                        }

                    });

                } catch (e) {
                    console.error(functionName, e.message);
                }
            };

            var readResponse = function (data) {
                console.log('parsing service:', data);

                if (!data || data.success === false) {
                    var error = 'No reponse from Contact Capture service';
                    if (data && data.message) {
                        error = data.message;
                    }
                    try { failureCallback(error); } catch (e) { }
                    return;
                }
                // Handle merge situation (sinlge contact was split into multiple
                var sourceContacts = merge(data.contacts);

                //Clean HTML tags from values
                clean(sourceContacts);

                //     convert to actual contacts and pass back
                var contacts = [];
                for (var contactIndex in sourceContacts) {

                    if (!sourceContacts.hasOwnProperty(contactIndex)) {
                        console.error('Not an index!', contactIndex, ' in ', angular.copy(sourceContacts));
                        continue;
                    }

                    var CN = sourceContacts[contactIndex];

                    var contact = contactUtility.createNewContact();
                    contact.sourceurl = sourceUrl;

                    //if (CN.LastName) { a.last = CN.LastName[0]; }
                    //if (CN.FirstName) { a.first = CN.FirstName[0]; }
                    //if (CN.Phone) {
                    //    a.phone = CN.Phone[0];
                    //    if (CN.Phone.length > 1) { a.phone2 = CN.Phone[1]; }
                    //}
                    //if (CN.JobTitle) { a.jobtitle = CN.JobTitle[0]; }
                    //if (CN.Email) { a.email = CN.Email[0]; }
                    //if (CN.Biography) { a.bio = CN.Biography[0]; }
                    //if (CN.CompanyName) { a.company = CN.CompanyName[0]; }

                    //if (CN.AddressLine1) { a.address1 = CN.AddressLine1[0]; }
                    //if (CN.AddressLine2) { a.address2 = CN.AddressLine2[0]; }
                    //if (CN.City) { a.city = CN.City[0]; }
                    //if (CN.PostalCode) {a.zip = CN.PostalCode[0]; }
                    //if (CN.State){ a.state = CN.State[0]; }
                    //if (CN.Country) { a.country = CN.Country[0]; }

                    //if (CN.Website) { a.website = CN.Website[0]; }


                    contact.emails = [];

                    if (CN.LastName) { contact.last = CN.LastName[0]; }
                    if (CN.FirstName) { contact.first = CN.FirstName[0]; }
                    if (CN.MiddleName) { contact.middle = CN.MiddleName[0]; }

                    if (CN.JobTitle) { contact.jobtitle = CN.JobTitle[0]; }
                    if (CN.Email) { contact.email = CN.Email[0]; }

                    //if (CN.Bio) { contact.bio = CN.Bio; }
                    if (CN.Biography) { contact.bio = CN.Biography[0]; }
                    if (CN.CompanyName) { contact.company = CN.CompanyName[0]; }
                    if (CN.Website) { contact.website = contactUtility.fixUrl(CN.Website[0]); }
                    if (CN.Revenue) { contact.revenue = CN.Revenue[0]; }
                    if (CN.Employees) { contact.employees = CN.Employees[0]; }
                    if (CN.Industry) { contact.industry = CN.Industry[0]; }

                    if (CN.AddressLine1) { contact.address1 = CN.AddressLine1[0]; }
                    if (CN.AddressLine2) { contact.address2 = CN.AddressLine2[0]; }
                    if (CN.City) { contact.city = CN.City[0]; }
                    if (CN.PostalCode) { contact.zip = CN.PostalCode[0]; }
                    if (CN.State) { contact.state = CN.State[0]; }
                    if (CN.Country) { contact.country = contactUtility.formatCountry(CN.Country[0]); }

                    if (CN.Phone) {
                        console.log('Phones', CN.Phone);
                        var newPhone1 = contactUtility.formatPhone(CN.Phone[0]);
                        var newPhone2 = '';
                        if (CN.Phone.length > 1) { newPhone2 = contactUtility.formatPhone(CN.Phone[1]); }

                        contact.phone = newPhone1;
                        contact.phone2 = newPhone2;
                    }

                    if (CN.Venue) {
                        console.log('Venues', CN.Venue);

                        contact.venues = [];

                        var vi = 0;
                        while (vi < CN.Venue.length) {
                            contactUtility.addVenue(contact, { website: contactUtility.fixUrl(CN.Venue[vi]), type: CN.VenueType[vi] });
                            vi++;
                        }
                    }

                    contactUtility.sortVenues(contact);

                    /*
                    if (CN.Lists && CN.Lists.AdditionalEmails) {
                        console.log('AdditionalEmails', CN.Lists.AdditionalEmails);
        
                        //if (CN.Lists.AdditionalEmails.Email.length > 0)
                        //{ contact.email2 = CN.Lists.AdditionalEmails.Email; }
        
                        if (Array.isArray(CN.Lists.AdditionalEmails.Email)) {
                            var emailIndex = 0;
                            while (emailIndex < CN.Lists.AdditionalEmails.Email.length) {
                                if (emailIndex === 0)
                                { contact.email2 = CN.Lists.AdditionalEmails.Email[emailIndex]; }
                                else
                                { contact.emails.push(CN.Lists.AdditionalEmails.Email[emailIndex]); }
                                emailIndex++;
                            }
                        }
                        else {
                            if (CN.Lists.AdditionalEmails.Email)
                            { contact.email2 = CN.Lists.AdditionalEmails.Email; }
                        }
        
                    }
        
        
        
                    if (CN.Lists && CN.Lists.AdditionalAddresses) {
                        console.log('AdditionalAddresses', CN.Lists.AdditionalAddresses);
                        contact.addresses = [];
                        if (CN.Lists.AdditionalAddresses.Address.length > 0) {
        
                            var ai = 0;
                            while (ai < CN.Lists.AdditionalAddresses.Address.length) {
                                contactUtility.addAddress(contact, {
                                    address1: CN.Lists.AdditionalAddresses.Address[ai].AddressLine1,
                                    address2: CN.Lists.AdditionalAddresses.Address[ai].AddressLine2,
                                    city: CN.Lists.AdditionalAddresses.Address[ai].City,
                                    zip: CN.Lists.AdditionalAddresses.Address[ai].PostalCode,
                                    state: CN.Lists.AdditionalAddresses.Address[ai].State,
                                    country: CN.Lists.AdditionalAddresses.Address[ai].Country
                                });
                                ai++;
                            }
                        }
                        else {
                            if (CN.Lists.AdditionalAddresses.Address && CN.Lists.AdditionalAddresses.Address.City) {
                                contactUtility.addAddress(contact, {
                                    address1: CN.Lists.AdditionalAddresses.Address.AddressLine1,
                                    address2: CN.Lists.AdditionalAddresses.Address.AddressLine2,
                                    city: CN.Lists.AdditionalAddresses.Address.City,
                                    zip: CN.Lists.AdditionalAddresses.Address.PostalCode,
                                    state: CN.Lists.AdditionalAddresses.Address.State,
                                    country: CN.Lists.AdditionalAddresses.Address.Country
                                });
        
                            }
                        }
                    }
                    */

                    contacts.push(contact);

                }


                try { successCallback(contacts); } catch (e) { }
            };

            //     callback(data, status, headers, config)
            $http.post(url, params, config)
                 .success(readResponse)
                 .error(failureCallback);

        }




    };
}]);

'use strict';

/* global angular: false */

angular.module('webServices')
.factory('registrationService', ['$http', 'endpoints', 'xmlUtility', 'contactUtility', 'chromeUtility', 'userInfoStore', 'environmentUtility', function ($http, endpoints, xmlUtility, contactUtility, chromeUtility, userInfoStore, environmentUtility) {
    var debug = true;

    /*
    var store = {
        persistent:{license:null, profile:null},
    };

    var saveStore = function(){
        chromeUtility.setField('registrationService', store.persistent);
    };
    var loadStore = function(override, successCallback){
        if(store.persistent.loaded && !override){
            try{ successCallback(); }catch(e){}
            return;
        }
        chromeUtility.getField('registrationService', function(persistent){
            if(!persistent) { persistent = {}; }
            store.persistent = persistent;
            store.persistent.loaded = true;
            if(debug) {console.log('registrationService.store:', store);}
            try{ successCallback(); }catch(e){}
        });
    };
    var clearStore = function(){
        chromeUtility.clearField('registrationService');
    };



    var setLicense = function(license){
        store.persistent.license = license;
        saveStore();
    };
    */

    var setProfile = function (profile) {
        //store.persistent.profile = profile;
        //saveStore();
    };

    var service = {


        isRegistered: function () {
            return (userInfoStore.getSiteKey() !== undefined);
        },

        getAuth: function () {
            return userInfoStore.getShieldAuth();
        },

        getSiteKey: function () {
            return userInfoStore.getSiteKey();
        },

        getUId: function () {
            return userInfoStore.getShieldId();
        },

        getCrmId: function () {
            return userInfoStore.getCrmId();
        },

        /*
                getProfile: function(){
                    return store.persistent.profile;
                },
        
                getLicense: function(successCallback, failureCallback){
                    if(store.persistent.license){
                        try{ successCallback(store.persistent.license); } catch(e){}
                        return;
                    }
                    this.getLimits(successCallback, failureCallback);
                },
         */
        unregister: function () {
            userInfoStore.clear();
        },


        register: function (userinfo, successCallback, failureCallback) {
            //  successCallback(siteKey, auth, uid)
            //  failureCallback(errorMessage)
            var service = this;
            var crmtype ='salesforce';
            var authtype = 'Chrome';
            var url = endpoints.registrationService();

            userInfoStore.setCrmId('chrome-sf:' + userinfo.email);

            //userinfo.crmid = 'chrome-sf:' + userinfo.email;
            //service.crmId = userinfo.crmid;

            setProfile(userinfo);




            //var params = '<?xml version="1.0"?>' +
            //     '<request>' +
            //     '<crmid>' + xmlUtility.xmlencode('chrome-sf:' + userinfo.email) + '</crmid>' +
            //     (userinfo.key ? '<appkey>' + xmlUtility.xmlencode(userinfo.key) + '</appkey>' : '') +
            //     '<crmtype>' + xmlUtility.xmlencode(crmtype) + '</crmtype>' +
            //     '<crmlabel>' + xmlUtility.xmlencode(userInfoStore.getCrmId()) + '</crmlabel>' +
            //     '<authtype>' + xmlUtility.xmlencode(authtype) + '</authtype>' +
            //     '<users>1</users>' +
            //     '<contactname>' + xmlUtility.xmlencode(userinfo.name) + '</contactname>' +
            //     '<contactemail>' + xmlUtility.xmlencode(userinfo.email) + '</contactemail>' +
            //     '<contactcompany>' + xmlUtility.xmlencode(userinfo.company) + '</contactcompany>' +
            //     '<contactphone>' + xmlUtility.xmlencode(userinfo.phone) + '</contactphone>' +
            //     '<contacttitle>' + xmlUtility.xmlencode(userinfo.title) + '</contacttitle>' +
            //     //'<username>' + xmlUtility.xmlencode(userinfo.username) + '</username>' +
            //     //'<password>' + xmlUtility.xmlencode(userinfo.password) + '</password>' +
            //     '<agreetoeula>True</agreetoeula>' +
            //     '</request>';

            var params = {
                crmid: xmlUtility.xmlencode('chrome-sf:' + userinfo.email),
                crmid2: xmlUtility.xmlencode(userinfo.target || 'no'),
                appkey: xmlUtility.xmlencode(userinfo.key),
                crmtype: xmlUtility.xmlencode(crmtype),
                crmlabel: xmlUtility.xmlencode(userInfoStore.getCrmId()),
                authtype: xmlUtility.xmlencode(authtype),
                users: 1,
                contactname: xmlUtility.xmlencode(userinfo.name),
                contactemail: xmlUtility.xmlencode(userinfo.email),
                contactcompany: xmlUtility.xmlencode(userinfo.company),
                contactphone: xmlUtility.xmlencode(userinfo.phone),
                contacttitle: xmlUtility.xmlencode(userinfo.title),
                agreetoeula: true
            };

            var config = {
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json' }
            };
            if (debug) { console.log('registrationService.register...', { url: url, params: params, config: config }); }
            //return;


            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('registrationService.register:', response); }
                    if (!response) {
                        if (debug) { console.log('Unknown registration response:', response); }
                        try { failureCallback('Registration is unavailable. Please try again later. Error code: RS-153.'); } catch (e) { }
                    } else if (response.success) {
                        //  Legacy stuff
                        //  Save profile for backward compatibility
                        chromeUtility.setField('profile', userinfo);

                        //  Save account info for backward compatibility
                        chromeUtility.setField('account', { sitekey: response.sitekey, auth: response.auth, uid: response.uid, settings: { target: 'sf' } });

                        userInfoStore.setSiteKey(response.sitekey);
                        userInfoStore.setShieldId(response.uid);
                        userInfoStore.setShieldAuth(response.auth);

                        /*
                        store.persistent.siteKey = response.sitekey;
                        userInfoStore.siteKey = response.sitekey;
                        store.persistent.auth = response.auth;
                        store.persistent.uId = response.uid;
                        store.persistent.crmId = userinfo.crmid;
                        saveStore();
                        */
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('registrationService.register.error:' + status, data); }
                    // TODO: Catch individual status codes here
                    try { failureCallback('Registration was unsuccessful. Please fill out all fields and try again, or contact support@broadlook.com'); } catch (e) { }
                });
        },

        me: function (userinfo, successCallback, failureCallback) {
            //  successCallback(siteKey, auth, uid)
            //  failureCallback(errorMessage)
            var service = this;
            var crmtype = 'salesforce';
            var authtype = 'Chrome';
            var url = endpoints.accountService() + 'api/v1/org/getsitekey?id=chrome-sf:' + userinfo.email;

            var config = {
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json' }
            };

            if (debug) { console.log('registrationService.me...', { url: url, config: config }); }

            $http.get(url, config)
                .success(function (response) {
                    if (debug) { console.log('registrationService.me:', response); }
                    if (!response) {
                        try { failureCallback('Service is unavailable. Please try again later. Error code: RS-202.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(response); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('registrationService.me.error:' + status, data); }
                    try { failureCallback('Not available'); } catch (e) { }
                });
        },


        getLimits: function (successCallback, failureCallback) {
            //  successCallback(license)
            //  failureCallback(errorMessage)
            var release = environmentUtility.getRelease();
            var url = endpoints.accountService() + 'api/v1/org/getapplimits';
            var params = { crmid: userInfoStore.getCrmId(), sitekey: userInfoStore.getSiteKey(), release: release };
            var config = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json' } };
            if (debug) { console.log('registrationService.getLimits->request', { url: url, params: params, config: config }); }

            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('registrationService.getLimits->response', response); }

                    //  Server says no
                    if (!response.success) {
                        try { failureCallback(response.message); } catch (e) { }
                        return;
                    }

                    var license = { export: {}, full: {}, limited: {}, messages: [] };

                    if (response.messages) {
                        for (var j = 0; j < response.messages.length; j++) {
                            license.messages.push({ id: j, text: response.messages[j], hidden: false });
                        }
                        console.log('***********messages',  license.messages);
                    }

                    license.date = new Date();
                    license.dateMS = license.date.getTime();
                    license.limits = response.applimits;
                    license.exp = null;
                    license.pageTokens = 0;
                    license.listTokens = 0;
                    license.contactTokens = 0;
                    license.companyTokens = 0;
                    //license.exportCount = 0;
                    //license.exportLimit = 0;
                    license.parent = null;

                    var i = license.limits.length;

                    while (i--) {
                        var rec = license.limits[i];
                        var pp;
                        if (rec.LimitCode === 'SUBSCRIPTION') {
                            pp = rec.LimitValue.split('-');
                            license.exp = new Date(pp[0], pp[1] - 1, pp[2]);
                            console.log('exp', license.exp, ' received value=', rec.LimitValue);
                            license.expMS = license.exp.getTime();
                        } else if (rec.LimitCode === 'LASTSTATEMENT') {
                            pp = rec.LimitValue.split('-');
                            license.last = new Date(pp[0], pp[1] - 1, pp[2]);
                            console.log('last', license.last, ' received value=', rec.LimitValue);
                            license.lastMS = license.exp.getTime();
                        } else if (rec.LimitCode === 'NEXTSTATEMENT') {
                            pp = rec.LimitValue.split('-');
                            license.next = new Date(pp[0], pp[1] - 1, pp[2]);
                            console.log('next', license.next, ' received value=', rec.LimitValue);
                            license.nextMS = license.exp.getTime();
                        } else if (rec.LimitCode === 'PAGESEARCH') {
                            license.pageTokens = rec.LimitValue;
                        } else if (rec.LimitCode === 'COMPANYRESEARCH') {
                            license.companyTokens = rec.LimitValue;
                        } else if (rec.LimitCode === 'LISTSEARCH') {
                            license.listTokens = rec.LimitValue;
                        } else if (rec.LimitCode === 'CONTACTRESEARCH') {
                            license.contactTokens = rec.LimitValue; // obsolete
                            license.full.current = rec.LimitValue;
                        } else if (rec.LimitCode === 'LIMITEDCONTACTRESEARCH') {
                            license.limited.current = rec.LimitValue;
                        } else if (rec.LimitCode === 'EXPORTLIMIT') {
                            //license.exportLimit = rec.LimitValue;
                            license.export.current = rec.LimitValue;
                            //} else if (rec.LimitCode === 'EXPORTCOUNT') {
                            //    license.exportCount = rec.LimitValue;
                        } else if (rec.LimitCode === 'LICENSETYPE') {
                            license.licenseType = rec.LimitValue;
                        } else if (rec.LimitCode === 'CONTACTRESEARCHBEGINNINGBALANCE') {
                            license.full.beginning = rec.LimitValue;
                        } else if (rec.LimitCode === 'CONTACTRESEARCHCURRENTUSAGE') {
                            license.full.usage = rec.LimitValue;
                        } else if (rec.LimitCode === 'CONTACTRESEARCHMONTHLYLIMIT') {
                            license.full.monthly = rec.LimitValue;
                        } else if (rec.LimitCode === 'LIMITEDCONTACTRESEARCHBEGINNINGBALANCE') {
                            license.limited.beginning = rec.LimitValue;
                        } else if (rec.LimitCode === 'LIMITEDCONTACTRESEARCHCURRENTUSAGE') {
                            license.limited.usage = rec.LimitValue;
                        } else if (rec.LimitCode === 'LIMITEDCONTACTRESEARCHMONTHLYLIMIT') {
                            license.limited.monthly = rec.LimitValue;
                        } else if (rec.LimitCode === 'EXPORTBEGINNINGBALANCE') {
                            license.export.beginning = rec.LimitValue;
                        } else if (rec.LimitCode === 'EXPORTCURRENTUSAGE') {
                            license.export.usage = rec.LimitValue;
                        } else if (rec.LimitCode === 'EXPORTMONTHLYLIMIT') {
                            license.export.monthly = rec.LimitValue;
                        } else if (rec.LimitCode === 'PARENT') {
                            license.parent = rec.LimitValue;
                        } else if (rec.LimitCode === 'PARENTLIMIT') {
                            license.parentlimit = rec.LimitValue;
                        }
                    }

                    var d = -1; // days of subscription left

                    if (license.exp === null || isNaN(license.exp.getTime()) || license.exp.getFullYear() < 2012) {
                        license.subStatus = 'Not subscribed';
                    }
                    else {

                        d = contactUtility.daysBetween(license.exp, new Date(), true);

                        if (d < 90)
                        { license.subStatus = 'Expired'; }
                        if (d < 0)
                        { license.subStatus = 'Expired ' + (-d) + ' days ago'; }
                        else if (d === 0)
                        { license.subStatus = 'Expires today'; }
                        else if (d <= 1)
                        { license.subStatus = 'Expires tomorrow'; }
                        else if (d <= 30)
                        { license.subStatus = 'Expires in ' + (d) + ' days'; }
                        else
                        { license.subStatus = 'Expires in ' + Math.round(d / 30) + ' months'; }

                        var nextDate = license.next;
                        var annivDay = nextDate.getDate();
                        var annivMonthNum = nextDate.getMonth() + 1;
                        var annivYear = nextDate.getFullYear();

                        //expDate.setDate(expDate.getDate() + 1);
                        //var annivDay = expDate.getDate();

                        //var todayDay = (new Date()).getDate();
                        //var dt = new Date();
                        //var annivYear = dt.getFullYear();
                        //if (todayDay >= annivDay) {
                        //    dt.setMonth(dt.getMonth() + 1);
                        //    if (dt.getMonth() === 0) { annivYear++; }
                        //}
                        //var annivMonthNum = dt.getMonth() + 1;
                        var annivMonth = '';
                        if (annivMonthNum === 1) { annivMonth = 'January'; }
                        if (annivMonthNum === 2) { annivMonth = 'February'; }
                        if (annivMonthNum === 3) { annivMonth = 'March'; }
                        if (annivMonthNum === 4) { annivMonth = 'April'; }
                        if (annivMonthNum === 5) { annivMonth = 'May'; }
                        if (annivMonthNum === 6) { annivMonth = 'June'; }
                        if (annivMonthNum === 7) { annivMonth = 'July'; }
                        if (annivMonthNum === 8) { annivMonth = 'August'; }
                        if (annivMonthNum === 9) { annivMonth = 'September'; }
                        if (annivMonthNum === 10) { annivMonth = 'October'; }
                        if (annivMonthNum === 11) { annivMonth = 'November'; }
                        if (annivMonthNum === 12) { annivMonth = 'December'; }

                        var dateStr = annivMonth + ' ' + annivDay + ', ' + annivYear;
                        license.nextPeriod = dateStr;
                    }

                    license.subscribed = d >= 0;

                    try { successCallback(license); } catch (e) { }
                })
                .error(failureCallback);
        }
    };
    return service;

}]);


'use strict';

/* global angular: false */
/* global timeout_id: true */

angular.module('webServices')
    .factory('researchService', ['$http', 'endpoints', 'xmlUtility', 'userInfoStore', function ($http, endpoints, xmlUtility, userInfoStore) {
        var debug = 'researchService->';
        var serviceUrl = endpoints.researchService() + 'api/v1/contact/enhance';

        var defaultPostConfig = { headers: {'Content-Type': 'application/xml', 'Accept': 'application/json'} };

        var postMethod = function(method, url, params, cfg, successCallback, failureCallback) {
            if(debug){ console.log(debug + method + '...',{url:url, params:params}); }
            $http.post(url, params, cfg)
                .success(function(response, status){
                        if(debug){ console.log(debug + method,response); }
                        if(response.success){
                            try{successCallback(response);}catch(e){}
                        }else{
                            try{failureCallback(response.message, status);}catch(e){}
                        }
                    })
                .error(function(response, status){
                        if(debug){ console.log(debug + method,{response:response, status:status}); }
                        try{failureCallback(response, status);}catch(e){}
                    });
        };

        var self = {
            modes: {
                limited: 'limited',
                full: 'full'
            },

            //  Perform immediate job (no queue)
            quick: function(contactXml, mode, successCallback, failureCallback){
                var params = xmlUtility.encodeParameters({
                        crmid:          userInfoStore.getCrmId(),
                        sitekey:        userInfoStore.getSiteKey(),
                        runmode:        'immediate',
                        researchmode:   mode,
                        dataformat:     'text/html',
                        data:           contactXml
                    });
                postMethod('quick', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            },

            //  Queue up a job
            enqueue: function (contactXml, mode, successCallback, failureCallback) {
                var params = xmlUtility.encodeParameters({
                        crmid:          userInfoStore.getCrmId(),
                        sitekey:        userInfoStore.getSiteKey(),
                        runmode:        'queue',
                        researchmode:   mode,
                        dataformat:     'text/html',
                        data:           contactXml
                    });
                postMethod('enqueue', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            },

            //  Poll a job id for status
            poll: function(jobId, successCallback, failureCallback){
                var params = xmlUtility.encodeParameters({
                        crmid:          userInfoStore.getCrmId(),
                        sitekey:        userInfoStore.getSiteKey(),
                        runmode:        'get',
                        jobid:          jobId,
                        data:           '-'
                    });
                postMethod('poll', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            }

        };

        return self;

    }]);
'use strict';

/* global angular: false */

angular.module('webServices')
.factory('storageService', ['$http', 'endpoints', 'xmlUtility', 'contactUtility', 'chromeUtility', 'userInfoStore', function ($http, endpoints, xmlUtility, contactUtility, chromeUtility, userInfoStore) {
    var debug = 'storage-service.js->'; debug = false;

    var setProfile = function (profile) {
        //store.persistent.profile = profile;
        //saveStore();
    };

    var service = {

        get: function (keys, successCallback, failureCallback) {
            var service = this;

            var url = endpoints.storageService() + 'get';

            var params = {
                keys: keys
            };

            var config = {
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() }
            };
            if (debug) { console.log('storageService.get...', { url: url, params: params, config: config }); }

            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log(debug + 'get.success', response); }
                    if (!response) {
                        if (debug) { console.log('Unknown storage service response:', response); }
                        try { failureCallback('Storage service is unavailable. Please try again later. Error code: SS-68.'); } catch (e) { }
                    } else if (response.success) {
                        var o = {};
                        for (var i = 0; i < response.values.length; i++) {
                            var key = response.values[i].key;

                            var value = response.values[i].value;
                            if (value !== null && value !== '')
                            { value = JSON.parse(value); }

                            //var value = JSON.parse(response.values[i].value);
                            o[key] = value;
                        }
                        try { successCallback(o); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log(debug + 'get.error:' + status); }
                    try { failureCallback('Storage service is not available. Please try again later. Error code: SS-88. Url: ' + (url || '')); } catch (e) { }
                });
        },

        set: function (values, successCallback, failureCallback) {
            var service = this;

            var url = endpoints.storageService() + 'set';

            var params = {
                values: []
            };

            for (var prop in values) {
                if (values[prop] !== null && prop) {
                    params.values.push({ key: prop, value: JSON.stringify(values[prop]) });
                }
            }

            var config = {
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() }
            };
            if (debug) { console.log('storageService.set...', { url: url, params: params, config: config }); }

            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('storageService.set:', response); }
                    if (!response) {
                        if (debug) { console.log('Unknown storage service response:', response); }
                        try { failureCallback('Storage service is unavailable. Please try again later. Error code: SS-118.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('storageService.set.error:' + status, data); }
                    try { failureCallback('Storage service is unavailable. Please try again later. Error code: SS-127.'); } catch (e) { }
                });
        }
    };
    return service;

}]);


'use strict';

/* global angular: false */

angular.module('webServices')
.factory('diverService', ['$http', 'xmlUtility', function ($http, xmlUtility) {
    return {
        //  Debugging
        debug: true,

        //  Endpoint declaration
        endpoints: {
            production: 'http://wprpc.broadlook.com/rpc2/',

            //  Points to desired target
            current: function(){ return this.production; }
        },

        //  successCallback: function(response, status, headers, config)
        //  failureCallback: function(response, status, headers, config)
        executeDiveCommand: function (www, html, options, key_hash, successCallback, failureCallback)
        {
            if(this.debug) { console.log('diverService.executeDiveCommand...'); }

            var url = this.endpoints.current();

            var wwwEncoded = xmlUtility.xmlencode(www);
            var params = xmlUtility.prolog + '<methodCall>'+
                         '<methodName>webdiver.search</methodName>'+
                         '<params><param><value><struct>'+
                         '<member><name>key_hash</name><value><string>'+key_hash+'</string></value></member>'+
                         '<member><name>www</name><value><string>'+wwwEncoded+'</string></value></member>'+
                         '<member><name>dataz</name><value><string>'+html+'</string></value></member>'+
                         '<member><name>options</name><value><string>'+options+'</string></value></member>'+
                         '</struct></value></param></params></methodCall>';

            var config = { headers: {'Content-type': 'text/xml'} };

            $http.post(url, params, config).success(successCallback).error(failureCallback);
        },

        //  successCallback: function(response, status, headers, config)
        //  failureCallback: function(response, status, headers, config)
        executeDeleteCommand: function(id, key_hash, successCallback, failureCallback)
        {
            if(this.debug) { console.log('diverService.executeDeleteCommand...'); }

            var url = this.endpoints.current();

            var params = xmlUtility.prolog + '<methodCall>' +
                     '<methodName>webdiver.delete</methodName>' +
                     '<params><param><value><struct>' +
                     '<member><name>key_hash</name><value><string>'+key_hash+'</string></value></member>' +
                     '<member><name>search_id</name><value><string>'+id+'</string></value></member>' +
                     '</struct></value></param></params></methodCall>';

            var config = { headers: {'Content-type': 'text/xml'} };

            $http.post(url, params, config).success(successCallback).error(failureCallback);
        },

        executeLoadCommand: function (search_id, storage, successCallback, failureCallback)
        {
            if(this.debug) { console.log('diverService.executeLoadCommand...'); }

            var url = 'http://'+storage+'/result.php?task='+search_id+'&format=fullxml';
            var config = { headers: {'Content-type': 'text/xml'} };
            $http.get(url, config).success(successCallback).error(failureCallback);
        },

        executeSyncCommand: function (key_hash, successCallback, failureCallback)
        {
            if(this.debug) { console.log('diverService.executeSyncCommand...'); }

            var url = this.endpoints.current();

            var params = xmlUtility.prolog + '<methodCall>' +
                     '<methodName>webdiver.status</methodName>' +
                     '<params><param><value><struct>' +
                     '<member><name>key_hash</name><value><string>'+key_hash+'</string></value></member>' +
                     '<member><name>www</name><value><string></string></value></member>' +
                     '<member><name>uncompleted</name><value><string>0</string></value></member>' +
                     '<member><name>account_info</name><value><string></string></value></member>' +
                     '</struct></value></param></params></methodCall>';

            var config = { headers: {'Content-type': 'text/xml'} };

            $http.post(url, params, config).success(successCallback).error(failureCallback);
        },

        executeProgressCommand: function (key_hash, successCallback, failureCallback)
        {
            if(this.debug) { console.log('diverService.executeProgressCommand...'); }

            var url = this.endpoints.current();

            var params = xmlUtility.prolog + '<methodCall>' +
                     '<methodName>webdiver.status</methodName>' +
                     '<params><param><value><struct>' +
                     '<member><name>key_hash</name><value><string>'+key_hash+'</string></value></member>' +
                     '<member><name>www</name><value><string></string></value></member>' +
                     '<member><name>uncompleted</name><value><string>1</string></value></member>' +
                     '<member><name>account_info</name><value><string></string></value></member>' +
                     '</struct></value></param></params></methodCall>';

            var config = { headers: {'Content-type': 'text/xml'} };

            $http.post(url, params, config).success(successCallback).error(failureCallback);
        }


    };
}]);
'use strict';

/* global angular: false */
/* global timeout_id: true */

angular.module('webServices')
    .factory('profilerService', ['$http', 'endpoints', 'xmlUtility', function ($http, endpoints, xmlUtility) {

        var urls = endpoints.profilerService();
        var accountsServerURL = urls.accounts;
        var webProfilerURL = urls.webProfiler;

        var defaultPostConfig = { headers: {'Content-type': 'text/xml'} };

        var loadCommandConfig = {
                headers: {
                    'Content-type': 'text/xml',
                    'Accept': 'application/json'
                }
        };

        var postMethod = function(url, params, config, successCallback, failureCallback) {
            var cfg = config || defaultPostConfig;
            $http.post(webProfilerURL, params, cfg).success(successCallback).error(failureCallback);
        };

        var profiler = {

            serverUrl:   accountsServerURL,

            hello: function () {
                return 'hello from profiler';
            },

            executeDeleteCommand: function (id, key_hash, successCallback, failureCallback) {
                var params = xmlUtility.prolog + '<methodCall>' +
                    '<methodName>webprofiler.deleteSearch</methodName>' +
                    '<params><param><value><struct>' +
                    '<member><name>key_hash</name><value><string>' + key_hash + '</string></value></member>' +
                    '<member><name>search_id</name><value><string>' + id + '</string></value></member>' +
                    '</struct></value></param></params></methodCall>';

                /* TODO: add failureCallback */
                postMethod(webProfilerURL, params, defaultPostConfig, successCallback, failureCallback);
            },

            executeLoadCommand: function (storage, successCallback, failureCallback) {

                var crmid = 'blcrm';

                var params = xmlUtility.prolog +
                    '<request>' +
                    '<crmid>' + crmid + '</crmid>' +
                    '<storageurl>' + storage + '</storageurl>' +
                    '</request>';

                var url = profiler.serverUrl + 'api/v1/profiler/load';
                /* TODO: add failureCallback */
                postMethod(url, params, loadCommandConfig, successCallback, failureCallback);

                /*
                // TODO: delete this

                var http = new XMLHttpRequest();
                http.onreadystatechange = callback;
                http.open('POST', url, true);
                http.setRequestHeader('Content-type', 'application/xml');
                http.setRequestHeader('Accept', 'application/json');
                http.send(params);
                */

            },

            executeSyncCommand: function (key_hash, successCallback, failureCallback) {
                var params = xmlUtility.prolog + '<methodCall>' +
                    '<methodName>webprofiler.getStatus</methodName>' +
                    '<params><param><value><struct>' +
                    '<member><name>key_hash</name><value><string>' + key_hash + '</string></value></member>' +
                    '<member><name>www</name><value><string></string></value></member>' +
                    '<member><name>uncompleted</name><value><string>0</string></value></member>' +
                    '<member><name>account_info</name><value><string></string></value></member>' +
                    '</struct></value></param></params></methodCall>';

                /* TODO: add failureCallback */
                postMethod(webProfilerURL, params, defaultPostConfig, successCallback, failureCallback);

                /*
                 // TODO: delete this

                 var http = new XMLHttpRequest();
                http.onreadystatechange = callback;
                http.open('POST', webProfilerURL, true);
                http.setRequestHeader('Content-type', 'text/xml');
                http.send(params);
                */
            },

            executeProgressCommand: function (key_hash, successCallback, failureCallback) {
                timeout_id = 0;

                var params = xmlUtility.prolog + '<methodCall>' +
                    '<methodName>webprofiler.getStatus</methodName>' +
                    '<params><param><value><struct>' +
                    '<member><name>key_hash</name><value><string>' + key_hash + '</string></value></member>' +
                    '<member><name>www</name><value><string></string></value></member>' +
                    '<member><name>uncompleted</name><value><string>1</string></value></member>' +
                    '<member><name>account_info</name><value><string></string></value></member>' +
                    '</struct></value></param></params></methodCall>';

                /* TODO: add failureCallback */
                postMethod(webProfilerURL, params, defaultPostConfig, successCallback, failureCallback);

                /*
                 // TODO: delete this

                var http = new XMLHttpRequest();
                http.onreadystatechange = callback; //ProcessProgressRequest;
                http.open('POST', webProfilerURL, true);
                http.setRequestHeader('Content-type', 'text/xml');
                http.send(params);
                */
            },

            executeQuickSearchCommand: function (www, key_hash, successCallback, failureCallback) {
                var www2 = xmlUtility.xmlencode(www);
                var params = xmlUtility.prolog + '<methodCall>' +
                    '<methodName>webprofiler.quickSearch</methodName>' +
                    '<params><param><value><struct>' +
                    '<member><name>key_hash</name><value><string>' + key_hash + '</string></value></member>' +
                    '<member><name>www</name><value><string>' + www2 + '</string></value></member>' +
                    '</struct></value></param></params></methodCall>';


                /* TODO: add failureCallback */
                postMethod(webProfilerURL, params, defaultPostConfig, successCallback, failureCallback);

                /*
                 // TODO: delete this

                 var http = new XMLHttpRequest();
                http.onreadystatechange = callback;
                http.open('POST', webProfilerURL, true);
                http.setRequestHeader('Content-type', 'text/xml');
                http.send(params);
                */
            },

            executeBatchSearchCommand: function (wwws, key_hash, successCallback, failureCallback) {
                var www2 = xmlUtility.xmlencode(wwws);
                var params = xmlUtility.prolog + '<methodCall>' +
                    '<methodName>webprofiler.queueAdd</methodName>' +
                    '<params><param><value><struct>' +
                    '<member><name>key_hash</name><value><string>' + key_hash + '</string></value></member>' +
                    '<member><name>wwws</name><value><string>' + www2 + '</string></value></member>' +
                    '</struct></value></param></params></methodCall>';


                /* TODO: add failureCallback */
                postMethod(webProfilerURL, params, defaultPostConfig, successCallback, failureCallback);

                /*
                 // TODO: delete this
                var http = new XMLHttpRequest();
                http.onreadystatechange = callback;
                http.open('POST', webProfilerURL, true);
                http.setRequestHeader('Content-type', 'text/xml');
                http.send(params);
                */
            }

        };

        return profiler;

    }]);
'use strict';

/* global angular: false */

angular.module('webServices')
    .factory('searchesService', ['$http', 'endpoints', 'xmlUtility', 'userInfoStore', function ($http, endpoints, xmlUtility, userInfoStore) {
        //---- PRIVATE ----
        var debug = 'searches-service.js->';
        debug = false;
        var overrideCache = false;
        var searchesMap = {};
        var teams = {
            _list: [],
            _onChangeCallbacks: [],
            _notifyChanged: function(){
                for(var index in this._onChangeCallbacks){
                    this._onChangeCallbacks[index](this._list);
                }
            },
            set onChanged (callback){
                this._onChangeCallbacks.push(callback);
            },
            get onChanged (){
                return null;
            },
            set list (val) {
                this._list = val;
                this._notifyChanged();
            },
            get list(){
                return this._list;
            },
            add: function(team){
                this._list.push(team);
                this._notifyChanged();
            }
        };


        var reloadCallbacks = [];


        var urls = endpoints.searchService();

        var endpoint = {
            team: {
                    list:       urls.searches + 'api/v1/search/GetTeams',
                    add:        urls.searches + 'api/v1/search/AddTeam',
                    remove:     urls.searches + 'api/v1/search/RemoveTeam',
                    members: {
                        add:     urls.searches + 'api/v1/search/AddTeamMember',
                        remove:  urls.searches + 'api/v1/search/RemoveTeamMember'
                    },
                    search: {
                        add:     urls.searches + 'api/v1/search/AddTeamSearch'
                    }
            },

            search: {
                team: {
                    find:       urls.searches + 'api/v1/search/GetTeamSearches'


                },

                share:      urls.searches + 'api/v1/search/share',
                unshare:    urls.searches + 'api/v1/search/unshare',
                retrieve:   urls.searches + 'api/v1/search/get2',
                find:       urls.searches + 'api/v1/search/get',
                add:        urls.searches + 'api/v1/search/add',
                update:     urls.searches + 'api/v1/search/edit',
                rate:       urls.searches + 'api/v1/search/comment',

                comments:   {
                    add:        urls.searches + 'api/v1/search/comment',
                    get:        urls.searches + 'api/v1/search/getcomments'
                },

                links:      {
                    add:        urls.searches + 'api/v1/search/link',
                    remove:     urls.searches + 'api/v1/search/delete'
                }
            }
        };
        var defaultConfig = { headers: {'Content-type': 'application/json', 'Accept': 'application/json'} };

        var postMethod = function(url, params, config, successCallback, failureCallback) {
            var cfg = config || defaultConfig;
            if(debug) {console.log('POST',{url:url, config:config, params:params});}
            $http.post(url, params, cfg).success(successCallback).error(failureCallback);
        };

        var getTags = function (s) {
            var tags = xmlUtility.getTags(s);
            var results = [];
            angular.forEach(tags, function (s) {
                if (s && s.length > 2) {
                    results.push(s.substring(1, s.length - 1));
                }
            });
            return results;
        };

        var convertToDate = function(input){
            if (typeof input === 'undefined' || input === null || input === false) { return null; }
            if (!input.getMonth) { // not a date
                var date = null;
                if (typeof input === 'number') {
                    date = new Date(input);
                } else if (typeof input === 'object' && parseInt(input.toString(), 10) > 0) {
                    date = new Date(parseInt(input.toString()));
                } else if (typeof input === 'string' && input.substring(0, 6) === '/Date(') {
                    date = new Date(parseInt(input.substring(6), 10));
                }
                return date;
            }
            return input;
        };

        var convertComment = function(c){
            return {
                comment: c.Comment,
                author: c.Author,
                createdOn: convertToDate(c.CreatedOn)
            };
        };

        var convertRawComment = function(c){
            return {
                comment: c.Comment,
                author: c.Author,
                createdOn: convertToDate(c.CreatedOn)
            };
        };

        var convertRawComments = function(commentArray){
            var list = [];
            for(var index in commentArray){
                list.push(convertRawComment(commentArray[index]));
            }
            return list;
        };



        //  Raw webservice search -> searchesMap (returns search ID)
        var receiveRawSearch = function(search){
            searchesMap[search.SearchID] = {
                searchID: search.SearchID,
                name: search.Name,
                description: search.Description,
                searchEngine: search.SearchEngine,
                searchString: search.SearchString,
                createdOn: convertToDate(search.ModifiedOn ? search.ModifiedOn : search.CreatedOn),
                rating: search.Rating,
                author: search.Author,
                isPrivate: search.IsPrivate,
                isMine: search.IsMine,
                isRated: search.IsRated,
                isFavorite: search.IsFavorite,
                ratingUp: search.RatingUp,
                ratingDown: search.RatingDown,
                commentCount: search.CommentCount,
                vars: getTags(search.SearchString),
                comments: []
            };
            return search.SearchID;
        };

        //  Raw webservices searches array -> searchesMap (returns list of IDs)
        var receiveRawSearches = function(searchesArray){
            var list = [];
            for(var index in searchesArray){
                list.push(receiveRawSearch(searchesArray[index]));
            }
            return list;
        };

        var searches = {

        };


        //---- /PRIVATE ----



        var service = {
            //---- PUBLIC ----
            engines: [
                {name: 'Google', value: 'google', url:'https://www.google.com/search?q='},
                {name: 'Bing', value: 'bing', url:'http://www.bing.com/search?q='},
                {name: 'Yahoo', value: 'yahoo', url:'https://search.yahoo.com/search?p='},
                {name: 'Custom', value: 'custom', url:''}
            ],

            searches: {

                save: function(search, successCallback, failureCallback ){
                    if(search.searchID){ this.update(search, successCallback, failureCallback); }
                    else{ this.create(search, successCallback, failureCallback); }
                },
                create: function(search, successCallback, failureCallback){
                    var url = endpoint.search.add;
                    var req = {
                        sitekey: userInfoStore.getSiteKey(),
                        name: search.name,
                        description: search.description,
                        searchengine: search.searchEngine,
                        searchstring: search.searchString,
                        isprivate: search.isPrivate
                    };
                    if(debug) {console.log('searchesService.search.create...',{url:url, req:req});}
                    postMethod(url,req, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.search.create:',response);}
                            receiveRawSearch(response.search);
                            try{successCallback(search);}catch(e){}
                        }, failureCallback);
                },
                update: function(search, successCallback, failureCallback){
                    var url = endpoint.search.update;
                    var req = {
                        sitekey: userInfoStore.getSiteKey(),
                        name: search.name,
                        description: search.description,
                        searchengine: search.searchEngine,
                        searchstring: search.searchString,
                        isprivate: search.isPrivate,
                        searchid: search.searchID
                    };
                    if(debug) {console.log('searchesService.search.update...',{url:url, req:req});}
                    postMethod(url,req, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.search.update:',response);}
                            receiveRawSearch(response.search);
                            try{successCallback(search);}catch(e){}
                        }, failureCallback);
                },
                remove: function(searchId, successCallback, failureCallback){
                    var request = {searchid: searchId, sitekey: userInfoStore.getSiteKey()};
                    if(debug) {console.log('searchesService.search.remove...',request);}
                    postMethod(endpoint.search.links.remove,request, defaultConfig, successCallback, failureCallback);
                },
                /*
                retrieve: function(publicScope, teamScope, keywordsArray, successCallback, failureCallback){
                    var url = (teamScope ? endpoint.search.team.find : endpoint.search.find);
                    if(debug) {console.log('searchesService.find...',{publicScope:publicScope, keywordsArray:keywordsArray});}
                    var request = {
                        sitekey: userInfoStore.getSiteKey(),
                        includepublic: publicScope,
                        keywords: keywordsArray,
                    };

                    postMethod(url, request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.find:',response);}
                            try{successCallback(receiveRawSearches(response.searches));}catch(e){}
                        }, failureCallback);
                },
                */
                retrieve: function(allowCache, targetScope, targetId, keywordsArray, successCallback, failureCallback){

                    var storageKey = 'searches_' + (targetScope || '0') + '_' + (targetId || '0') + '_' + (keywordsArray || []).join('_');
                    storageKey = storageKey.replace(/[^\w]/g, '_');
                    var storageTsKey = storageKey + '_ts';

                    
                    if (debug) { console.log(debug+'searches->retrieve', ' key=', storageKey, ' allowCache=', allowCache); }

                    var retrieveFromServer = function () {
                        overrideCache = false;

                        var request = {
                            sitekey: userInfoStore.getSiteKey(),
                            scope: targetScope,
                            scopeid: targetId,
                            keywords: keywordsArray,
                        };

                        //if (debug) { console.log('searchesService.searches.retrieve...', request); }

                        postMethod(endpoint.search.retrieve, request, defaultConfig, function (response) {
                            if (debug) { console.log('SEARCHES LOADED FROM SERVER', ' key=', storageKey); }
//                            if (debug) { console.log('searchesService.retrieve:', response); }
                            var o = {};
                            o[storageKey] = response.searches;
                            o[storageTsKey] = Date.now();
                            chrome.storage.local.set(o);
                            try { successCallback(receiveRawSearches(response.searches)); } catch (e) { }
                        }, failureCallback);
                    };

                    if (allowCache) {

                        chrome.storage.local.get([storageKey, storageKey + '_ts'], function (values) {
                            var timeDiff = Math.abs(Date.now() - values[storageTsKey]);
                            var diffMinutes = Math.ceil(timeDiff / (1000 * 60));
                            if (debug) { console.log('SEARCHES LOADED FROM CACHE...', values, ' cache age (minutes)=', diffMinutes, ' key=', storageKey); }
                            if ((values[storageKey] && diffMinutes < 60) && !overrideCache) {
                                if (debug) { console.log('SEARCHES LOADED FROM CACHE', ' key=', storageKey); }
                                try { successCallback(receiveRawSearches(values[storageKey])); } catch (e) { }
                            }
                            else {
                                retrieveFromServer();
                            }
                        });
                    } else {
                        retrieveFromServer();
                    }

                    //var request = {
                    //    sitekey: userInfoStore.getSiteKey(),
                    //    scope: targetScope,
                    //    scopeid: targetId,
                    //    keywords: keywordsArray,
                    //};
                    //if(debug) {console.log('searchesService.retrieve...',request);}
                    //postMethod(endpoint.search.retrieve, request, defaultConfig, function(response){
                    //        if(debug) {console.log('searchesService.retrieve:',response);}
                    //        try{successCallback(receiveRawSearches(response.searches));}catch(e){}
                    //    }, failureCallback);
                },

                share: function(searchId, targetScope, targetId, targetPrivilege, successCallback, failureCallback){

                    var request = {
                        sitekey: userInfoStore.getSiteKey(),
                        searchid: searchId,
                        targetscope: targetScope,
                        targetid: targetId,
                        targetprivilege: targetPrivilege
                    };
                    if(debug) {console.log('searchesService.share...',request);}
                    postMethod(endpoint.search.share, request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.share:',response);}
                            try{successCallback(receiveRawSearches(response.searches));}catch(e){}
                        }, failureCallback);
                },
                unShare: function(searchId, targetScope, targetId, targetPrivilege, successCallback, failureCallback){
                    var request = {
                        sitekey: userInfoStore.getSiteKey(),
                        searchid: searchId,
                        targetscope: targetScope,
                        targetid: targetId,
                        targetprivilege: targetPrivilege
                    };
                    if(debug) {console.log('searchesService.unshare...',request);}
                    postMethod(endpoint.search.unshare, request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.unshare:',response);}
                            try{successCallback(receiveRawSearches(response.searches));}catch(e){}
                        }, failureCallback);
                },

                ratings:{
                    create: function(searchId, direction, successCallback, failureCallback){
                        var request = {searchid: searchId, sitekey: userInfoStore.getSiteKey(), comment: null, rating: direction};
                        if(debug) {console.log('searchesService.search.rate...',request);}
                        postMethod(endpoint.search.rate,request, defaultConfig, function(response){
                                if(debug) {console.log('searchesService.search.rate:',response);}
                                receiveRawSearch(response.search);
                                try{successCallback();}catch(e){}
                            }, failureCallback);
                    }
                },


                comments: {
                    create: function(searchId, comment, successCallback, failureCallback){
                        var request = {searchid: searchId, sitekey: userInfoStore.getSiteKey(), comment: comment, rating: null};
                        if(debug) {console.log('searchesService.rate...',request);}
                        postMethod(endpoint.search.comments.add,request, defaultConfig, successCallback, failureCallback);
                    },
                    retrieve: function(searchId, successCallback, failureCallback){
                        var request = {searchid: searchId, sitekey: userInfoStore.getSiteKey(), searchids:[searchId]};
                        if(debug) {console.log('searchesService.getComments...',request);}
                        postMethod(endpoint.search.comments.get,request, defaultConfig, function(response){
                                if(debug) {console.log('searchesService.getComments:',response);}
                                searchesMap[searchId].comments = convertRawComments(response.comments);
                                searchesMap[searchId].commentsLoaded = true;
                                try{successCallback(response.comments);}catch(e){}
                            }, failureCallback);
                    }
                },



            },

            teams: {
                retrieve: function (ignoreCache, successCallback, failureCallback) {
                    chrome.storage.local.get(['teams','teams_ts'], function (values) {
                        var timeDiff = Math.abs(Date.now() - values.teams_ts);
                        var diffMinutes = Math.ceil(timeDiff / (1000 * 60));
                        if (debug) { console.log('LOADED FROM CACHE...', values, ' cache age (minutes)=', diffMinutes); }
                        if (!ignoreCache && ((values.teams && diffMinutes < 60) && !overrideCache)) {
                            if (debug) { console.log('TEAMS LOADED FROM CACHE'); }
                            teams.list = values.teams;
                            try { successCallback(teams); } catch (e) { }
                        }
                        else {
                            overrideCache = false;
                            if (debug) { console.log('TEAMS LOADED FROM SERVER'); }
                            var request = { sitekey: userInfoStore.getSiteKey() };
                            if (debug) { console.log('searchesService.teams.retrieve...', request); }
                            postMethod(endpoint.team.list, request, defaultConfig, function (response) {
                                if (debug) { console.log('searchesService.teams.retrieve:', response); }
                                chrome.storage.local.set({ teams: response.teams, teams_ts: Date.now()});
                                teams.list = response.teams;
                                try { successCallback(teams); } catch (e) { }
                            }, failureCallback);
                        }
                    });
                },
                create: function(name, successCallback, failureCallback){
                    var request = { sitekey: userInfoStore.getSiteKey(), name: name };
                    if(debug) {console.log('searchesService.teams.create...',request);}
                    postMethod(endpoint.team.add,request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.teams.create:',response);}
                            if(response.success) {
                                overrideCache = true;
                                teams.add({name:name, teamcode:response.teamcode});
                                try{successCallback(teams);}catch(e){}
                            }else{
                                try{failureCallback(response.message);}catch(e){}
                            }

                        }, failureCallback);
                },
                join: function(teamCode, successCallback, failureCallback){
                    var request = { sitekey: userInfoStore.getSiteKey(), teamcode: teamCode, memberemail: userInfoStore.getProfileEmail() };
                    if(debug) {console.log('searchesService.teams.join...',request);}
                    postMethod(endpoint.team.members.add,request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.teams.join:',response);}
                            if(response.success) {
                                overrideCache = true;
                                try{successCallback();}catch(e){}
                            }else{
                                try{failureCallback(response.message);}catch(e){}
                            }
                        }, failureCallback);
                },
                leave: function(teamCode, successCallback, failureCallback){
                    var request = { sitekey: userInfoStore.getSiteKey(), teamcode: teamCode, memberemail: userInfoStore.getProfileEmail() };
                    if(debug) {console.log('searchesService.teams.leave...',request);}
                    postMethod(endpoint.team.members.remove,request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.teams.leave:',response);}
                            if(response.success) {
                                overrideCache = true;
                                try{successCallback();}catch(e){}
                            }else{
                                try{failureCallback(response.message);}catch(e){}
                            }
                        }, failureCallback);
                },
                remove: function(teamId, successCallback, failureCallback){
                    var request = { sitekey: userInfoStore.getSiteKey(), teamcode:teamId };
                    if(debug) {console.log('searchesService.teams.remove...',request);}
                    postMethod(endpoint.team.remove,request, defaultConfig, function(response){
                            if(debug) {console.log('searchesService.teams.remove:',response);}
                            if(response.success) {
                                overrideCache = true;
                                var list = [];
                                for(var index in teams.list){
                                    if(teams.list[index].teamcode!==teamId){
                                        list.push(teams.list[index]);
                                    }
                                }
                                teams.list = list;
                                try{successCallback(teams.list);}catch(e){}
                            }else{
                                try{failureCallback(response.message);}catch(e){}
                            }
                        }, failureCallback);
                },
            },

            //  Get the searches map {id:search, id:search}  TODO: Cache in local storage
            getMap: function(){
                return searchesMap;
            },

            link: function(searchId, successCallback, failureCallback){
                var request = {searchid: searchId, sitekey: userInfoStore.getSiteKey()};
                if(debug) {console.log('searchesService.link...',request);}
                postMethod(endpoint.search.links.add,request, defaultConfig, successCallback, failureCallback);
            },





            //  Called when teams list changes
            set onTeamsChanged (callback) {
                teams.onChanged = callback;
                callback(teams.list);
            },
            //  JSHint requires a getter :-(
            get onTeamsChanged () { return; },

            //  Getter for teamsList
            get teamsList() {
                return teams.list;
            },

            //  Provide a callback anytime someone wants to reload the searches (kinda an ugly hack)
            //  TODO: create search utility to seperate service and utility
            setReloadCallback: function(callback){
                if(callback) { reloadCallbacks.push(callback); }
            },
            //  Call any reload callbacks that have been registered
            reload: function(){
                for(var index in reloadCallbacks){
                    reloadCallbacks[index]();
                }
            },

            
            getTeams: function(){ return teams; },

            linkToTeam: function(searchId, teamCode, successCallback, failureCallback){
                var me = this;
                var request = { sitekey: userInfoStore.getSiteKey(), teamcode: teamCode, searchid: searchId };
                if(debug) {console.log('searchesService.linkToTeam...',request);}
                postMethod(endpoint.team.search.add,request, defaultConfig, function(response){
                        if(debug) {console.log('searchesService.linkToTeam:',response);}
                        if(response.success) {
                            try{successCallback();}catch(e){}
                        }else{
                            try{failureCallback(response.message);}catch(e){}
                        }

                    }, failureCallback);
            },

            //---- /PUBLIC ----
        };

        return service;

    }]);
'use strict';

/* global angular: false */
/* global timeout_id: true */

angular.module('webServices')
    .factory('lookupService', ['$http', 'endpoints', 'xmlUtility', 'userInfoStore', function ($http, endpoints, xmlUtility, userInfoStore) {
        var debug = 'lookupService->'; debug = false;
        var serviceUrl = endpoints.researchService() + 'api/v1/profiler/'; //querycompanywebsite

        var defaultPostConfig = { headers: {'Content-Type': 'application/json', 'Accept': 'application/json'} };

        var postMethod = function(method, url, params, cfg, successCallback, failureCallback) {
            if(debug){ console.log(debug + method + '...',{url:url, params:params}); }
            $http.post(url + method, params, cfg)
                .success(function(response, status){
                        if(debug){ console.log(debug + method,response); }
                        if(response.success){
                            try{successCallback(response);}catch(e){}
                        }else{
                            try{failureCallback(response.message, status);}catch(e){}
                        }
                    })
                .error(function(response, status){
                        if(debug){ console.log(debug + method,{response:response, status:status}); }
                        try{failureCallback(response, status);}catch(e){}
                    });
        };

        var self = {

            //  Search for company website by name
            lookupCompanyWebsite: function (companyName, successCallback, failureCallback) {
                var params = {
                        crmid:          userInfoStore.getCrmId(),
                        sitekey:        userInfoStore.getSiteKey(),
                        name:           companyName,
                        mode:           'quick'
                    };
                postMethod('querycompanywebsite', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            },

            //  Search for company name by website
            lookupCompanyName: function (website, successCallback, failureCallback) {
                var params = {
                    crmid:          userInfoStore.getCrmId(),
                    sitekey:        userInfoStore.getSiteKey(),
                    website:        website
                };
                postMethod('querycompanyname', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            },

            //  Log company name-website pair
            logCompanyWebsite: function (companyName, companyWebsite, successCallback, failureCallback) {
                var params = {
                        crmid:          userInfoStore.getCrmId(),
                        sitekey:        userInfoStore.getSiteKey(),
                        name:           companyName,
                        website:        companyWebsite
                    };
                postMethod('logcompanywebsite', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            },

            //  Log company name-website pair
            logEmailPattern: function (companyDomain, emailPattern, successCallback, failureCallback) {
                var params = {
                    crmid:          userInfoStore.getCrmId(),
                    sitekey:        userInfoStore.getSiteKey(),
                    domain:         companyDomain,
                    template:       emailPattern
                };
                postMethod('logcompanyemail', serviceUrl, params, defaultPostConfig, successCallback, failureCallback);
            }

        };

        return self;

    }]);
'use strict';

/* global angular: false */

angular.module('webServices')
.factory('limitService', ['$http', 'endpoints', 'xmlUtility', 'contactUtility', 'chromeUtility', 'userInfoStore', function ($http, endpoints, xmlUtility, contactUtility, chromeUtility, userInfoStore) {

    var debug = 'limit-sertvice.js->';

    var subaccounts = {
        _list: [],
        _onChangeCallbacks: [],
        _notifyChanged: function () {
            for (var index in this._onChangeCallbacks) {
                this._onChangeCallbacks[index](this._list);
            }
        },
        set onChanged(callback) {
            this._onChangeCallbacks.push(callback);
        },
        get onChanged() {
            return null;
        },
        set list(val) {
            this._list = val;
            this._notifyChanged();
        },
        get list() {
            return this._list;
        },
        add: function (subaccount) {
            this._list.push(subaccount);
            this._notifyChanged();
        }
    };

    var service = {


        //use: function (value, successCallback, failureCallback) {

        //},

        useExport: function (value, successCallback, failureCallback) {

            var service = this;

            var url = endpoints.limitService() + 'useapplimits';

            var params = {
                crmid: userInfoStore.getCrmId(),
                sitekey: userInfoStore.getSiteKey(),
                limitcode: 'EXPORTCOUNT',
                limitvalue: value
            };

            var config = {
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() }
            };
            if (debug) { console.log('limitService.set...', { url: url, params: params, config: config }); }

            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('limitService.set:', response); }
                    if (!response) {
                        if (debug) { console.log('Unknown limit service response:', response); }
                        try { failureCallback('Limit service is unavailable. Please try again later. Error code: LS-67.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('limitService.set.error:' + status, data); }
                    if (data && data.message) {
                        try { failureCallback(data.message); } catch (e) { }
                    }
                    else {
                        try { failureCallback('Limit service is unavailable. Please try again later.  Error code: LS-76.'); } catch (e) { }
                    }
                });
        },

        retrieveSubaccounts: function (successCallback, failureCallback) {
            var service = this;
            var url = endpoints.limitService() + 'GetSubaccounts';
            var config = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() } };
            $http.get(url, config)
                .success(function (response) {
                    if (debug) { console.log('limitService.retrieveSubaccounts:', response); }
                    if (!response) {
                        try { failureCallback('Service is unavailable. Please try again later.  Error code: LS-88.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(response.list); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('limitService.retrieveSubaccounts.error:' + status, data); }
                    try { failureCallback('Limit service is unavailable. Please try again later. Error code: LS-97.'); } catch (e) { }
                });
        },

        connectSubaccount: function (email, successCallback, failureCallback) {
            var service = this;
            var url = endpoints.limitService() + 'ConnectSubaccount';
            var params = { email: email };
            var config = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() } };
            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('limitService.connectSubaccount:', response); }
                    if (!response) {
                        try { failureCallback('Service is unavailable. Please try again later.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('limitService.connectSubaccount.error:' + status, data); }
                    try { failureCallback('Limit service is unavailable. Please try again later. Error code: LS-119.'); } catch (e) { }
                });
        },

        disconnectSubaccount: function (email, successCallback, failureCallback) {
            var service = this;
            var url = endpoints.limitService() + 'DisconnectSubaccount';
            var params = { email: email };
            var config = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() } };
            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('limitService.connectSubaccount:', response); }
                    if (!response) {
                        try { failureCallback('Service is unavailable. Please try again later. Error code: LS-132.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('limitService.connectSubaccount.error:' + status, data); }
                    try { failureCallback('Limit service is unavailable. Please try again later.  Error code: LS-141.'); } catch (e) { }
                });
        },

        disconnectFromParent: function (successCallback, failureCallback) {
            var service = this;
            var url = endpoints.limitService() + 'DisconnectFromParent';
            var params = { };
            var config = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() } };
            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('limitService.connectSubaccount:', response); }
                    if (!response) {
                        try { failureCallback('Service is unavailable. Please try again later. Error code: LS-154.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('limitService.connectSubaccount.error:' + status, data); }
                    try { failureCallback('Limit service is unavailable. Please try again later. Error code: LS-163.'); } catch (e) { }
                });
        },

        setSubaccountLimit: function (limit, email, successCallback, failureCallback) {
            var service = this;
            var url = endpoints.limitService() + 'SetSubaccountLimit';
            var params = { email: email, limit: limit };
            var config = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json', 'BroadlookSitekey': userInfoStore.getSiteKey() } };
            $http.post(url, params, config)
                .success(function (response) {
                    if (debug) { console.log('limitService.setSubaccountLimit:', response); }
                    if (!response) {
                        try { failureCallback('Service is unavailable. Please try again later. Error code: LS-175.'); } catch (e) { }
                    } else if (response.success) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failureCallback(response.message); } catch (e) { }
                    }
                })
                .error(function (data, status, headers, config) {
                    if (debug) { console.log('limitService.setSubaccountLimit.error:' + status, data); }
                    try { failureCallback('Limit service is unavailable. Please try again later.  Error code: LS-185.'); } catch (e) { }
                });
        },

    };
    return service;

}]);


'use strict';

/* global angular: false */
/* global timeout_id: true */

angular.module('webServices')
    .factory('shieldService', ['$http', 'contactUtility', 'endpoints', 'xmlUtility', 'userInfoStore', function ($http, contactUtility, endpoints, xmlUtility, userInfoStore) {

        var postMethod = function (url, params, config, successCallback, failureCallback) {

            var defaultConfig = { headers: { 'Content-type': 'application/json' } };
            var cfg = config || defaultConfig;

            var shieldServiceURL = endpoints.shieldService().v2;
            var postUrl = shieldServiceURL + url;

            $http.post(postUrl, params, cfg).success(successCallback).error(failureCallback);
        };

        var shield = {

            getNormalizationScheme: function (successCallback, failureCallback) {

                var url = 'schema';
                
                var cfg = { headers: { 'Content-type': 'application/json', 'Accept': 'application/json' } };
                var data = {};
                data.crmid = userInfoStore.getCrmId();
                data.sitekey = userInfoStore.getSiteKey();

                var dataJson = JSON.stringify(data);

                var successCallback1 = function (response) {
                    var schema = response.schema;
                    try { successCallback(schema); } catch (e) { }
                };

                var failureCallback1 = function (response) {
                    var error = (response ? response.message : '') || 'Cannot load Data Shield scheme';
                    try { failureCallback(error); } catch (e) { }
                };

                postMethod(url, dataJson, cfg, successCallback1, failureCallback1);

            },

            normalize: function (contacts, callback) {

                var uid, sitekey, scheme, url, bljson, jsonString, params, shieldServiceURL;

                try {

                    uid = userInfoStore.getShieldId();
                    sitekey = userInfoStore.getSiteKey();
                    scheme = userInfoStore.getShieldScheme();
                    shieldServiceURL = endpoints.shieldService().v2;
                    url = shieldServiceURL + 'normalize';
                    
                    if (!scheme) { console.log('ERROR in normalize: NO SCHEME!'); return; }
                    if (!uid) { console.log('ERROR in normalize: NO UID!'); return; }
                    if (!sitekey) { console.log('ERROR in normalize: NO SITEKEY!'); return; }

                    bljson = contactUtility.contactsToBlJson(contacts);

                    jsonString = JSON.stringify(bljson);

                    params = '<?xml version="1.0"?>' +
                        '<request>' +
                        '<uid>' + xmlUtility.encode(uid) + '</uid>' +
                        '<sitekey>' + xmlUtility.encode(sitekey) + '</sitekey>' +
                        (scheme ? '<schema>' + xmlUtility.encode(scheme) + '</schema>' : '') +
                        '<data>' + xmlUtility.encode(jsonString) + '</data>' +
                        '</request>';

                    var http = new XMLHttpRequest();
                    http.onreadystatechange = callback;
                    http.open('POST', url, true);
                    http.setRequestHeader('Content-type', 'application/xml');
                    http.setRequestHeader('Accept', 'application/json');
                    http.send(params);

                } catch (e) {
                    console.log('ERROR in normalize: ' + e.message);
                }
            },

            openUI: function (successCallback, failureCallback) {

                var url = 'openui';
                var sitekey = userInfoStore.getSiteKey();
                var cfg = { headers: { 'Content-type': 'application/json', 'BroadlookSitekey': sitekey } };

                var successCallback1 = function (response) {
                    var resultUrl = response.url;
                    try { successCallback(resultUrl); } catch (e) { }
                };

                var failureCallback1 = function (response) {
                    var error = response.message;
                    try { failureCallback(error); } catch (e) { }
                };

                postMethod(url, null, cfg, successCallback1, failureCallback1);

            }
        };

        return shield;

    }]);
'use strict';

/* global angular: false */
/* global timeout_id: true */

angular.module('webServices')
    .factory('exportService', ['$http', 'endpoints', 'xmlUtility', 'userInfoStore', 'contactUtility', function ($http, endpoints, xmlUtility, userInfoStore, contactUtility) {
        var debug = 'exportService->';
        var serviceUrl = endpoints.researchService(); 

        var defaultPostConfig = { headers: { 'Content-Type': 'application/xml', 'Accept': 'application/json' } };

        var postMethod = function (url, params, cfg, successCallback, failureCallback) {

            if (debug) { console.log(debug + 'postMethod', { url: url, params: params }); }

            $http.post(url, params, cfg)
                .success(function (response, status) {
                    if (debug) { console.log(debug + 'Success', response); }


                    try {
                        var contentAsJson = response; //JSON.parse(response);
                        if (!contentAsJson.success && contentAsJson.message) {
                            try { failureCallback(contentAsJson.message, status); } catch (e) { }
                            return;
                        }
                    } catch (e) {
                        //normal for CSV content
                    }
                    
                    try { successCallback(response); } catch (e) { }

                })
                .error(function (response, status) {
                    if (debug) { console.log(debug + 'ERROR', { response: response, status: status }); }
                    try { failureCallback(response, status); } catch (e) { }
                });
        };

        var self = {

            saveAsCsv: function (contacts, successCallback, failureCallback) {

                var crmid, sitekey, url, blxml, params;

                try {

                    url = serviceUrl + 'api/v1/contact/downloadascsv';
                    crmid = userInfoStore.getCrmId();
                    sitekey = userInfoStore.getSiteKey();
                    blxml = contactUtility.contactsToBlXml(contacts);

                    params = '<?xml version="1.0"?>' +
                        '<request>' +
                        '<crmid>' + xmlUtility.xmlencode(crmid) + '</crmid>' +
                        '<sitekey>' + xmlUtility.xmlencode(sitekey) + '</sitekey>' +
                        '<target>CSV</target>' +
                        '<dataformat>' + xmlUtility.xmlencode('text/html') + '</dataformat>' +
                        '<data>' + xmlUtility.xmlencode(blxml) + '</data>' +
                        '</request>';

                    postMethod(url, params, defaultPostConfig, successCallback, failureCallback);

                } catch (e) {
                    console.log('ERROR in saveAsCSV', e.message);
                    try { failureCallback(e.message); } catch (e) { }
                }

            },


        };

        return self;

    }]);
/**
 * @class captureApp.webServices.salesforce
 * @memberOf captureApp.webServices.exportTargetVer2
 * @description This is Salesforce AngularJS service.
 */

'use strict';

/* global angular: false */
/* global jQuery: false */
/* global geographyData: false */
/* global backgroundUtility: false */


angular.module('webServices')//exportService 
//angular.module('exportService')
//.factory('salesforce', ['$http', '$q', '$timeout', 'endpoints', 'dialogs', function ($http, $q, $timeout, endpoints, dialogs) {
.factory('salesforce', ['$http', '$q', '$timeout', 'dialogs', 'userInfoStore', 'bgService', 'environmentUtility', function ($http, $q, $timeout, dialogs, userInfoStore, bgService, environmentUtility) {
    var debug = 'saleforce.js->';
    const consolePrefix = 'Salesforce > ';
    var savedRefreshToken = null;
    var enableOAuth = true;
    var OAuthServer = 'https://account-staging.broadlook.com';
    var store = { cache: {} };
    var invalidSessions = {};
    var enteredValues = {};
    const apiClientApi = 'RingLeadCapture';

    environmentUtility.onLoaded(function () {
        var isLocal = environmentUtility.isRelease('local');
        var isAlpha = environmentUtility.isRelease('alpha');
        var isBeta = environmentUtility.isRelease('beta');
        var isProduction = environmentUtility.isRelease('production');

        if (isBeta || isProduction) {
            OAuthServer = 'https://account.broadlook.com';
        } else {
            OAuthServer = 'https://account-staging.broadlook.com';
        }
        //enableOAuth = isLocal || isAlpha;

        //enableOAuth = isAlpha;
    });

    var mapField = function (source, sourceKey, target, targetKey) {
        var sourceKeyParts = sourceKey.split('.');
        if (sourceKeyParts.length === 2) {
            try {
                target[targetKey] = source[sourceKeyParts[0]][sourceKeyParts[1]];
            } catch (e) {
                target[targetKey] = null;
            }
        }
        else { target[targetKey] = source[sourceKey]; }
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };
    var initStore = function (session, url, refreshToken) {
        const functionName = 'Init Store';
        try {

            if (debug) { console.warn(consolePrefix + functionName, arguments); }

            if (!session) { // logout
                store = { cache: {} };
            }

            if (session && url) {
                store.id = session;
                store.url = url;
                store.ts = new Date();
            }

            console.warn('enableOAuth > ', enableOAuth);
            if (enableOAuth) {
                savedRefreshToken = refreshToken || savedRefreshToken;
                if (!store.id || !store.url) {                   
                    refreshAccessToken(savedRefreshToken); // calls initStore(session, url); refreshToken will be undefined
                }

                //if (refreshToken) {

                //    if (savedRefreshToken !== refreshToken || !store.id || !store.url) {
                //        savedRefreshToken = refreshToken || savedRefreshToken;
                //        refreshAccessToken(refreshToken); // calls initStore(session, url); refreshToken will be undefined
                //    } else {
                //        savedRefreshToken = refreshToken || savedRefreshToken;
                //    }
                //}
            }

            if (debug) { console.log(consolePrefix + functionName, angular.copy(store)); }
        } catch (e) {
            console.error(functionName, e.message);
        }
    };

    var initStoreAsync = function (data) {
        const functionName = 'Init Store';
        try {

            if (debug) { console.warn(consolePrefix + functionName, arguments); }

            var deferred = $q.defer();
           
            var resolve = function () {
                $timeout(function () {
                    deferred.resolve(true);
                }, 1);
            };

            var reject = function (msg) {
                $timeout(function () {
                    deferred.reject(msg);
                }, 1);
            };

            store = { cache: {} };

            var done = false;

            if (data.session && data.url) {
                store.id = data.session;
                store.url = data.url;
                store.ts = new Date();
                done = true;
            }

            console.warn('enableOAuth > ', enableOAuth);

            if (enableOAuth) {
                savedRefreshToken = data.refreshToken || savedRefreshToken;
                if (!store.id || !store.url) {
                    refreshAccessTokenAsync({ refreshToken: savedRefreshToken }); // calls initStore(session, url); refreshToken will be undefined
                    return deferred.promise;
                } else {
                    done = true;
                }
            }

            if (done) { resolve(); } else { reject('Not logged in'); }

            if (debug) { console.log(consolePrefix + functionName, angular.copy(store)); }

            return deferred.promise;
            
        } catch (e) {
            console.error(functionName, e.message);
        }
    };

    var defaultOnSuccessHandler = function (data, status, headers, config, successCallback, failureCallback) {

        if (!data) {
            var message = 'Salesforce API call failed';

            //Read header: Sforce-Limit-Info: api-usage=50035/48000
            var apiUsage = headers('Sforce-Limit-Info');
            if (apiUsage) {
                message += ': ' + apiUsage;
            }

            failureCallback(message);

            return;
        }

        successCallback(data);
    };

    var defaultOnErrorHandler = function (errorResponse, status, failureCallback) {
        const functionName = 'On Error';
        try {
            console.error(consolePrefix + functionName + ' > Status > ', status, ' > Response > ', angular.copy(errorResponse));

            if (errorResponse) {
                if (errorResponse.responseJSON && errorResponse.responseJSON.length > 0 && errorResponse.responseJSON[0].message) {
                    failureCallback(errorResponse.responseJSON[0].message);
                }
                else if (errorResponse.statusText) {
                    failureCallback(errorResponse.statusText);
                }
                else if (errorResponse.length > 0) {

                    var errorCode = errorResponse[0].errorCode;

                    if (errorCode === 'INVALID_SESSION_ID') {
                        service.logout(true);
                        failureCallback('Session expired. Please log in.');
                    }
                    else { failureCallback(errorResponse[0].message); }
                }
                else { failureCallback(errorResponse); }
            }
            else { failureCallback('Salesforce API Error'); }

        } catch (e) {
            console.error(functionName + ' > On Error > ', e.message);
            failureCallback('Salesforce API Exception');
        }

    };

    var checkSession = function () {

        if (!store || typeof store.url === 'undefined') {
            console.error('Session Not initialized > ', angular.copy(store));
            throw { message: 'Session expired. Please log in.' };
        }

    };

    var refreshingToken = false;
    var refreshAccessToken = function (refreshToken) {
        const functionName = 'Refresh Access Token';
        refreshingToken = true;
        var config = {
            method: 'POST',
            url: 'https://login.salesforce.com/services/oauth2/token',
            headers: { 'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded' },
            data: 'grant_type=refresh_token&client_id=3MVG99OxTyEMCQ3gxoS7zJYNasAk6gttQLnv.h_VYo.HG6xh5esLG.s5JPB_.5FyUCqgNxn_RxgWE7AiuZe41&refresh_token=' + refreshToken
        };

        if (debug) { console.log(consolePrefix + functionName + ' > Request > ', config); }

        $http(config).success(function (data, status, headers, config) {

            console.warn('refresh token > ', data);
            refreshingToken = false;
            initStore(data.access_token, data.instance_url);
        });

    };

    var refreshAccessTokenAsync = function (data) {
        const functionName = 'Refresh Access Token';

        var deferred = $q.defer();
        //service.isLoggedIn(
        //    function () { deferred.resolve(true); },
        //    function (msg) { deferred.reject(msg); }
        //);



        var config = {
            method: 'POST',
            url: 'https://login.salesforce.com/services/oauth2/token',
            headers: { 'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded' },
            data: 'grant_type=refresh_token&client_id=3MVG99OxTyEMCQ3gxoS7zJYNasAk6gttQLnv.h_VYo.HG6xh5esLG.s5JPB_.5FyUCqgNxn_RxgWE7AiuZe41&refresh_token=' + data.refreshToken
        };

        if (debug) { console.log(consolePrefix + functionName + ' > Request > ', config); }

        $http(config).success(function (data, status, headers, config) {

            console.warn('refresh token > ', data);

            initStoreAsync(data.access_token, data.instance_url);

            //deferred.resolve(true);
        });

        return deferred.promise;
    };

    var service = {

        getName: function () {
            return 'Salesforce';
        },

        getInterfaceVersion: function () {
            return 2;
        },

        /**
        * @function init
        * @description Initializes store object. Not used for Salesforce.
        * @memberOf captureApp.webServices.exportTargetVer1.salesforce
        * @param {object} settings - List of target-specific settings.
        */
        init: function (settings) {
            if (settings) {
                if (settings.Session && settings.Url) {
                    initStore(settings.Session, settings.Url);
                }

                console.warn('enableOAuth > ', enableOAuth);
                if (enableOAuth) {
                    if (settings.refreshToken || settings.accessToken) {
                        //$q
                        //    .when({ accessToken: settings.accessToken, url: settings.Url, refreshToken: settings.refreshToken })
                        //    .then(initStoreAsync);
                        initStore(settings.accessToken, settings.Url, settings.refreshToken);                       
                    }
                }
            }
        },

        //login: function (successCallback, failCallback, silent) {

        //    console.log('000000000000000000 LOGIN 000000000000000000');

        //    if (debug) { console.log(debug + 'Logging into Salesforce...'); }

        //    if (!store.refreshToken) {
        //        try { failCallback('Please open Settings and enter your user credentials'); } catch (e) { }
        //        return;
        //    }

        //    //var openTab = function () {
        //    //    try {
        //    //        // TODO validate the assumption that any pcrDatabaseId contains uid (before period) and that the url form is the same for all PCR users/orgs 
        //    //        var uid = store.pcrDatabaseId.split('.')[0];
        //    //        chrome.tabs.create({ url: 'https://www2.pcrecruiter.net/pcr.asp?uid=odbc.' + uid }, function () { });
        //    //    } catch (e) {

        //    //    }
        //    //};

        //    var config = {
        //        'client_id': '9ca842e02dce70de6ead42609a88032e569ccd6de8e4cc656d799cf52065eb41',
        //        'client_secret': 'c13303124a00dfc9cdf36dcf5bd045a496632374182e106d1e56c570e6d1f790',
        //        'grant_type': 'refresh_token',
        //        'refresh_token': '4b0d686b856f9645de68192d7fc5d3baaccb91e3d11afac8bb477ef9ab3c64cd'//store.refreshToken
        //    };

        //    var request = buildRequest('', successCallback, failCallback);
        //    request.url = 'https://accounts.salesloft.com/oauth/token';
        //    request.type = 'POST';
        //    request.data = JSON.stringify(config);
        //    request.success = function (successResponse, status, xhr) {
        //        store.refreshToken = successResponse.refresh_token;
        //        store.accessToken = successResponse.access_token;


        //        //if (silent === false) {
        //        //    openTab();
        //        //}
        //        console.log('000000000000000000 ACCESS TOKEN 000000000000000000');
        //        console.log(store.accessToken);
        //        successCallback();
        //    };
        //    jQuery.ajax(request);
        //},
        //  Log us in
        login: function (successCallback, failCallback, silent, options) {
            const functionName = 'Is Logged In';
            try {
                if (debug) { console.log('Logging into salesforce... silent=', silent); }

                if (options && options.enableOAuth) {
                    enableOAuth = true;
                }

                console.warn('enableOAuth > ', enableOAuth);
                if (enableOAuth) {

                    if (silent) {
                        initStore(store.id,  store.url, savedRefreshToken);
                    } else {

                        var target = 'sf';
                        var sitekey = userInfoStore.getSiteKey();
                        var refreshToken = savedRefreshToken || '';
                        var server = OAuthServer; // 'https://account-staging.broadlook.com';
                        // DEV MODE!
                        //if (true) {
                        //    server = 'http://localhost:52000';
                        //}
                        var url = server + '/Capture/Auth/?sitekey=' + sitekey + '&target=' + target + '&refreshToken=' + refreshToken;

                        // reset local settings
                        bgService.setValue('settings', null);

                        //$scope.openPage(url, true);
                        chrome.tabs.create({ url: url }, function () { });
                    }

                    return;
                }



                //chrome.tabs.create({ url: 'https://na1.salesforce.com/001/o' }, function () { });

                if (debug) { console.log(debug + 'Looking for salesforce session...'); }
                var checkTabs = function (tabs) {
                    if (!tabs || tabs.length === 0) {
                        if (debug) { console.log(debug + 'salesforce tab not found'); }
                        if (silent) {
                            try { failCallback(); } catch (e) { }
                        }
                        else {
                            chrome.tabs.create({ url: 'https://login.salesforce.com' }, function () { });
                            //chrome.tabs.create({ url: 'https://na1.salesforce.com/001/o' }, function () { });
                        }
                        return;
                    }

                    var tab = tabs.pop();
                    //if (tab.url && tab.url.indexOf('https://') === 0 && tab.url.indexOf('salesforce.com/') > 0) {
                    if (tab.url && tab.url.indexOf('https://') === 0 && (tab.url.indexOf('.salesforce.com/') > 0 || tab.url.indexOf('.visual.force.com/') > 0 || tab.url.indexOf('.lightning.force.com/') > 0)) {
                        if (debug) { console.log(functionName + ' > Salesforce tab found > ', tab.url); }
                        var url;
                        var parts;
                        if (tab.url.indexOf('.visual.force.com/') > 0) {
                            url = tab.url.substring(0, tab.url.indexOf('.visual.force.com/'));// + 'visual.force.com'; // no ending "/"
                            parts = url.split('.');
                            url = 'https://' + parts[parts.length - 1] + '.salesforce.com';
                        }
                        else if (tab.url.indexOf('.lightning.force.com/') > 0) {
                            url = tab.url.substring(0, tab.url.indexOf('.lightning.force.com/'));
                            parts = url.split('//');
                            url = 'https://' + parts[parts.length - 1] + '.salesforce.com';
                        }
                        else {
                            url = tab.url.substring(0, tab.url.indexOf('.salesforce.com/') + 15); // no ending "/"
                        }

                        //if (debug) { console.log(debug + 'salesforce tab found, querying for session id', tab.url); }

                        chrome.cookies.getAll({ 'url': tab.url }, function (cookies) {
                            for (var i = 0; i < cookies.length; i++) {
                                try {
                                    var cookie = cookies[i];
                                    if (cookie.name === 'sid' && invalidSessions[cookie.value] !== true) {
                                        var session = cookie.value;
                                        //var url = tab.url.substring(0, tab.url.indexOf('salesforce.com/') + 14);// no ending "/"
                                        initStore(session, url);
                                        if (debug) { console.log(debug + 'store.ts:', store.ts); }
                                        try { successCallback(); } catch (e) { }
                                        return;
                                    }
                                } catch (e) {
                                    console.log('ERROR in cookie', e.message);
                                }
                            }
                            checkTabs(tabs);
                        });

                    } else {
                        checkTabs(tabs);
                    }
                };

                //chrome.tabs.query({ windowId: chrome.windows.WINDOW_ID_CURRENT }, checkTabs);
                chrome.tabs.query({}, checkTabs);

            } catch (e) {
                console.error(functionName, e.message);
                failCallback(e.message);
            }
        },

        logout: function (expireSession) {
            console.log('logout. expire? ', expireSession);
            if (expireSession && store.id) {
                invalidSessions[store.id] = true;
            }
            initStore();
        },

        //  Get login info
        isLoggedIn: function (successCallback, failCallback) {
            const functionName = 'Is Logged In';
            try {

                if (debug) { console.log(functionName, store); }

                console.warn('enableOAuth > ', enableOAuth);
                if (enableOAuth) {
                    if (store.id || refreshingToken) {
                        try { successCallback(); } catch (e) { }
                    } else {
                        try { failCallback(); } catch (e) { }
                    }
                    return;
                }


                if (store.id) {
                    if (debug) { console.log(debug + 'store.ts:', store.ts); }

                    if (store.ts) {
                        try {
                            var daysOld = (new Date().getTime() - store.ts.getTime()) / (1000 * 60 * 60 * 24);
                            if (debug) { console.log(debug + 'daysOld:', daysOld); }
                            if (daysOld < 1) {
                                try { successCallback(); } catch (e) { }
                                return;
                            } else {
                                // force expire
                                initStore();
                            }
                        } catch (e) {
                            console.log('*** ERROR in SF daysOld', e.message);
                        }
                    }

                }
                if (debug) { console.log(debug + 'Looking for salesforce session...'); }
                var checkTabs = function (tabs) {
                    if (!tabs || tabs.length === 0) {
                        if (debug) { console.log(debug + 'salesforce tab not found'); }
                        try { failCallback(); } catch (e) { }
                        return;
                    }

                    var tab = tabs.pop();
                    //if (debug) { console.log(debug + 'tab', tab.url, angular.copy(tabs)); }
                    //if (tab.url && tab.url.indexOf('https://') === 0 && tab.url.indexOf('salesforce.com/') > 0) {

                    //    if (debug) { console.log(debug + 'salesforce tab found, querying for session id', tab.url); }

                    if (tab.url && tab.url.indexOf('https://') === 0 &&
                    (tab.url.indexOf('.salesforce.com/') > 0 || tab.url.indexOf('.visual.force.com/') > 0 || tab.url.indexOf('.lightning.force.com/') > 0)) {
                        if (debug) { console.log(functionName + ' > Salesforce tab found > ', tab.url); }
                        var url;
                        try {
                            var parts;
                            if (tab.url.indexOf('.visual.force.com/') > 0) {
                                url = tab.url.substring(0, tab.url.indexOf('.visual.force.com/'));// + 'visual.force.com'; // no ending "/"
                                parts = url.split('.');
                                url = 'https://' + parts[parts.length - 1] + '.salesforce.com';
                            }
                            else if (tab.url.indexOf('.lightning.force.com/') > 0) {
                                url = tab.url.substring(0, tab.url.indexOf('.lightning.force.com/'));
                                parts = url.split('//');
                                url = 'https://' + parts[parts.length - 1] + '.salesforce.com';
                            }
                            else {
                                url = tab.url.substring(0, tab.url.indexOf('.salesforce.com/') + 15); // no ending "/"
                            }
                            console.log(functionName + ' > Salesforce URL found > ', url);
                        } catch (e) {
                            console.error('URL detection failed', e.message);
                        }

                        chrome.cookies.getAll({ 'url': tab.url },

                            function (cookies) {
                                //console.log('cookies', cookies);
                                for (var i = 0; i < cookies.length; i++) {
                                    try {
                                        var cookie = cookies[i];
                                        if (cookie.name === 'sid') {
                                            var session = cookie.value;
                                            //var url = tab.url.substring(0, tab.url.indexOf('salesforce.com/') + 14); // no ending "/"
                                            initStore(session, url);
                                            if (debug) { console.log(debug + 'store.ts:', store.ts); }
                                            try { successCallback(); } catch (e) { }
                                            return;
                                        }
                                    } catch (e) {
                                        console.log('ERROR in cookie', e.message);
                                    }
                                }
                                if (debug) { console.log(debug + 'WARNING: Cookie not found'); }
                                checkTabs(tabs);
                            }

                        );

                    } else {
                        checkTabs(tabs);
                    }
                };

                chrome.tabs.query({}, checkTabs);

            } catch (e) {
                console.error(functionName, e.message);
                failCallback(e.message);
            }
        },

        asyncIsLoggedIn: function () {

            console.log('CHECKING IF ASYNC LOGGED IN');

            var deferred = $q.defer();
            service.isLoggedIn(
                function () { deferred.resolve(true); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        getEntities: function (successCallback, failureCallback) {
            const functionName = 'Get Entities';
            try {
                if (debug) { console.log(consolePrefix + functionName); }
                //successCallback([{ name: 'Lead', type: 'lead' }]);

                checkSession();

                //if (typeof store.url === 'undefined') {
                //    console.error(functionName + ' > Not initialized > ', store);
                //    try { failureCallback('Session expired. Please log in.'); } catch (e) { }
                //    return;
                //}

                //// Use cached values
                //if (store.cache.entities) {
                //    var list = angular.copy(store.cache.entities);
                //    console.log(consolePrefix + functionName + ' > Read from cache > ', list);
                //    successCallback(list);
                //    return;
                //}

                var config = {
                    method: 'GET',
                    url: store.url + '/services/data/v34.0/sobjects',
                    headers: { 'Authorization': 'Bearer ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' }
                };
                if (debug) { console.log(consolePrefix + functionName + ' > Request > ', config); }

                $http(config).success(function (data, status, headers, config) {

                    var onTrueSuccess = function (data) {
                        try {

                            var list = [];
                            angular.forEach(data.sobjects, function (sobject, index) {
                                list.push({ name: sobject.name, label: sobject.label });
                            });

                            // Cache 
                            store.cache.entities = angular.copy(list);

                            successCallback(list);

                        } catch (e) {
                            console.error(functionName + ' > On True Success > ', e.message);
                            failureCallback('Salesforce API response is invalid');
                        }
                    };

                    defaultOnSuccessHandler(data, status, headers, config, onTrueSuccess, failureCallback);
                }

                ).error(function (data, status) {
                    defaultOnErrorHandler(data, status, failureCallback);
                });

            } catch (e) {
                console.error(functionName, e.message);
                failureCallback(e.message);
            }

        },

        // successCallback: function(fields)
        // fields: [ {name: '', label: '' } ]
        getFields: function (entityType, successCallback, failureCallback) {
            const functionName = 'Get Fields';
            try {
                if (debug) { console.log(consolePrefix + functionName + ' > Type > ', entityType); }

                var config = {
                    method: 'GET',
                    url: store.url + '/services/data/v34.0/sobjects/' + entityType + '/describe',
                    headers: { 'Authorization': 'Bearer ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' }
                };
                if (debug) { console.log(consolePrefix + functionName + ' > Request > ', config); }

                $http(config).success(function (data, status, headers, config) {

                    var onTrueSuccess = function (data) {
                        try {

                            var list = [];
                            angular.forEach(data.fields, function (field, index) {

                                if (!field.updateable) { return; }

                                var values = [];
                                if (field.picklistValues) {
                                    angular.forEach(field.picklistValues, function (picklistValue) {
                                        values.push({ value: picklistValue.value, label: picklistValue.label });
                                    });
                                }

                                var f = { name: field.name, label: field.label, length: field.length };

                                f.required = !field.nillable && field.updateable;

                                if (values.length > 0) {
                                    f.values = values;
                                }

                                list.push(f);

                            });

                            //store.cache['fields:' + entityType] = angular.copy(list);

                            successCallback(list);

                        } catch (e) {
                            console.error(functionName + ' > On True Success > ', e.message);
                            failureCallback('Salesforce API response is invalid');
                        }
                    };

                    defaultOnSuccessHandler(data, status, headers, config, onTrueSuccess, failureCallback);
                }

                ).error(function (data, status) {
                    defaultOnErrorHandler(data, status, failureCallback);
                });

                //jQuery.ajax({
                //    type: 'GET',
                //    url: url,
                //    contentType: 'application/json',
                //    beforeSend: function (xhr) {
                //        xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
                //        xhr.setRequestHeader('Accept', 'application/json');
                //    },
                //    success: function (successResponse) {

                //        console.log('successResponse=', successResponse);

                //        if (!successResponse) {
                //            console.error('null response!');
                //            failureCallback('Cannot get Salesforce object description');
                //            return;
                //        }

                //        var ff = [];
                //        angular.forEach(successResponse.fields, function (field, index) {

                //            //var def = null;
                //            var vv = [];
                //            if (field.picklistValues) {
                //                angular.forEach(field.picklistValues, function (pv, pvi) {
                //                    vv.push({ value: pv.value, label: pv.label });
                //                    //if()
                //                    //default: value.default
                //                });
                //            }

                //            if (field.updateable) {
                //                var f = { name: field.name, label: field.label, length: field.length };

                //                f.required = !field.nillable && field.updateable;

                //                if (vv.length > 0) {
                //                    f.values = vv;
                //                }

                //                ff.push(f);
                //            }
                //        });

                //        successCallback(ff);
                //    },
                //    error: function (errorResponse) {

                //        console.error('errorResponse=', errorResponse);
                //        failureCallback(errorResponse);
                //    }

                //});
            } catch (e) {
                console.error(functionName, e.message);
                failureCallback(e.message);
            }
        },

        // successCallback: function(maps)
        // maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        getDefaultExportMaps: function (successCallback, failureCallback) {

            console.log('GETTING DEFAULT EXPORT MAPS');

            var defaultCaptureMap = {
                fields: [
                    { captureField: 'first', label: 'First Name', crmField: null },
                    { captureField: 'last', label: 'Last Name', crmField: null },
                    { captureField: 'jobtitle', label: 'Job Title', crmField: null },
                    { captureField: 'company', label: 'Company Name', crmField: null },
                    { captureField: 'email', label: 'Email', crmField: null },
                    { captureField: 'phone', label: 'Phone', crmField: null },
                    { captureField: 'phone2', label: 'Phone 2', crmField: null },
                    { captureField: 'website', label: 'Website', crmField: null },
                    { captureField: 'bio', label: 'Bio', crmField: null },
                    { captureField: 'address1', label: 'Address Line 1', crmField: null },
                    { captureField: 'address2', label: 'Address Line 2', crmField: null },
                    { captureField: 'city', label: 'City', crmField: null },
                    { captureField: 'state', label: 'State', crmField: null },
                    { captureField: 'zip', label: 'Zip Code', crmField: null },
                    { captureField: 'country', label: 'Country', crmField: null },
                ]
            };

            //var contactMap = {
            //    fields: [
            //        { captureField: 'first', label: 'First Name',  crmField: { name: 'FirstName', label: 'First Name' } },
            //        { captureField: 'last', label: 'Last Name', crmField: { name: 'LastName', label: 'Last Name' } },
            //        { captureField: 'jobtitle', label: 'Job Title', crmField: { name: 'Title', label: 'Title' } },
            //        { captureField: 'company', label: 'Company Name', crmField: { name: 'Account.Name', label: 'Account Name' } },
            //        { captureField: 'email', label: 'Email', crmField: { name: 'Email', label: 'Email' } },
            //        { captureField: 'phone', label: 'Phone', crmField: { name: 'Phone', label: 'Phone' } },
            //        { captureField: 'phone2', label: 'Phone 2', crmField: { name: 'MobilePhone', label: 'Mobile Phone' } },
            //        { captureField: 'website', label: 'Website', crmField: null },
            //        { captureField: 'bio', label: 'Bio', crmField: { name: 'Description', label: 'Description' } },
            //        { captureField: 'address1', label: 'Address Line 1', crmField: { name: 'MailingStreet', label: 'Mailing Street' } },
            //        { captureField: 'address2', label: 'Address Line 2', crmField: null },
            //        { captureField: 'city', label: 'City', crmField: { name: 'MailingCity', label: 'Mailing City' } },
            //        { captureField: 'state', label: 'State', crmField: { name: 'MailingState', label: 'Mailing State' } },
            //        { captureField: 'zip', label: 'Zip Code', crmField: { name: 'MailingPostalCode', label: 'Mailing Postal Code' } },
            //        { captureField: 'country', label: 'Country', crmField: { name: 'MailingCountry', label: 'Mailing Country' } },
            //    ]
            //};

            var contactMap = {
                fields: [
                    { target: { name: 'FirstName', label: 'First Name' }, source: { type: 'capture', value: { captureField: 'first', label: 'First Name' } } },
                    { target: { name: 'LastName', label: 'Last Name' }, source: { type: 'capture', value: { captureField: 'last', label: 'Last Name' } } },
                    { target: { name: 'Title', label: 'Title' }, source: { type: 'capture', value: { captureField: 'jobtitle', label: 'Job Title' } } },
                    { target: { name: 'Company', label: 'Company' }, source: { type: 'capture', value: { captureField: 'company', label: 'Company Name' } } },
                    { target: { name: 'Email', label: 'Email' }, source: { type: 'capture', value: { captureField: 'email', label: 'Email' } } },
                    { target: { name: 'Phone', label: 'Phone' }, source: { type: 'capture', value: { captureField: 'phone', label: 'Phone' } } },
                    { target: { name: 'MobilePhone', label: 'Mobile Phone' }, source: { type: 'capture', value: { captureField: 'phone2', label: 'Phone 2' } } },
                    { target: { name: 'Description', label: 'Description' }, source: { type: 'capture', value: { captureField: 'bio', label: 'Bio' } } },
                    { target: { name: 'MailingStreet', label: 'Street' }, source: { type: 'capture', value: { captureField: 'address', label: 'Address Line 1 and 2' } } },
                    { target: { name: 'MailingCity', label: 'City' }, source: { type: 'capture', value: { captureField: 'city', label: 'City' } } },
                    { target: { name: 'MailingStateCode', label: 'State/Province Code' }, source: { type: 'capture', value: { captureField: 'stateCode', label: 'State Code' } } },
                    { target: { name: 'MailingPostalCode', label: 'Postal Code' }, source: { type: 'capture', value: { captureField: 'zip', label: 'Zip Code' } } },
                    { target: { name: 'MailingCountryCode', label: 'Country Code' }, source: { type: 'capture', value: { captureField: 'countryCode', label: 'Country Code' } } },
                    {
                        target: { name: 'AccountId', label: 'Account Name' }, source: {
                            type: 'lookup',
                            value: {
                                appProperty: 'company',
                                message: 'Select Account',
                                type: 'Account',
                                required: false,
                                allowNew: true,
                                resolve: 'createNewAccount'
                            }
                        }
                    },
                    {
                        target: { name: 'CampaignMember', label: 'Add To Campaign' },
                        source: {
                            type: 'action',
                            value: {
                                appProperty: 'campaign',
                                message: 'Add Contact to Campaign',
                                type: 'Campaign',
                                required: false,
                                enabled: false,
                                resolve: 'addContactToCampaign'
                            }
                        }
                    },
                ]
            };

            var leadMap = {
                fields: [
                    { target: { name: 'FirstName', label: 'First Name' }, source: { type: 'capture', value: { captureField: 'first', label: 'First Name' } } },
                    { target: { name: 'LastName', label: 'Last Name' }, source: { type: 'capture', value: { captureField: 'last', label: 'Last Name' } } },
                    { target: { name: 'Title', label: 'Title' }, source: { type: 'capture', value: { captureField: 'jobtitle', label: 'Job Title' } } },
                    { target: { name: 'Company', label: 'Company' }, source: { type: 'capture', value: { captureField: 'company', label: 'Company Name' } } },
                    { target: { name: 'Email', label: 'Email' }, source: { type: 'capture', value: { captureField: 'email', label: 'Email' } } },
                    { target: { name: 'Phone', label: 'Phone' }, source: { type: 'capture', value: { captureField: 'phone', label: 'Phone' } } },
                    { target: { name: 'MobilePhone', label: 'Mobile Phone' }, source: { type: 'capture', value: { captureField: 'phone2', label: 'Phone 2' } } },
                    { target: { name: 'Website', label: 'Website' }, source: { type: 'capture', value: { captureField: 'website', label: 'Website' } } },
                    { target: { name: 'Description', label: 'Description' }, source: { type: 'capture', value: { captureField: 'bio', label: 'Bio' } } },
                    { target: { name: 'Street', label: 'Street' }, source: { type: 'capture', value: { captureField: 'address', label: 'Address Line 1 and 2' } } },
                    { target: { name: 'City', label: 'City' }, source: { type: 'capture', value: { captureField: 'city', label: 'City' } } },
                    { target: { name: 'StateCode', label: 'State/Province Code' }, source: { type: 'capture', value: { captureField: 'stateCode', label: 'State Code' } } },
                    { target: { name: 'PostalCode', label: 'Postal Code' }, source: { type: 'capture', value: { captureField: 'zip', label: 'Zip Code' } } },
                    { target: { name: 'CountryCode', label: 'Country Code' }, source: { type: 'capture', value: { captureField: 'countryCode', label: 'Country Code' } } },
                    {
                        target: { name: 'CampaignMember', label: 'Add To Campaign' },
                        source: {
                            type: 'action',
                            value: {
                                message: 'Add Lead to Campaign',
                                type: 'Campaign',
                                required: false,
                                enabled: true,
                                resolve: 'addLeadToCampaign'
                                //function (service, lookupId, objectId, successCallback, failCallback) {
                                //    service.createRecord('CampaignMember', { CampaignId: lookupId, LeadId: objectId }, {}, successCallback, failCallback);
                                //},

                            }
                        }
                    },
                    {
                        target: { name: 'LeadSource', label: 'Lead Source' },
                        source: {
                            type: 'picklist',
                            value: {
                                message: 'Set Lead Source',
                                defaultValue: null,
                                required: false,
                                allowNew: false
                            }
                        }
                    },


                //return [{
                //    crmProperty: 'Campaign', appProperty: 'campaign', message: 'Select Campaign', type: 'Campaign', required: false, allowNew: false,
                //    resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //        service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    },
                //}, {
                //    crmProperty: 'LeadSource', appProperty: null, message: 'Select Lead Source', type: 'Lead', required: true, allowNew: false,
                //    picklist: true//,
                //    //resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //    //    console.log('resolve called', lookupId, objectId)
                //    //    //service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    //},
                //}];

                    //{ captureField: 'first', label: 'First Name', crmField: { name: 'FirstName', label: 'First Name' } },
                    //{ captureField: 'last', label: 'Last Name', crmField: { name: 'LastName', label: 'Last Name' } },
                    //{ captureField: 'jobtitle', label: 'Job Title', crmField: { name: 'Title', label: 'Title' } },
                    //{ captureField: 'company', label: 'Company Name', crmField: { name: 'Company', label: 'Company' } },
                    //{ captureField: 'email', label: 'Email', crmField: { name: 'Email', label: 'Email' } },
                    //{ captureField: 'phone', label: 'Phone', crmField: { name: 'Phone', label: 'Phone' } },
                    //{ captureField: 'phone2', label: 'Phone 2', crmField: { name: 'MobilePhone', label: 'Mobile Phone' } },
                    //{ captureField: 'website', label: 'Website', crmField: { name: 'Website', label: 'Website' } },
                    //{ captureField: 'bio', label: 'Bio', crmField: { name: 'Description', label: 'Description' } },
                    //{ captureField: 'address1', label: 'Address Line 1', crmField: { name: 'Street', label: 'Street' } },
                    //{ captureField: 'address2', label: 'Address Line 2', crmField: null },
                    //{ captureField: 'city', label: 'City', crmField: { name: 'City', label: 'City' } },
                    //{ captureField: 'state', label: 'State', crmField: { name: 'State', label: 'State' } },
                    //{ captureField: 'zip', label: 'Zip Code', crmField: { name: 'PostalCode', label: 'Postal Code' } },
                    //{ captureField: 'country', label: 'Country', crmField: { name: 'Country', label: 'Country' } },
                ]
            };


            var maps = [];

            maps.push({ name: 'lead', label: 'Lead', map: leadMap });
            maps.push({ name: 'contact', label: 'Contact', map: contactMap });

            successCallback(maps);
        },

        resolveLookup: function (actionId, lookupId, objectId, successCallback, failCallback) {

            console.log('RESOLVING LOOKUP');

            if (actionId === 'addLeadToCampaign') {
                service.createRecord('CampaignMember', { CampaignId: lookupId, LeadId: objectId }, {}, successCallback, failCallback);
            } else if (actionId === 'addContactToCampaign') {
                service.createRecord('CampaignMember', { CampaignId: lookupId, ContactId: objectId }, {}, successCallback, failCallback);
            } else if (actionId === 'createNewAccount') {

                if (lookupId && typeof lookupId.newName === 'undefined') {
                    console.log('EXISTING ACCOUNT', lookupId);
                    //service.updateRecord(objectId, 'Contact', { AccountId: lookupId }, successCallback, failCallback); // No need: was already posted
                    successCallback();
                } else {

                    console.log('NEW ACCOUNT', lookupId.newName);

                    var createSourceRecord = angular.copy(lookupId.record);
                    //Replace new Account name with user-entered value
                    createSourceRecord.company = lookupId.newName;
                    var createOptions = { map: lookupId.map };

                    service.createRecord('Account', createSourceRecord, createOptions,

                        // account was created
                        function (accountLink, accountId) {
                            console.log('account was created', accountLink, accountId, lookupId, objectId);
                            if (objectId) {
                                // Link was requested
                                var updateData = {};
                                updateData[lookupId.crmProperty] = accountId;
                                service.updateRecord(objectId, 'Contact', updateData, successCallback, failCallback);
                            } else {
                                // Link was not requested
                                successCallback(accountLink, accountId);
                            }
                        },

                        // Account was not created
                        function (msg) {
                            console.error('account was not created', msg);
                            failCallback('Account was not created');
                        }
                    );
                }
            } else {
                console.log('ERROR: Unknown action', lookupId);
                failCallback('Unknown action');
            }
        },

        getDefinition: function (entityType, successCallback, failureCallback) {

            console.log('GETTING DEFINITION');

            var def = {};
            entityType = entityType.toLowerCase();
            if (entityType === 'lead') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'RevenueAvg', 'EmployeesAvg'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'RevenueAvg', 'EmployeesAvg', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { display: 'First Name', group: 'G1' },
                            'LastName': { display: 'Last Name', group: 'G1' },
                            'Title': { display: 'Job Title', group: 'G1' },
                            'Company': { display: 'Company', group: 'G1' },
                            'Email': { display: 'Email', group: 'G1' },
                            'Phone': { display: 'Phone', group: 'G1' },
                            'MobilePhone': { display: 'Mobile Phone', group: 'G1' },
                            'Website': { display: 'Website', group: 'G1' },
                            'Description': { display: 'Description', group: 'G1' },
                            'RevenueAvg': { id: 'AnnualRevenue', display: 'Annual Revenue', group: 'G1' },
                            'EmployeesAvg': { id: 'NumberOfEmployees', display: 'Employees', group: 'G1' },

                            'Street': { display: 'Street', group: 'G2' },
                            'City': { display: 'City', group: 'G2' },
                            'State': { display: 'State/Province', group: 'G2' },
                            'PostalCode': { display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { display: 'Country', group: 'G2' },
                        }
                    }
                };

            } else if (entityType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { id: 'G1', display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description'] },
                            'G2': { id: 'G2', display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'FirstName', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'LastName', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'Title', display: 'Job Title', group: 'G1' },
                            'Email': { id: 'Email', display: 'Email', group: 'G1' },
                            'Phone': { id: 'Phone', display: 'Phone', group: 'G1' },
                            'MobilePhone': { id: 'MobilePhone', display: 'Mobile Phone', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Description': { id: 'Description', display: 'Description', group: 'G1' },

                            'Street': { id: 'Street', display: 'Street', group: 'G2' },
                            'City': { id: 'City', display: 'City', group: 'G2' },
                            'State': { id: 'State', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'PostalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },

        //  From sf lead to app contact
        fromLead: function (sfObject) {
            var contact = {};
            mapFromField(contact, 'first', sfObject, 'FirstName');
            mapFromField(contact, 'last', sfObject, 'LastName');
            mapFromField(contact, 'jobtitle', sfObject, 'Title');
            mapFromField(contact, 'company', sfObject, 'Company');
            mapFromField(contact, 'email', sfObject, 'Email');
            mapFromField(contact, 'phone', sfObject, 'Phone');
            mapFromField(contact, 'phone2', sfObject, 'MobilePhone');
            mapFromField(contact, 'website', sfObject, 'Website');
            mapFromField(contact, 'bio', sfObject, 'Description');
            mapFromField(contact, 'revenue', sfObject, 'AnnualRevenue');
            mapFromField(contact, 'revenueAvg', sfObject, 'AnnualRevenue');
            mapFromField(contact, 'employees', sfObject, 'NumberOfEmployees');
            mapFromField(contact, 'employeesAvg', sfObject, 'NumberOfEmployees');
            mapFromField(contact, 'address1', sfObject, 'Street');
            mapFromField(contact, 'city', sfObject, 'City');
            mapFromField(contact, 'state', sfObject, 'State');
            mapFromField(contact, 'zip', sfObject, 'PostalCode');
            mapFromField(contact, 'country', sfObject, 'Country');
            contact._link = store.url + '/' + sfObject.Id;
            contact._type = 'Lead';
            contact._id = sfObject.Id;
            return contact;
        },
        //  From app contact to sf lead
        toLead: function (contact) {
            var sfObject = {};
            mapField(contact, 'first', sfObject, 'FirstName');
            mapField(contact, 'last', sfObject, 'LastName');
            mapField(contact, 'jobtitle', sfObject, 'Title');
            mapField(contact, 'company', sfObject, 'Company');
            mapField(contact, 'email', sfObject, 'Email');
            mapField(contact, 'phone', sfObject, 'Phone');
            mapField(contact, 'phone2', sfObject, 'MobilePhone');
            mapField(contact, 'website', sfObject, 'Website');
            mapField(contact, 'bio', sfObject, 'Description');
            mapField(contact, 'revenueAvg', sfObject, 'AnnualRevenue');
            mapField(contact, 'employeesAvg', sfObject, 'NumberOfEmployees');
            mapField(contact, 'address1', sfObject, 'Street');
            mapField(contact, 'city', sfObject, 'City');
            mapField(contact, 'state', sfObject, 'State');
            mapField(contact, 'zip', sfObject, 'PostalCode');
            mapField(contact, 'country', sfObject, 'Country');
            return sfObject;
        },
        //  From sf contact to app contact
        fromContact: function (sfObject) {
            var contact = {};
            mapFromField(contact, 'first', sfObject, 'FirstName');
            mapFromField(contact, 'last', sfObject, 'LastName');
            mapFromField(contact, 'jobtitle', sfObject, 'Title');
            mapFromField(contact, 'company', sfObject, 'Account.Name');
            mapFromField(contact, 'email', sfObject, 'Email');
            mapFromField(contact, 'phone', sfObject, 'Phone');
            mapFromField(contact, 'phone2', sfObject, 'MobilePhone');
            mapFromField(contact, 'bio', sfObject, 'Description');
            mapFromField(contact, 'address1', sfObject, 'MailingStreet');
            mapFromField(contact, 'city', sfObject, 'MailingCity');
            mapFromField(contact, 'state', sfObject, 'MailingState');
            mapFromField(contact, 'zip', sfObject, 'MailingPostalCode');
            mapFromField(contact, 'country', sfObject, 'MailingCountry');
            contact._link = store.url + '/' + sfObject.Id;
            contact._type = 'Contact';
            contact._id = sfObject.Id;
            return contact;
        },
        //  from app contact to sf contact
        toContact: function (contact) {
            var sfObject = {};
            mapField(contact, 'first', sfObject, 'FirstName');
            mapField(contact, 'last', sfObject, 'LastName');
            mapField(contact, 'jobtitle', sfObject, 'Title');
            mapField(contact, 'email', sfObject, 'Email');
            mapField(contact, 'phone', sfObject, 'Phone');
            mapField(contact, 'phone2', sfObject, 'MobilePhone');
            mapField(contact, 'bio', sfObject, 'Description');
            mapField(contact, 'address1', sfObject, 'MailingStreet');
            mapField(contact, 'city', sfObject, 'MailingCity');
            mapField(contact, 'state', sfObject, 'MailingState');
            mapField(contact, 'zip', sfObject, 'MailingPostalCode');
            mapField(contact, 'country', sfObject, 'MailingCountry');
            return sfObject;
        },
        //  From sf account to app contact
        fromAccount: function (sfObject) {
            var contact = {};
            mapFromField(contact, 'website', sfObject, 'Website');
            mapFromField(contact, 'company', sfObject, 'Name');
            //mapFromField(contact, 'jobtitle', sfObject, 'Title');
            //mapFromField(contact, 'email', sfObject, 'Email');
            //mapFromField(contact, 'phone', sfObject, 'Phone');
            //mapFromField(contact, 'phone2', sfObject, 'MobilePhone');
            //mapFromField(contact, 'bio', sfObject, 'Description');
            //mapFromField(contact, 'address1', sfObject, 'MailingStreet');
            mapFromField(contact, 'city', sfObject, 'BillingCity');
            mapFromField(contact, 'state', sfObject, 'BillingState');
            //mapFromField(contact, 'zip', sfObject, 'MailingPostalCode');
            //mapFromField(contact, 'country', sfObject, 'MailingCountry');
            //mapFromField(contact, 'country', sfObject, 'MailingCountry');
            contact._createdDate = sfObject.CreatedDate;
            contact._link = store.url + '/' + sfObject.Id;
            //contact._link = store.url + sfObject.attributes.url;
            contact._type = 'Account';
            contact._id = sfObject.Id;
            return contact;
        },
        //  From app contact to sf object
        toNativeRecord: function (contact, entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') { return this.toContact(contact); }
            if (entityType === 'lead') { return this.toLead(contact); }
        },
        //  From sf entity to app contact
        fromNativeRecord: function (sfEntity, entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') { return this.fromContact(sfEntity); }
            if (entityType === 'lead') { return this.fromLead(sfEntity); }
            if (entityType === 'account') { return this.fromAccount(sfEntity); }
        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {
            if (debug) { console.log(debug + 'toLookupObject->entityType', entityType, '->crmObject', crmObject); }

            entityType = entityType.toLowerCase();
            var lookupObject = { label: '', link: '' };
            var appObject = null;
            if (entityType === 'contact') { appObject = this.fromContact(crmObject); }
            else if (entityType === 'lead') {
                appObject = this.fromLead(crmObject);
            }
            else if (entityType === 'account') {
                appObject = this.fromAccount(crmObject);
                var cityState = '';
                if (appObject.city) { cityState = appObject.city; }
                if (appObject.state) {
                    if (cityState) { cityState = cityState + ', ' + appObject.state; }
                    else { cityState = appObject.state; }
                }
                if (cityState) { cityState = ' (' + cityState + ')'; }
                lookupObject.label = (appObject.company || '(no name)') + cityState;
                lookupObject.link = appObject._link;
                lookupObject.id = appObject._id;
            }
            else if (entityType === 'campaign') {
                lookupObject.label = (crmObject.Name || '(no name)');
                lookupObject.link = store.url + '/' + crmObject.Id;
                lookupObject.id = crmObject.Id;
            } else {
                // Assume there is Id and Name fields
                lookupObject.label = (crmObject.Name || '(no name)');
                lookupObject.link = store.url + '/' + crmObject.Id;
                lookupObject.id = crmObject.Id;
            }
            if (debug) { console.log(debug + 'toLookupObject->result', lookupObject); }
            return lookupObject;
        },

        getRequiredLookups: function (entityType, actualMap) {

            console.log('GETTING REQUIRED LOOKUPS');

            entityType = entityType.toLowerCase();

            if (actualMap) {

                if (debug) { console.log(debug + 'getRequiredLookups->map', actualMap); }

                var aa = [];

                // convert map def to lookup def

                for (var i = 0, l = actualMap.fields.length; i < l; i++) {
                    var f = actualMap.fields[i];
                    if (f.source && (f.source.type === 'lookup' || f.source.type === 'picklist' || f.source.type === 'action')) {

                        if (f.source && f.source.value && f.source.value.enabled === false) {
                            console.log('disabled action', angular.copy(f));
                            continue;
                        }

                        var a;

                        if (f.source.value) {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: f.source.value.appProperty,
                                message: f.source.value.message,
                                type: f.source.value.type,
                                defaultValue: f.source.value.defaultValue ? { id: f.source.value.defaultValue.value, label: f.source.value.defaultValue.label } : null,
                                required: f.source.value.required,
                                allowNew: f.source.value.allowNew,
                                picklist: f.source.value.picklist || f.source.type === 'picklist',
                                resolve: f.source.value.resolve,
                                hidden: f.source.value.hidden
                            };

                            if (a.crmProperty === 'CampaignMember' && !a.appProperty) {
                                a.appProperty = 'campaign';
                            }
                        } else {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: '',
                                message: '',
                                type: '',
                                defaultValue: '',
                                required: false,
                                allowNew: false,
                                picklist: f.source.type === 'picklist',
                                resolve: null,
                            };
                        }

                        if (f.source.type === 'picklist') {
                            a.type = entityType;
                            a.allowNew = false;
                        }


                        aa.push(a);
                    }
                }

                if (debug) { console.log(debug + 'getRequiredLookups->result', aa); }

                return aa;
            }

            if (entityType === 'contact') {
                return [{ crmProperty: 'AccountId', appProperty: 'company', message: 'Select Account', type: 'Account', required: false, allowNew: true }
                    //,
                    //    { crmProperty: 'OwnerId', appProperty: 'full', message: 'Select account owner', type: 'SystemUser', required: false, allowNew: false }
                ];
            }
            if (entityType === 'lead') {
                //return [{
                //    crmProperty: 'Campaign', appProperty: 'campaign', message: 'Select Campaign', type: 'Campaign', required: false, allowNew: false,
                //    resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //        service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    },
                //}, {
                //    crmProperty: 'LeadSource', appProperty: null, message: 'Select Lead Source', type: 'Lead', required: true, allowNew: false,
                //    picklist: true//,
                //    //resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //    //    console.log('resolve called', lookupId, objectId)
                //    //    //service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    //},
                //}];
            }
            if (entityType === 'account') { return []; }
            return [];
        },


        asyncGetDefinition: function (entityType) {
            var deferred = $q.defer();
            service.getDefinition(entityType,
                function (def) { deferred.resolve(def); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        //-- CRUD --//
        //  Create a record with data provided
        //      successCallback: function(recordId)
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {

            console.log('CREATING RECORD WITH');
            console.log(recordType);

            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            if (recordType === 'account') { recordType = 'Account'; }

            //var service = this;
            var attemptsLeft = 10;
            var record = {};
            var url = store.url + '/services/data/v34.0/sobjects/' + recordType + '/';

            var createRecordWithMap = function (map, captureRecord) {

                var r = {};

                if (map && map.fields) {
                    var i = map.fields.length;
                    while (i--) {
                        var f = map.fields[i];
                        if (f.target && f.target.name) {
                            if (f.source) {
                                var a = r[f.target.name];
                                var b = '';
                                var l = f.target.length || 0;
                                if (f.source.type === 'capture') {
                                    b = captureRecord[f.source.value.captureField] || '';
                                    if (a) {
                                        r[f.target.name] = service.limitstr(a + ' ' + b, l);
                                    } else {
                                        r[f.target.name] = service.limitstr(b, l);
                                    }
                                } else if (f.source.type === 'text' && f.source.value) {
                                    b = f.source.value.text || '';
                                    if (r[f.target.name]) {
                                        r[f.target.name] = service.limitstr(a + ' ' + b, l);
                                    } else {
                                        r[f.target.name] = service.limitstr(b, l);
                                    }
                                }
                                //else if (f.source.type === 'lookup')
                                //{ r[f.target.name] = f.source.value.text; }
                            }
                        }
                    }
                }

                if (createOptions && createOptions.mappedProperties) {
                    var j = createOptions.mappedProperties.length;
                    while (j--)
                    { r[createOptions.mappedProperties[j].name] = createOptions.mappedProperties[j].value; }
                }

                console.log('SF record', r);

                return r;
            };

            var handleError = function (errorResponse, f) {

                if (debug) { console.log(debug + 'handleError', errorResponse); }

                var tryAgain = false;
                var delayDecision = false;
                var msg = '';
                var text = '';

                var makeDecision = function () {

                    if (tryAgain) {
                        if (debug) { console.log(debug + 'trying again', record); }
                        f();
                    }
                    else {
                        if (msg === '') {
                            msg = errorResponse.responseText;
                        }
                        if (typeof msg === 'undefined' || msg === '') {
                            msg = 'Export error';
                        }
                        failCallback(msg);
                    }
                };


                if (errorResponse.responseJSON) {

                    var i = errorResponse.responseJSON.length;

                    if (i--) {

                        msg += errorResponse.responseJSON[i].message + '  ';

                        var errorCode = errorResponse.responseJSON[i].errorCode;

                        if (errorCode === 'INVALID_SESSION_ID') {
                            service.logout(true);
                            failCallback('Session expired. Please log in.');
                            //} else if (errorCode === 'INVALID_FIELD_FOR_INSERT_UPDATE') {
                            //    var k = errorResponse.responseJSON[i].fields.length;
                            //    while (k--) {
                            //        delete record[errorResponse.responseJSON[i].fields[k]];
                            //        tryAgain = attemptsLeft > 0;
                            //        attemptsLeft--;
                            //    }
                        } else if (errorCode === 'FIELD_INTEGRITY_EXCEPTION') {
                            var j = errorResponse.responseJSON[i].fields.length;
                            while (j--) {
                                delete record[errorResponse.responseJSON[i].fields[j]];
                                tryAgain = attemptsLeft > 0;
                                attemptsLeft--;
                            }
                        } else if (errorCode === 'REQUIRED_FIELD_MISSING') {

                            var requiredField = errorResponse.responseJSON[i].message.split('[')[1];

                            if (requiredField) {
                                requiredField = requiredField.split(']')[0].split(',')[0].trim();

                                if (typeof enteredValues[requiredField] !== 'undefined') {
                                    record[requiredField] = enteredValues[requiredField];
                                    tryAgain = attemptsLeft > 0;
                                    attemptsLeft--;
                                }
                                else {
                                    //msg = 'Please map value of required field ' + requiredField + ' and try again';
                                    //attemptsLeft = 0;

                                    text = 'Please enter value of required field ' + requiredField + ':';
                                    delayDecision = true;

                                    $timeout(function () {
                                        dialogs.text.show({ message: text, value: '' }).confirm(function (value) {

                                            console.log('New Value = ' + value);
                                            enteredValues[requiredField] = value;
                                            record[requiredField] = value;

                                            if (typeof value === 'undefined') {
                                                attemptsLeft = 0;
                                            }

                                            tryAgain = attemptsLeft > 0;
                                            attemptsLeft--;

                                            makeDecision();

                                        });
                                    }, 500);
                                }

                            }

                        } else if (errorCode === 'INVALID_OR_NULL_FOR_RESTRICTED_PICKLIST') {

                            var fieldLabel = errorResponse.responseJSON[i].message.split(':')[0];
                            var invalidValue = errorResponse.responseJSON[i].message.split(':')[2];

                            var fieldIndex = 0;
                            if (fieldIndex < errorResponse.responseJSON[i].fields.length) {
                                var fieldName = errorResponse.responseJSON[i].fields[fieldIndex];

                                if (typeof enteredValues[fieldName] !== 'undefined') {
                                    record[fieldName] = enteredValues[fieldName];
                                    tryAgain = attemptsLeft > 0;
                                    attemptsLeft--;
                                }
                                else {
                                    //msg = 'Please map picklist value of field ' + fieldLabel + ' and try again';
                                    //attemptsLeft = 0;

                                    text = 'Please enter valid picklist value of ' + fieldLabel + ':';
                                    delayDecision = true;

                                    $timeout(function () {
                                        dialogs.text.show({ message: text, value: invalidValue }).confirm(function (value) {

                                            console.log('New Value = ' + value);
                                            enteredValues[fieldName] = value;
                                            record[fieldName] = value;

                                            if (!record[fieldName]) {
                                                attemptsLeft = 0;
                                            }

                                            makeDecision();

                                        });
                                    }, 500);
                                }
                                fieldIndex++;
                            }

                            tryAgain = attemptsLeft > 0;
                            attemptsLeft--;

                        } else if (errorCode === 'INVALID_FIELD') {

                            if (errorResponse.responseJSON[i].message === 'No such column \'MailingStateCode\' on sobject of type Contact' ||
                                errorResponse.responseJSON[i].message === 'No such column \'MailingCountryCode\' on sobject of type Contact') {

                                delete record.MailingStateCode;
                                delete record.MailingCountryCode;

                                record.MailingState = service.limitstr(captureRecord.state, 0);
                                record.MailingCountry = service.limitstr(captureRecord.country, 0);

                                tryAgain = attemptsLeft > 0;
                                attemptsLeft--;

                            } else if (errorResponse.responseJSON[i].message === 'No such column \'StateCode\' on sobject of type Lead' ||
                                errorResponse.responseJSON[i].message === 'No such column \'CountryCode\' on sobject of type Lead') {

                                delete record.StateCode;
                                delete record.CountryCode;

                                record.State = service.limitstr(captureRecord.state, 0);
                                record.Country = service.limitstr(captureRecord.country, 0);

                                tryAgain = attemptsLeft > 0;
                                attemptsLeft--;

                            } else {

                                if (errorResponse.responseJSON[i].message.indexOf('No such column' >= 0)) {
                                    var missingField = errorResponse.responseJSON[i].message.split('\'')[1];
                                    if (missingField) {
                                        delete record[missingField];
                                        tryAgain = attemptsLeft > 0;
                                        attemptsLeft--;
                                    }
                                }

                            }
                        }

                    }
                }

                if (!delayDecision)
                { makeDecision(); }

            };

            var handleSuccess = function (successResponse) {

                if (debug) { console.log(debug + 'handleSuccess', successResponse); }

                //var fields = {};
                //fields[data.mappedProperties[0].name] = '0014000001Ym7q7'; //data.mappedProperties[0].value;
                //updateRecord(successResponse.id, { 'FirstName': 'Alex' });
                //updateRecord(successResponse.id, { 'accid': '0014000001Ym7q7' });

                if (successResponse && successResponse.success)
                { successCallback(store.url + '/' + successResponse.id, successResponse.id); }
                else
                { failCallback('Record was not created'); }

            };

            var composeDescription = function (contact) {
                var s = [];
                s.push('Added by Capture!');
                if (contact.mark && contact.mark !== 'Default') { s.push('List: [' + contact.mark + ']'); }
                if (contact.email2) { s.push('Email 2: ' + contact.email2); }
                if (contact.sourceurl) { s.push('Source URL: ' + contact.sourceurl); }
                if (contact.venues) {
                    s.push('Social Links:');
                    for (var i = 0; i < contact.venues.length; i++)
                    { s.push(contact.venues[i].website); }
                    //{ s.push(contact.venues[i].type + ': ' + contact.venues[i].website); }
                }
                if (contact.bio) { s.push('Bio:\n' + contact.bio); }


                return s.join('\n').trim();
            };

            var createLead = function (contact) { //, session, url, crmid, sitekey) {

                //console.log('SF', session, url, store.id);


                var countryCode = service.convertCountryToSalesforceCountryCode(contact.country);
                var stateCode = service.convertStateToSalesforceStateCode(contact.state);

                if (service.isUSState(stateCode)) {
                    countryCode = 'US';
                }

                record = {
                    'LastName': service.limitstr(contact.last, 80),
                    'FirstName': service.limitstr(contact.first, 40),
                    'Email': service.limitstr(contact.email, 0),
                    'Company': service.limitstr(contact.company ? contact.company : 'Unknown', 255),
                    'Title': service.limitstr(contact.jobtitle, 128),
                    'Street': service.limitstr((contact.address1 ? contact.address1 : '') + (contact.address2 ? ' ' + contact.address2 : ''), 0),
                    'City': service.limitstr(contact.city, 0),
                    'State': service.limitstr(contact.state, 0),
                    'StateCode': service.limitstr(stateCode, 0),
                    'PostalCode': service.limitstr(contact.zip, 0),
                    'Country': service.limitstr(contact.country, 0),
                    'CountryCode': service.limitstr(countryCode, 0),
                    'Website': service.limitstr(contact.website, 255),
                    'Phone': service.limitstr(contact.phone, 0),
                    'MobilePhone': service.limitstr(contact.phone2, 0),
                    'Fax': service.limitstr(contact.fax, 0),
                    //'LeadSource': service.limitstr((contact.mark && contact.mark !== 'Default' ? contact.mark : 'Capture!'), 0),
                    'Description': service.limitstr(composeDescription(contact), 32000)
                };

                if (record.StateCode !== '') {
                    delete record.State;
                }
                if (record.CountryCode !== '') {
                    delete record.Country;
                }

                if (createOptions && createOptions.mappedProperties) {
                    var i = createOptions.mappedProperties.length;
                    while (i--)
                    { record[createOptions.mappedProperties[i].name] = createOptions.mappedProperties[i].value; }
                }

                console.log('SF Record', JSON.stringify(record), JSON.stringify(contact));

                var f = function () {
                    try {
                        if (debug) { console.log(debug + 'post', angular.copy(record)); }
                        //calls Salesforce REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: url, //url + code + 'Lead/',
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                handleError(errorResponse, f);
                            }

                        });
                    } catch (e) {
                        console.log('create sf lead failed', e);
                        failCallback('Record was not created');
                    }
                };

                f();

            };

            var createContact = function (contact) {

                var countryCode = service.convertCountryToSalesforceCountryCode(contact.country);
                var stateCode = service.convertStateToSalesforceStateCode(contact.state);

                if (service.isUSState(stateCode))
                { countryCode = 'US'; }

                record = {
                    //'AccountId': '', // passed as mappedProperties
                    'LastName': service.limitstr(contact.last, 80),
                    'FirstName': service.limitstr(contact.first, 40),
                    'Email': service.limitstr(contact.email, 0),
                    'Title': service.limitstr(contact.jobtitle, 128),
                    'MailingStreet': service.limitstr((contact.address1 ? contact.address1 : '') + (contact.address2 ? ' ' + contact.address2 : ''), 0),
                    'MailingCity': service.limitstr(contact.city, 0),
                    'MailingState': service.limitstr(contact.state, 0),
                    'MailingStateCode': service.limitstr(stateCode, 0),
                    'MailingPostalCode': service.limitstr(contact.zip, 0),
                    'MailingCountry': service.limitstr(contact.country, 0),
                    'MailingCountryCode': service.limitstr(countryCode, 0),
                    'Phone': service.limitstr(contact.phone, 0),
                    'MobilePhone': service.limitstr(contact.phone2, 0),
                    'Fax': service.limitstr(contact.fax, 0),
                    'Description': service.limitstr(composeDescription(contact), 32000)
                };

                if (record.MailingStateCode !== '') {
                    delete record.MailingState;
                }
                if (record.MailingCountryCode !== '') {
                    delete record.MailingCountry;
                }

                if (createOptions && createOptions.mappedProperties) {
                    var i = createOptions.mappedProperties.length;
                    while (i--) {
                        var fieldName = createOptions.mappedProperties[i].name;
                        record[fieldName] = createOptions.mappedProperties[i].value;
                    }
                }

                var f = function () {

                    if (debug) { console.log(debug + 'post', url, angular.copy(record)); }
                    try {
                        //calls Salesforce REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: url,
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                handleError(errorResponse, f);
                            }
                        });
                    } catch (e) {
                        console.log('create sf contact failed', e);
                        failCallback('Record was not created');
                    }
                };

                f();

            };

            var createAccount = function (contact) {

                //if (map && map.fields && map.fields.length > 0) {
                //    record = createRecordWithMap(map, contact);
                //} else {
                var countryCode = service.convertCountryToSalesforceCountryCode(contact.country);
                var stateCode = service.convertStateToSalesforceStateCode(contact.state);

                if (service.isUSState(stateCode)) {
                    countryCode = 'US';
                }

                record = {
                    'Name': service.limitstr(contact.company || 'Unknown', 255),
                    'BillingStreet': service.limitstr((contact.address1 ? contact.address1 : '') + (contact.address2 ? ' ' + contact.address2 : ''), 0),
                    'BillingCity': service.limitstr(contact.city, 40),
                    'BillingState': service.limitstr(contact.state, 80),
                    'BillingStateCode': service.limitstr(stateCode, 0),
                    'BillingPostalCode': service.limitstr(contact.zip, 20),
                    'BillingCountry': service.limitstr(contact.country, 80),
                    'BillingCountryCode': service.limitstr(countryCode, 0),
                    'Website': service.limitstr(contact.website, 255),
                    'Phone': service.limitstr(contact.phone, 0),
                    'Fax': service.limitstr(contact.fax, 0),
                    'Description': service.limitstr('Added by Capture!', 32000)
                };

                if (record.BillingStateCode !== '') {
                    delete record.BillingState;
                }
                if (record.BillingCountryCode !== '') {
                    delete record.BillingCountry;
                }
                //}

                if (createOptions && createOptions.mappedProperties) {
                    var i = createOptions.mappedProperties.length;
                    while (i--)
                    { record[createOptions.mappedProperties[i].name] = createOptions.mappedProperties[i].value; }
                }

                console.log('SF Record', JSON.stringify(record), JSON.stringify(contact));

                var f = function () {
                    try {
                        if (debug) { console.log(debug + 'post', angular.copy(record)); }

                        //calls Salesforce REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: url,
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                console.log('**** CREATE ACCOUNT SUCCESS');
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                console.log('**** CREATE ACCOUNT FAIL');
                                handleError(errorResponse, f);
                            }

                        });
                    } catch (e) {
                        console.log('create sf account failed', e);
                        failCallback(e.message);
                    }
                };

                f();

            };

            var createNewRecord = function (recordType, record2) {

                record = record2; // fixing the scope

                if (debug) { console.log(debug + 'createNewRecord->type:', recordType, '->record:', record); }

                var f = function () {
                    try {
                        if (debug) { console.log(debug + 'post', angular.copy(record)); }
                        //calls Salesforce REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: store.url + '/services/data/v34.0/sobjects/' + recordType + '/',
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                handleError(errorResponse, f);
                            }

                        });
                    } catch (e) {
                        console.log('create failed', e);
                        failCallback(e.message);
                    }
                };

                f();

            };


            console.log('SF create record', captureRecord);


            if (createOptions && createOptions.map && createOptions.map.fields && createOptions.map.fields.length > 0) {

                captureRecord.address = ((captureRecord.address1 ? captureRecord.address1 : '') +
                    (captureRecord.address2 ? ' ' + captureRecord.address2 : '')).trim();

                captureRecord.stateCode = service.convertStateToSalesforceStateCode(captureRecord.state);
                captureRecord.countryCode = service.convertCountryToSalesforceCountryCode(captureRecord.country);
                if (service.isUSState(captureRecord.stateCode)) {
                    captureRecord.countryCode = 'US';
                }

                var rec = createRecordWithMap(createOptions.map, captureRecord);

                createNewRecord(recordType, rec);

            } else {

                if (recordType.toUpperCase() === 'LEAD')
                { createLead(captureRecord); }
                else if (recordType.toUpperCase() === 'CONTACT')
                { createContact(captureRecord); }
                else if (recordType.toUpperCase() === 'ACCOUNT')
                { createAccount(captureRecord); }
                else
                { createNewRecord(recordType, captureRecord); }

            }

        },

        //  Update an existing record with data
        //      successCallback: function(recordId)
        updateRecord: function (recordId, recordType, record, successCallback, failCallback, original) {
            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            var headers = { 'Content-type': 'application/json', 'Authorization': 'Bearer ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' };
            var url = store.url + '/services/data/v34.0/sobjects/' + recordType + '/' + recordId;

            if (original) {
                // remove fields that did not change
                for (var a in original) {
                    if (record[a] === original[a]) {
                        delete record[a];
                    }
                }
                console.log(consolePrefix + 'Update > Cleaned Record > ', record);
            }

            var config = { method: 'PATCH', url: url, data: record, headers: headers };
            console.log('salesforce.updateRecord...', config);
            $http(config).success(function (response) {
                if (debug) { console.log('salesforce.updateRecord:', response); }
                try { successCallback(response); } catch (e) { }
            }).error(function (response, status) {
                if (debug) { console.error('salesforce.updateRecord:', status, response); }

                // Missing field?
                if (status === 400) {
                    var error = response[0];
                    if (error.errorCode === 'INVALID_FIELD' && error.message.indexOf('No such column' >= 0)) {
                        var missingField = error.message.split('\'')[1];
                        if (missingField) {
                            delete record[missingField];
                            service.updateRecord(recordId, recordType, record, successCallback, failCallback, original);
                            return;
                        }
                    }
                }

                var msg = '';
                if (response && response.length > 0) {
                    var i = 0;
                    while (i < response.length) {
                        if (response[i].message)
                        { msg += response[i].message + ' '; }
                        i++;
                    }
                }
                try { failCallback('Cannot update Salesforce record: (' + status + ') ' + (msg || response)); } catch (e) { }
            });
        },

        //  Retrieve record from service
        //      successCallback: function(recordId, data)
        retrieveRecord: function (recordId, recordType, successCallback, failureCallback) {

            console.log('RETRIEVING RECORD');
            try {
                if (recordType === 'lead') { recordType = 'Lead'; }
                if (recordType === 'contact') { recordType = 'Contact'; }
                var config = { headers: { 'Content-type': 'application/json', 'Authorization': 'Bearer ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' } };
                var url = store.url + '/services/data/v34.0/sobjects/' + recordType + '/' + recordId;
                console.log('salesforce.retrieveRecord...', { url: url, config: config });
                $http.get(url, config).success(

                    //function (response) {
                    //    if (debug) { console.log('salesforce.retrieveRecord:', response); }
                    //    try { successCallback(response); } catch (e) { }
                    //}

                    function (data, status, headers, config) {
                        defaultOnSuccessHandler(data, status, headers, config, successCallback, failureCallback);
                    }

                ).error(function (response, status) {
                    console.error('Retrieve Record > Error > ', response, status);
                    var error = '';
                    if (response.message) { error = response.message; }
                    else { error = JSON.stringify(response); }
                    try { failureCallback('Cannot retrieve Salesforce record: (' + status + ') ' + error, status); } catch (e) { }
                });
            } catch (e) {
                console.error('Retrieve Record > Exception > ', e.message);
                var details = 'Chrome exception';
                if (e && e.message) {
                    details = e.message;
                }
                failureCallback('Cannot retrieve Salesforce record: ' + details);
            }
        },

        asyncRetrieveRecord: function (recordId, recordType) {
            var deferred = $q.defer();
            service.retrieveRecord(recordId, recordType,
                function (response) { deferred.resolve(response); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        //  Delete record from service
        //      successCallback: function(recordId)
        deleteRecord: function (recordId, successCallback, failCallback) {
        },
        //-- /CRUD --//


        //-- Search --//
        //  Find a record using a query: { first:'', last:'', email:''} object
        //      successCallback: function(nativeRecords[])
        findRecord: function (recordType, query, fields, successCallback, failureCallback) {
            const functionName = 'Find Record';
            try {

                console.log(consolePrefix + functionName, ' > Type > ', recordType, ' > Query > ', query, ' > Fields >', fields);

                checkSession();

                //var service = this;

                var encodeParam = function (p) {
                    p = p || '';
                    p = p.replace('\\', '\\\\');
                    p = p.replace('\'', '\\\'');
                    p = p.replace('\"', '\\\"');
                    return encodeURIComponent(p);
                    //return p.replace(/'/g, '%5C%27');
                };

                if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

                if (recordType === 'account') { recordType = 'Account'; }
                if (recordType === 'lead') { recordType = 'Lead'; }
                if (recordType === 'contact') { recordType = 'Contact'; }
                if (recordType === 'campaign') { recordType = 'Campaign'; }

                var where = [];

                if (query) {

                    if (query.email)
                    { where.push('Email=\'' + encodeParam(query.email) + '\''); }

                    if (query.email_endsWith)
                    { where.push('Email+LIKE+\'%25' + encodeParam(query.email_endsWith) + '\''); }

                    if (query.last)
                    { where.push('LastName=\'' + encodeParam(query.last) + '\''); }

                    if (query.first)
                    { where.push('FirstName=\'' + encodeParam(query.first) + '\''); }

                    if (query.middle)
                    { where.push('MiddleName=\'' + encodeParam(query.middle) + '\''); } // The field may be disabled!

                    if (recordType === 'Account') {
                        if (query.company)
                        { where.push('Name+LIKE+\'%25' + encodeParam(query.company) + '%25\''); }
                        if (query.website)
                        { where.push('Website+LIKE+\'%25' + encodeParam(query.website) + '%25\''); }
                    }

                    if (recordType === 'Campaign') {
                        if (query.campaign)
                        { where.push('Name+LIKE+\'%25' + encodeParam(query.campaign) + '%25\''); }
                    }

                }
                var whereStr = where.join('+AND+');
                if (recordType === 'Account') {
                    whereStr = where.join('+OR+');
                }
                if (whereStr) { whereStr = '+WHERE+' + whereStr; } else { whereStr = '+'; }
                console.log(whereStr);

                var fieldsStr = 'Id,Name'; // * is not supported by SOQL SELECT Syntax
                var f;

                if (recordType === 'user') {
                    fieldsStr = 'Id,Name';
                }

                if (recordType === 'Account') {
                    f = [];

                    f.push('ID');

                    if (fields.indexOf('company') > -1) { f.push('Name'); }
                    if (fields.indexOf('website') > -1) { f.push('Website'); }
                    if (fields.indexOf('_createdDate') > -1) { f.push('CreatedDate'); }

                    f.push('BillingCity');
                    f.push('BillingState');

                    fieldsStr = f.join(',');
                }

                if (recordType === 'Contact') {
                    f = [];

                    f.push('ID');

                    if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                    if (fields.indexOf('last') > -1) { f.push('LastName'); }
                    if (fields.indexOf('email') > -1) { f.push('Email'); }
                    //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                    fieldsStr = f.join(',');
                }

                if (recordType === 'Lead') {
                    f = [];

                    f.push('ID');

                    if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                    if (fields.indexOf('last') > -1) { f.push('LastName'); }
                    if (fields.indexOf('email') > -1) { f.push('Email'); }
                    //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                    fieldsStr = f.join(',');
                }

                if (recordType === 'Campaign') {
                    f = [];

                    f.push('ID');
                    f.push('Name');

                    fieldsStr = f.join(',');
                }

                var headers = { 'Content-type': 'application/json', 'Authorization': 'Bearer ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' };
                var url = store.url + '/services/data/v34.0/query/?q=SELECT+' + fieldsStr + '+FROM+' + recordType + whereStr;

                if (query && query.limit > 0)
                { url = url + '+LIMIT+' + query.limit; }
                else if (query && query.limit === 0)
                { }
                else
                { url = url + '+LIMIT+50'; }

                var config = { method: 'GET', url: url, headers: headers };
                if (debug) { console.log(debug + 'findRecord->config:', config); }

                var allRecords = [];

                var errorHandler = function (response, status) {
                    try {
                        if (debug) { console.error(consolePrefix + functionName + '> Failure Response > ', response); }
                        var msg = '';
                        if (response && response.length > 0) {

                            if (response[0].errorCode === 'INVALID_SESSION_ID') {
                                service.logout(true);
                            }

                            var i = 0;
                            while (i < response.length) {
                                if (response[i].message)
                                { msg += response[i].message + ' '; }
                                i++;
                            }
                        }
                        try { failureCallback('Cannot find Salesforce record: (' + (status || '') + ') ' + (msg || response)); } catch (e) { }
                    } catch (e) {
                        console.error(functionName, e.message);
                        failureCallback(e.message);
                    }
                };

                var successHandler = function (response) {
                    try {
                        if (debug) { console.log(consolePrefix + functionName + ' > Success Response > ', response); }

                        allRecords = allRecords.concat(response.records);

                        if (!response.done && response.nextRecordsUrl) {
                            config.url = store.url + response.nextRecordsUrl;
                            $http(config).success(successHandler).error(errorHandler);
                        }
                        else { try { successCallback(allRecords); } catch (e) { } }
                    } catch (e) {
                        console.error(functionName, e.message);
                        failureCallback(e.message);
                    }

                };

                $http(config).success(successHandler).error(errorHandler);

            } catch (e) {
                console.error(functionName, e.message);
                failureCallback(e.message);
            }

        },
        //-- /Search --//


        //-- Auth --//
        //  Authenticate with the service
        //      successCallback: function(authId)
        authenticate: function (credentials, successCallback, failCallback) {
            // https://login.salesforce.com/services/oauth2/authorize?response_type=code&client_id= &redirect_uri=
        },

        //  is this client currently authenticated?
        //      return true/false
        isAuthenticated: function () {
        },
        //-- /Auth --//


        //-- Define --//
        //  Get a list of all available entities (lead, contact, account, etc)
        //      successCallback: function(entityList)
        listEntities: function (successCallback, failCallback) {
        },

        //  Get the definition for an entity (field names of a lead or contact)
        //      successCallback: function(entityDefinition)
        defineEntity: function (entity, successCallback, failCallback) {
        },
        //-- /Define --//


        findDuplicates: function (recordType, contact, successCallback, failCallback) {
            const functionName = 'Find Duplicates';
            try {

                if (debug) { console.log(consolePrefix + functionName, recordType, contact); }

                if (typeof store.url === 'undefined') {
                    console.error(functionName + ' > Not initialized > ', store);
                    try { failCallback('Session expired. Please log in.'); } catch (e) { }
                    return;
                }

                var encode = function (s) {
                    if (typeof s === 'undefined') { s = ''; }
                    return s.replace(/'/g, '\\\'');
                };

                if (recordType === 'lead') { recordType = 'Lead'; }
                if (recordType === 'contact') { recordType = 'Contact'; }

                var fields = 'ID,LastName,FirstName,Email,Company,Phone,Title';
                if (recordType === 'Contact') { fields = 'ID,LastName,FirstName,Email,Title,Phone,Account.Name'; }

                var from = recordType;
                if (recordType === 'Contact')
                { from = 'Contact,Contact.Account'; }

                var where = '';

                var dups = [];

                var reponseHandle = null;
                var returnResponse = function () {
                    try {
                        successCallback({ duplicates: dups });
                    } catch (e) { }
                };

                var query = function (q) {

                    try {

                        //calls Salesforce REST API with jQuery
                        jQuery.ajax({
                            type: 'GET',
                            url: store.url + '/services/data/v34.0/query/?q=' + q,
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (sfdata) {
                                console.log('findDuplicates results', sfdata);

                                if (!sfdata.records)
                                { try { failCallback(); } catch (e) { } }


                                for (var i = 0; i < sfdata.records.length; i++) {
                                    var dup = {};
                                    if (recordType === 'Lead') { dup = service.fromLead(sfdata.records[i]); }
                                    else if (recordType === 'Contact') { dup = service.fromContact(sfdata.records[i]); }
                                    dups.push(dup);
                                }

                                if (reponseHandle) {
                                    window.clearTimeout(reponseHandle);
                                }
                                reponseHandle = window.setTimeout(returnResponse, 2000);

                            },
                            failure: function (error) {
                                console.log('ERROR in findDuplicates', error); // 401 [{"message":"Session expired or invalid","errorCode":"INVALID_SESSION_ID"}]
                                try { failCallback(); } catch (e) { }
                            },
                            xhr: function () {
                                var xhr = new window.XMLHttpRequest();
                                xhr.addEventListener('error', function (evt) {
                                    console.log('XHR Event: an error occured');
                                }, false);
                                xhr.addEventListener('abort', function () {
                                    console.log('XHR Event: cancelled');
                                }, false);
                                return xhr;
                            },
                            error: function (errorResponse) {
                                console.log('AJAX error in request: ' + JSON.stringify(errorResponse || '', null, 2));

                                if (errorResponse && errorResponse.responseJSON && errorResponse.responseJSON.length > 0) {
                                    var errorCode = errorResponse.responseJSON[0].errorCode;
                                    var message = errorResponse.responseJSON[0].message;

                                    if (errorCode === 'INVALID_SESSION_ID') {
                                        try {
                                            //var loginCallback = 
                                            service.logout(true);
                                            try { failCallback(message); } catch (e) { }
                                            //TODO: Add a callback to login and do not return an error.
                                            //service.login(function () {
                                            //    service.findDuplicates(recordType, contact, successCallback, failCallback);
                                            //}, function (error) {
                                            //    console.error(functionName + ' > Login Failure > ', error || message);
                                            //    try { failCallback(error || message); } catch (e) { }
                                            //}, true);
                                        } catch (e) {
                                            console.error(functionName + ' > Relogin Failure > ', e.message);
                                            try { failCallback(e.message); } catch (e) { }
                                        }
                                    } else {
                                        //API_DISABLED_FOR_ORG
                                        try { failCallback(message); } catch (e) { }
                                    }
                                }
                                else {
                                    try { failCallback(); } catch (e) { }
                                }
                            }
                        })
                        ;

                    } catch (e) {
                        console.log('ERROR in query', e.message);
                        try { failCallback(); } catch (e) { }
                    }

                };


                if (contact.email) {
                    where = 'Email=\'' + encode(contact.email) + '\'';
                    if (recordType === 'Lead')
                    { where += '+AND+IsConverted=False'; }
                    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                }

                if (contact.last && contact.first) {
                    where = 'LastName=\'' + encode(contact.last) + '\'+AND+FirstName=\'' + encode(contact.first) + '\'';
                    if (recordType === 'Lead')
                    { where += '+AND+IsConverted=False'; }
                    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                }

                //if (contact.phone && contact.last) {
                //    where = 'LastName=\'' + encode(contact.last) + '\'+AND+Phone=\'' + encode(contact.phone) + '\'';
                //    if (recordType === 'Lead')
                //    { where += '+AND+IsConverted=False'; }
                //    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                //}

                if (contact.email2) {
                    where = 'Email=\'' + contact.email2 + '\'';
                    if (recordType === 'Lead')
                    { where += '+AND+IsConverted=False'; }
                    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                }

            } catch (e) {
                console.error(functionName, e.message);
                failCallback(e.message);
            }
        },


        getDetails: function (captureRecord, parentRecordType, successCallback, failCallback) {





            console.log('getDetails', captureRecord);

            var recordId = captureRecord._id;



            var config = { headers: { 'Content-type': 'application/json', 'Authorization': 'Bearer ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' } };
            var url = null;

            if (parentRecordType.toLowerCase() === 'lead') {
                url = store.url + '/services/data/v33.0/query/?q=SELECT LastActivityDate, ' +
                    ' (SELECT ActivityDate, ActivityType, Description, Status, Subject, Owner.Name FROM ActivityHistories LIMIT 10),' +
                    ' (SELECT ActivityDate, Description, Status, Subject, Owner.Name FROM Tasks LIMIT 10)' +
                    ' FROM Lead WHERE Id = \'' + recordId + '\'';
            }
            else if (parentRecordType.toLowerCase() === 'contact') {
                url = store.url + '/services/data/v33.0/query/?q=SELECT LastActivityDate, ' +
                    ' Account.Name, Account.Website, ' +
                    ' (SELECT ActivityDate, ActivityType, Description, Status, Subject, Owner.Name FROM ActivityHistories LIMIT 10),' +
                    ' (SELECT ActivityDate, Description, Status, Subject, Owner.Name FROM Tasks LIMIT 10),' +
                    ' (SELECT Amount, IsClosed, IsWon, CloseDate, LastActivityDate, StageName, Type, Description, Owner.Name FROM Opportunities LIMIT 10)' +
                    ' FROM Contact WHERE Id = \'' + recordId + '\'';
            } else {
                try { failCallback('Cannot retrieve Salesforce record type: ' + parentRecordType); } catch (e) { }
                return;
            }

            captureRecord._act = captureRecord._act || {};
            captureRecord._opp = captureRecord._opp || {};

            var parseOpp = function (record) {

                var detailRecord = null;
                var detailRecordId = null;

                if (typeof record.Opportunities === 'object' && record.Opportunities !== null && record.Opportunities.totalSize > 0) {

                    for (var i = 0; i < record.Opportunities.totalSize; i++) {
                        detailRecord = record.Opportunities.records[i];
                        console.log('getDetails->opp', detailRecord);
                        detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                        //console.log('***** opp link', detailRecord.attributes.url, detailRecordId, store.url);
                        var a = detailRecord.Amount;
                        var n;
                        if (detailRecord.Amount && detailRecord.Amount > 1000000) {
                            n = Math.round(detailRecord.Amount / 1000000);
                            a = '$' + n + 'K';
                        }
                        else if (detailRecord.Amount && detailRecord.Amount > 1000) {
                            n = Math.round(detailRecord.Amount / 1000);
                            a = '$' + n + 'K';
                        }
                        var opp = {
                            who: detailRecord.Owner.Name,
                            when: detailRecord.LastActivityDate,
                            what: detailRecord.Name + ' ' + a,
                            details: detailRecord.Description,
                            link: store.url + '/' + detailRecordId
                        };

                        if (i === 0) {
                            captureRecord._opp.last = opp;
                        } else {
                            captureRecord._opp.next = opp;
                        }
                    }
                }
            };

            var successHandler2 = function (response) {
                console.log('getDetails->successCallback2', response);

                try {

                    if (response !== null && response.totalSize > 0) {

                        var record = response.records[0];

                        parseOpp(record);

                    }
                } catch (e) {
                    console.log('********************* ERROR in getDetails->successCallback2: ' + e.message);
                }

                console.log('captureRecord = ', captureRecord);

                try { successCallback(captureRecord); } catch (e) { }

            };

            var successHandler = function (response) {
                console.log('getDetails->successCallback', response);

                var suspendCallback = false;

                try {

                    if (response !== null && response.totalSize > 0) {

                        var record = response.records[0];
                        var detailRecord = null;
                        var detailRecordId = null;

                        captureRecord._dt = record.LastActivityDate;

                        if (typeof record.Account === 'object' && record.Account !== null) {
                            detailRecord = record.Account;
                            console.log('*** getDetails->account', detailRecord);
                            captureRecord.company = captureRecord.company || detailRecord.Name;
                            captureRecord.website = captureRecord.website || detailRecord.Website;
                            captureRecord._website = detailRecord.Website;
                            detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                            captureRecord._companyLink = store.url + '/' + detailRecordId;
                            console.log('*** getDetails->account->captureRecord', captureRecord);
                            // Query for opportunities
                            if (detailRecordId) {

                                url = store.url + '/services/data/v33.0/query/?q=SELECT ' +
                                   ' (SELECT Name, Amount, IsClosed, IsWon, CloseDate, LastActivityDate, StageName, Type, Description, Owner.Name FROM Opportunities LIMIT 10)' +
                                   ' FROM Account WHERE Id = \'' + detailRecordId + '\'';

                                $http.get(url, config)
                                    .success(successHandler2)
                                    .error(function (response, status) {
                                        var error = 'Cannot retrieve Salesforce record';
                                        if (response.message) { error = response.message; }
                                        console.log('ERROR in salesforce.retrieveOppRecord:' + JSON.stringify(response));
                                        try { failCallback('Cannot retrieve Salesforce record: (' + status + ') ' + response, status); } catch (e) { }
                                    });

                                suspendCallback = true;

                            }

                        }

                        if (typeof record.ActivityHistories === 'object' && record.ActivityHistories !== null && record.ActivityHistories.totalSize > 0) {
                            detailRecord = record.ActivityHistories.records[0];
                            console.log('*** getDetails->activityRecord', detailRecord);
                            detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                            captureRecord._act.last = {
                                who: detailRecord.Owner.Name,
                                when: detailRecord.ActivityDate,
                                what: detailRecord.Subject,
                                details: detailRecord.Description,
                                link: store.url + '/' + detailRecordId
                            };
                        }

                        if (typeof record.Tasks === 'object' && record.Tasks !== null && record.Tasks.totalSize > 0) {
                            detailRecord = record.Tasks.records[record.Tasks.totalSize - 1];
                            console.log('*** getDetails->task', detailRecord);
                            detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                            captureRecord._act.next = {
                                who: detailRecord.Owner.Name,
                                when: detailRecord.ActivityDate,
                                what: detailRecord.Subject,
                                details: detailRecord.Description,
                                link: store.url + '/' + detailRecordId
                            };
                        }

                        parseOpp(record);

                        //if (typeof record.Opportunities === 'object' && record.Opportunities !== null && record.Opportunities.totalSize > 0) {
                        //    detailRecord = record.Opportunities.records[record.Opportunities.totalSize - 1];
                        //    console.log('getDetails->opp', detailRecord);
                        //    detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.indexOf('/Opportunities/') + 15);
                        //    captureRecord._opp.last = {
                        //        who: detailRecord.Owner.Name,
                        //        when: detailRecord.LastActivityDate,
                        //        what: detailRecord.Amount,
                        //        details: detailRecord.Description,
                        //        link: store.url + '/' + detailRecordId
                        //    };
                        //}

                    }
                } catch (e) {
                    console.log('********************* ERROR in getDetails->successCallback: ' + e.message);
                }

                console.log('captureRecord = ', captureRecord);

                if (!suspendCallback) {
                    try { successCallback(captureRecord); } catch (e) { }
                }

            };

            $http.get(url, config)
                .success(successHandler)
                .error(function (response, status) {
                    var error = 'Cannot retrieve Salesforce record';
                    if (response.message) { error = response.message; }
                    if (debug) { console.log('salesforce.retrieveRecord:' + JSON.stringify(response)); }
                    try { failCallback('Cannot retrieve Salesforce record: (' + status + ') ' + response, status); } catch (e) { }
                });

        },
        // ***********************************
        // ** Salesforce-specific functions **
        // ***********************************

        convertStateToSalesforceStateCode: function (state) {

            if (typeof state === 'undefined' || state === null || state === '') {
                return '';
            }

            var key = state.toLowerCase();
            var r = geographyData.stateNameLowerToStateCodeDict[key];
            if (!r) {
                r = state;
            }
            return r.toUpperCase();

        },

        convertCountryToSalesforceCountryCode: function (country) {

            if (typeof country === 'undefined' || country === null || country === '') {
                return '';
            }

            var key = country.toLowerCase();
            var r = geographyData.countryNameLowerToCountryCodeDict[key];
            if (!r) {
                r = country;
            }
            return r.toUpperCase();
        },

        isUSState: geographyData.isUSStateCode,

        limitstr: //backgroundUtility.limitstr,
            function (s, limit) {
                if (!s || !limit) {
                    return s;
                }
                if (s.length > limit) {
                    return s.substring(0, limit);
                }
                return s;
            },


        //var updateRecord = function (id, fields) {

        //    if (debug) { console.log(debug + 'updateRecord', id, angular.copy(fields)); }

        //    //calls Salesforce REST API with jQuery
        //    jQuery.ajax({
        //        type: 'PATCH',
        //        url: url + id,
        //        contentType: 'application/json',
        //        dataType: 'json',
        //        data: JSON.stringify(fields),
        //        beforeSend: function (xhr) {
        //            xhr.setRequestHeader('Authorization', 'Bearer ' + store.id);
        //            xhr.setRequestHeader('Accept', 'application/json');
        //        },
        //        success: function (successResponse) {
        //            handleSuccess(successResponse);
        //        },
        //        error: function (errorResponse) {
        //            handleError(errorResponse, f);
        //        }
        //    });

        //};

        /**
        * @function validateRecord
        * @description Validates if record can be exported. Returns list of errors.
        * @memberOf captureApp.webServices.exportTargetVer1.salesforce
        * @param {recordType} recordType - Record type
        * @param {captureContact} captureRecord - Source Capture Contact. 
        */
        validateRecord: function (recordType, captureRecord) {

            var errors = [];

            if (!captureRecord) {
                errors.push('Record does not exist');
            } else {
                if (!captureRecord.last) {
                    errors.push('Last name is required');
                }
            }

            return errors;
        }

    };
    return service;
}]);
/**
 * @class captureApp.webServices.exportTargetVer1.salesloft
 * @memberOf captureApp.webServices.exportTargetVer1
 * @description This is Salesloft AngularJS service.
 * @constructor
 * @param {object} $http - Angular HTTP service.
 * @param {object} $q - jQuery.
 * @param {object} endpoints - Capture enpoints service.
 * @param {object} dialogs - Capture dialogs service.
 */

/**********************************************************************
* Salesloft AngularJS service
* Author: Justin Stull  
* Email: jstull@ringlead.com
* Version: 0.0.1

failCallback: function( errorMessage, statusCode (optional), other (optional) )

Minimum implementation:

- createRecord
- isLoggedIn
- login

**********************************************************************/
'use strict';

/* global angular: false */
/* global jQuery: false */
/* global geographyData: false */
/* global backgroundUtility: false */

angular.module('webServices')
.factory('salesloft', ['$http', '$q', 'endpoints', 'dialogs', function ($http, $q, endpoints, dialogs) {

    var debug = 'salesloft.js->';
    var defaultUrl = 'https://sdr.salesloft.com/public_api/v1/';
    var store = {};

    /* Builds basic Salesloft REST url from provided Service URL and Team Pipeline ID*/
    var buildUrl = function (serviceUrl, body) {
        return serviceUrl + body;
    };

    var getVenue = function (contact, filter) {
        if (contact.venues) {
            var i;
            for (i = 0; i < contact.venues.length; i++) {
                var w = contact.venues[i].website;
                console.log('*** VENUE ***', w);
                if (w && w.indexOf(filter) >= 0) {
                    return w;
                }
            }
        }
        return null;
    };
    var getCustomFieldValue = function (contact, fieldName) {
        if (contact.CustomFields) {
            var i;
            for (i = 0; i < contact.CustomFields.length; i++) {
                var w = contact.CustomFields[i].Values[0];
                if (w !== undefined && contact.CustomFields[i].FieldName === fieldName) {
                    return w;
                }
            }
        }
        return null;
    };



    /* Handles error response from Salesloft API. It should try to return string message if provided. 
    *
    * r - HTTP response
    * asJson - if true, then error message will returns as JSON object, otherwise as String.
    */
    var handleErrorMessageText = function (r, asJson) {
        var status = r.status || 500;
        var msg = '';
        if (r.responseJSON) { msg = r.responseJSON; }
        else if (r.responseText) {
            try {
                msg = JSON.parse(r.responseText);
            } catch (err) {
                msg = r.responseText;
            }
        } else if (r.statusText) {
            msg = r.statusText;
        } else {
            msg = 'Unknown error';
        }
        if (asJson !== undefined) {
            return msg;
        } else {
            if (msg.hasOwnProperty('message')) { msg = msg.message; }
            return msg;
        }
    };

    var getDomain = function (website) {
        var regex = /([a-z0-9-]+)([.]([a-z]{1,3})(?![a-z-])){1,2}/ig;
        var d = regex.exec(website);
        if (d && d.length > 0) { d = d[0]; }
        if (d && d.length > 0) { d = d.toLowerCase(); }
        console.log('domain', d, 'website', website);
        return d;
    };

    var mapField = function (source, sourceKey, target, targetKey) {
        target[targetKey] = source[sourceKey];
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };
    var toContact = function (captureRecord) {

        if (debug) {
            console.log(debug + 'toContact:in', captureRecord);
        }

        var nativeRecord = {};
        nativeRecord.CustomFields = [];
        mapField(captureRecord, 'first', nativeRecord, 'first_name');
        mapField(captureRecord, 'last', nativeRecord, 'last_name');
        mapField(captureRecord, 'jobtitle', nativeRecord, 'title');
        mapField(captureRecord, 'company', nativeRecord, 'company_name');
        mapField(captureRecord, 'website', nativeRecord, 'website');
        mapField(captureRecord, 'email', nativeRecord, 'email_address');
        mapField(captureRecord, 'phone', nativeRecord, 'phone');
        mapField(captureRecord, 'phone2', nativeRecord, 'mobile_phone');
        mapField(captureRecord, 'city', nativeRecord, 'city');
        mapField(captureRecord, 'state', nativeRecord, 'state');

        if (debug) {
            console.log(debug + 'toContact:out', nativeRecord);
        }

        return nativeRecord;
    };


    var fromContact = function (nativeRecord) {

        if (debug) {
            console.log(debug + 'fromContact:in', nativeRecord);
        }

        var captureRecord = {};
        captureRecord.venues = [];

        mapFromField(captureRecord, 'first', nativeRecord, 'first_name');
        mapFromField(captureRecord, 'last', nativeRecord, 'last_name');
        mapFromField(captureRecord, 'jobtitle', nativeRecord, 'title');
        mapFromField(captureRecord, 'company', nativeRecord, 'company_name');
        mapFromField(captureRecord, 'website', nativeRecord, 'website');
        mapFromField(captureRecord, 'email', nativeRecord, 'email_address');
        mapFromField(captureRecord, 'phone', nativeRecord, 'phone');
        mapFromField(captureRecord, 'phone2', nativeRecord, 'mobile_phone');
        mapFromField(captureRecord, 'city', nativeRecord, 'city');
        mapFromField(captureRecord, 'state', nativeRecord, 'state');


        if (debug) {
            console.log(debug + 'fromContact:venues', captureRecord.venues);
        }

        captureRecord._link = 'https://sdr.salesloft.com/app/people/' + nativeRecord.id + '/activities';
        captureRecord._type = 'Contact';
        captureRecord._id = nativeRecord.id;

        console.log('000000000000000000000 LINK: ' + captureRecord._link);

        if (debug) {
            console.log(debug + 'fromContact:out', captureRecord);
        }

        return captureRecord;
    };


    /*
    * Returns default HTTP request template.
    *
    * method - called Salesloft REST method
    */
    var buildRequest = function (method, successCallback, failCallback) {
        return {
            type: 'GET',
            contentType: 'application/json',
            crossDomain: true,
            success: function (successResponse, textStatus, xhr) {
                successCallback(successResponse, textStatus, xhr);
            },
            error: function (errorResponse) {
                var response = handleErrorMessageText(errorResponse);
                failCallback(response, errorResponse.status || 500);
            }
        };
    };

    var service = {


        /**
        * @function getName
        * @description Return name of export target.
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        */
        getName: function () {
            return 'Salesloft';
        },


        /**
        * @function init
        * @description Initializes store object. Sets user credentials, owner and team pipeline id.
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {object} o - List of target-specific settings.
        */
        init: function (o) {
            console.log('000000000000000000 INIT 000000000000000000');
            if (debug) { console.log(debug + 'Initializing Login ...'); }
            console.log('Store Refresh Token: ', store.refreshToken);
            if (!store.refreshToken) {
                store.accessToken = o.refreshToken;
            }
            //https://stratus.ringlead.com/v1/Authentication/dbe14c64-63a3-40f5-ad96-c8f06befd50a/_AUTHENTICATE?url=https://stratus.ringlead.com/v1/AUTHENTICATION/Request?token={0}
            console.log(store.refreshToken);
        },


        /**
        * @function login
        * @description Logs user in. Either silently (if possible) or interactively.
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - This callback informs that user was logged in successfully. 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - This callback informs that user cannot log in.
        */
        login: function (successCallback, failCallback, silent) {

            console.log('000000000000000000 LOGIN 000000000000000000');

            if (debug) { console.log(debug + 'Logging into Salesloft...'); }

            if (!store.refreshToken) {
                try { failCallback('Please open Settings and enter your user credentials'); } catch (e) { }
                return;
            }

            //var openTab = function () {
            //    try {
            //        // TODO validate the assumption that any pcrDatabaseId contains uid (before period) and that the url form is the same for all PCR users/orgs 
            //        var uid = store.pcrDatabaseId.split('.')[0];
            //        chrome.tabs.create({ url: 'https://www2.pcrecruiter.net/pcr.asp?uid=odbc.' + uid }, function () { });
            //    } catch (e) {

            //    }
            //};

            var config = {
                'client_id': '9ca842e02dce70de6ead42609a88032e569ccd6de8e4cc656d799cf52065eb41',
                'client_secret': 'c13303124a00dfc9cdf36dcf5bd045a496632374182e106d1e56c570e6d1f790',
                'grant_type': 'refresh_token',
                'refresh_token': store.refreshToken
            };

            var request = buildRequest('', successCallback, failCallback);
            request.url = 'https://accounts.salesloft.com/oauth/token';
            request.type = 'POST';
            request.data = JSON.stringify(config);
            request.success = function (successResponse, status, xhr) {
                store.refreshToken = successResponse.refresh_token;
                store.accessToken = successResponse.access_token;


                //if (silent === false) {
                //    openTab();
                //}
                console.log('000000000000000000 ACCESS TOKEN 000000000000000000');
                console.log(store.accessToken);
                successCallback();
            };
            jQuery.ajax(request);
        },

        /**
         * @function logout
         * @description Logs user out. Cleans up store variable.I
         * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
         */
        logout: function () {
            if (debug) { console.log(debug + 'Logged out...'); }
        },


        /**
         * @function isLoggedIn
         * @description Checks if user is logged in.
         * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInSuccessCallback} successCallback - This callback informs that user is currently logged in.
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInFailCallback} failCallback - This callback informs that user is not currently logged in.
         */
        isLoggedIn: function (successCallback, failCallback) {
            var isLogged = store.accessToken !== undefined ? true : false;

            if (debug) { console.log(debug + 'isLogged', isLogged); }

            if (!isLogged) {
                // Since we can do it... Do silent login.
                service.login(successCallback, failCallback);
            }
            else { try { successCallback(); } catch (e) { } }
        },


        /**
       * @function createRecord
       * @description Creates record.
       * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
       * @param {recordType} recordType - Destination Record Type
       * @param {captureContact} captureRecord - Source Capture Record.
       * @param {object} createOptions - Options (For future use)
       * @param {captureApp.webServices.exportTargetVer1~createRecordSuccessCallback} successCallback 
       * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
       */
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {

            console.log('000000000000000000 CREATE RECORD 000000000000000000');

            if (debug) { console.log(debug + 'createRecord', captureRecord); }

            var createContact = function () {

                console.log('000000000000000000 CREATE CONTACT 000000000000000000');

                var record = {
                    'email_address': (captureRecord.email || ''),
                    'first_name': (captureRecord.first || ''),
                    'last_name': (captureRecord.last || ''),
                    'phone': (captureRecord.phone || ''),
                    'mobile_phone': (captureRecord.phone2 || ''),
                    'linkedin_url': (getVenue(captureRecord, 'linkedin.com') || ''),
                    'company_id': (''), //TODO
                    'company_name': (captureRecord.company || ''),
                    'company_url': (captureRecord.website || ''),
                    'title': (captureRecord.jobtitle || ''),
                    'city': (captureRecord.city || ''),
                    'state': (captureRecord.state || '')
                };

                if (createOptions && createOptions.mappedProperties) {
                    var j = createOptions.mappedProperties.length;
                    while (j--)
                    { record[createOptions.mappedProperties[j].name] = createOptions.mappedProperties[j].value; }
                }

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                //var successCallback2 = function (successResponse, textStatus, xhr) {

                //if (debug) { console.log(debug + 'response', successResponse); }
                /*var urlBody = 'candidates';
                var request = buildRequest(nativeRecordType, successCallback, failCallback);
                request.beforeSend = function (xhr) {
                    xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                request.url = buildUrl(defaultUrl, urlBody);
                request.type = 'POST';
                request.data = JSON.stringify(record);
                jQuery.ajax(request);*/

                var url = buildUrl(defaultUrl, 'people.json');

                var config = {
                    headers: {
                        'Authorization': 'Bearer ' + store.accessToken
                    }
                };

                $http.post(url, record, config)
                    .success(function (data, status, headers, config) {
                        if (debug) { console.log(debug + 'response', data, status); }
                        try { successCallback(); } catch (e) { }
                    })
                    .error(function (data, status, headers, config) {
                        console.log(debug + 'ERROR in POST', data, status, headers, config);
                        try { failCallback(); } catch (e) { }
                    });

            };

            var createCompany = function (nativeRecordType) {

                console.log('000000000000000000 CREATE COMPANY 000000000000000000');

                var record = {
                    'name': (captureRecord.company || ''),
                    'domain': (captureRecord.website || ''),
                    'city': (captureRecord.city || ''),
                    'country': (captureRecord.country || ''),
                    'phone': (captureRecord.phone || ''),
                    'state': (captureRecord.state || ''),
                    'website': (captureRecord.website || '')
                };

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    if (debug) { console.log(debug + 'response', successResponse); }

                    var id = successResponse.id;
                    var link = '';

                    try { successCallback(link, id); } catch (e) { }
                };
                var urlBody = 'companies.json';
                var request = buildRequest(nativeRecordType, successCallback2, failCallback);
                request.beforeSend = function (xhr) {
                    xhr.setRequestHeader('Authorization', 'Bearer ' + store.accessToken);
                };
                request.url = buildUrl(defaultUrl, urlBody);
                request.type = 'POST';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                createContact('Contacts');
            } else if (recordType.toUpperCase() === 'ACCOUNT') {
                createCompany('Account');
            } else {
                failCallback('Invalid record type: ' + (recordType || 'Null'));
            }

        },


        /**
        * @function updateRecord
        * @description Updates record.
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {string} recordId - Record ID
        * @param {recordType} recordType - Record Type ('lead', 'contact' or 'account')
        * @param {object} record - Native record. Include only fields to be updated. 
        * @param {captureApp.webServices.exportTargetVer1~updateRecordSuccessCallback} successCallback 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
        */
        updateRecord: function (recordId, recordType, record, successCallback, failCallback) {

            console.log('000000000000000000 UPDATE RECORD 000000000000000000');

            if (debug) { console.log(debug + 'updateRecord', recordId, recordType, record); }

            var updateContact = function (nativeRecordType) {

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    if (debug) { console.log(debug + 'response', successResponse); }
                    try { successCallback(recordId); } catch (e) { }
                };

                var buildRequest2 = function (method, id, successCallback, failCallback) {
                    var urlBody = 'people/';
                    return {
                        type: 'GET',
                        url: buildUrl(defaultUrl, urlBody) + id,
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'Bearer ' + store.accessToken);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {
                            var response = handleErrorMessageText(errorResponse);
                            failCallback(response, errorResponse.status || 500);
                        }
                    };
                };

                var request = buildRequest2(nativeRecordType, recordId, successCallback2, failCallback);
                request.type = 'PATCH';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                updateContact('Contacts');
            } else {
                failCallback('Invalid record type');
            }

        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {
            //if (debug) { console.log(debug + 'toLookupObject->entityType', entityType, '->crmObject', crmObject); }

            console.log('000000000000000000 TO LOOKUP OBJECT 000000000000000000');

            var lookupObject = { label: '', link: '' };

            try {
                if (entityType.toLowerCase() === 'account') {

                    console.log('000000000000000000 TO LOOKUP OBJECT ACCOUNT 000000000000000000');
                    console.log(crmObject);

                    var cityState = '';
                    if (crmObject && (crmObject.City || crmObject.State)) {
                        cityState = ' (' + (crmObject.City || '') + ((crmObject.City && crmObject.State) ? ', ' : '') + (crmObject.State || '') + ')';
                    }
                    lookupObject.label = (crmObject.domain || '(no name)');
                    lookupObject.link = '';
                    lookupObject.id = crmObject.id;
                }
            } catch (e) {
                console.log('ERROR in toLookupObject', e.message);
            }

            //if (debug) { console.log(debug + 'toLookupObject->result', lookupObject); }
            return lookupObject;
        },

        /**
        * @function getRequiredLookups
        * @description Returns an array of lookups required prior to saving a record .
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {recordType} recordType - Record type 
        * @return {captureApp.webServices.exportTargetVer1~lookup[]}
        */
        getRequiredLookups: function (entityType, actualMap) {

            console.log('000000000000000000 GET REQUIRED LOOKUPS 000000000000000000');

            entityType = entityType.toLowerCase();

            if (actualMap) {

                if (debug) { console.log(debug + 'getRequiredLookups->map', actualMap); }

                var aa = [];

                // convert map def to lookup def

                for (var i = 0, l = actualMap.fields.length; i < l; i++) {
                    var f = actualMap.fields[i];
                    if (f.source && (f.source.type === 'lookup' || f.source.type === 'picklist' || f.source.type === 'action')) {

                        if (f.source && f.source.value && f.source.value.enabled === false) {
                            console.log('disabled action', angular.copy(f));
                            continue;
                        }

                        var a;

                        if (f.source.value) {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: f.source.value.appProperty,
                                message: f.source.value.message,
                                type: f.source.value.type,
                                defaultValue: f.source.value.defaultValue ? { id: f.source.value.defaultValue.value, label: f.source.value.defaultValue.label } : null,
                                required: f.source.value.required,
                                allowNew: f.source.value.allowNew,
                                picklist: f.source.value.picklist || f.source.type === 'picklist',
                                resolve: f.source.value.resolve,
                                hidden: f.source.value.hidden
                            };
                        } else {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: '',
                                message: '',
                                type: '',
                                defaultValue: '',
                                required: false,
                                allowNew: false,
                                picklist: f.source.type === 'picklist',
                                resolve: null,
                            };
                        }

                        if (f.source.type === 'picklist') {
                            a.type = entityType;
                            a.allowNew = false;
                        }


                        aa.push(a);
                    }
                }

                if (debug) { console.log(debug + 'getRequiredLookups->result', aa); }

                return aa;
            }

            if (entityType === 'contact') {
                console.log('000000000000000000 GET REQUIRED LOOKUPS CONTACT 000000000000000000');
                return [ //{ crmProperty: 'company_id', appProperty: 'website', message: 'Select Company Domain', type: 'Account', required: false, allowNew: true, resolve: 'createNewAccount' }
                    //,
                    //    { crmProperty: 'OwnerId', appProperty: 'full', message: 'Select account owner', type: 'SystemUser', required: false, allowNew: false }
                ];
            }
            /*if (entityType === 'lead') {
                //return [{
                //    crmProperty: 'Campaign', appProperty: 'campaign', message: 'Select Campaign', type: 'Campaign', required: false, allowNew: false,
                //    resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //        service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    },
                //}, {
                //    crmProperty: 'LeadSource', appProperty: null, message: 'Select Lead Source', type: 'Lead', required: true, allowNew: false,
                //    picklist: true//,
                //    //resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //    //    console.log('resolve called', lookupId, objectId)
                //    //    //service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    //},
                //}];
            }*/
            if (entityType === 'account') { return []; }
            return [];
        },

        resolveLookup: function (actionId, lookupId, objectId, successCallback, failCallback) {

            console.log('000000000000000000 RESOLVE LOOKUP 000000000000000000');

            console.log(debug + 'resolveLookup->action->', actionId);
            console.log(debug + 'resolveLookup->lookup->', lookupId);
            console.log(debug + 'resolveLookup->object->', objectId);

            if (actionId === 'createNewAccount') {

                console.log('000000000000000000 RESOLVE LOOKUP CREATE NEW ACCOUNT 000000000000000000');

                if (!lookupId.newName) {
                    // existing account, quit
                    try { successCallback(); } catch (e) { }
                    return;
                }

                var createSourceRecord = angular.copy(lookupId.record);
                createSourceRecord.company = lookupId.newName;

                service.createRecord('Account', createSourceRecord, null,

                    // created successfully
                    function (accountLink, accountId) {
                        console.log('account was created', accountLink, accountId);
                        var updateData = {};
                        updateData[lookupId.crmProperty] = accountId;
                        // update the new candidate
                        service.updateRecord(objectId, 'Contact', updateData, successCallback, failCallback);
                    },

                    // create failed
                    function (msg) {
                        console.log('account was not created', msg);
                        failCallback('Account was not created');
                    }

                );

            } else if (actionId === 'addToCadence') {


            } else {

                console.log('ERROR: Unknown action', lookupId);
                failCallback('Unknown action');

            }

        },


        /**
        * @function getDefaultExportMaps
        * @description (Reserved for future use) Return an empty array. 
        * maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefaultExportMaps: function (successCallback, failureCallback) {

            var maps = [];

            //maps.push({ name: 'contact', label: 'Contact', map: null });

            successCallback(maps);
        },


        /**
        * @function getDefinition
        * @description Returns configuration for Multi-Merge dialog. 
        * How to modify:
        * 1. Put native field names in def.fields.map.{Field}.id
        * 2. Remove lines that do not have corresponding native fields, or where fields are read-only
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {string} recordType - 'lead', 'contact' or 'account'. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefinition: function (recordType, successCallback, failureCallback) {

            console.log('000000000000000000 GET RECORD TYPE 000000000000000000');


            if (debug) { console.log(debug + 'getDefinition', recordType); }


            var def = {};
            recordType = recordType.toLowerCase();
            /*if (recordType === 'lead') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { display: 'First Name', group: 'G1' },
                            'LastName': { display: 'Last Name', group: 'G1' },
                            'Title': { display: 'Job Title', group: 'G1' },
                            'Company': { display: 'Company', group: 'G1' },
                            'Email': { display: 'Email', group: 'G1' },
                            'Phone': { display: 'Phone', group: 'G1' },
                            'MobilePhone': { display: 'Mobile Phone', group: 'G1' },
                            'Website': { display: 'Website', group: 'G1' },
                            'Description': { display: 'Description', group: 'G1' },

                            'Street': { display: 'Street', group: 'G2' },
                            'City': { display: 'City', group: 'G2' },
                            'State': { display: 'State/Province', group: 'G2' },
                            'PostalCode': { display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { display: 'Country', group: 'G2' },
                        }
                    }
                };

            } else*/ if (recordType === 'contact') {

                console.log('000000000000000000 GET RECORD TYPE CONTACT 000000000000000000');
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Linkedin'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Linkedin', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'first_name', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'last_name', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'title', display: 'Position', group: 'G1' },
                            //'Company': { id: 'QUICK_ACCOUNT_NAME', display: 'Company', group: 'G1' },
                            'Email': { id: 'email_address', display: 'Email 1', group: 'G1' },
                            'Phone': { id: 'phone', display: 'Work Phone', group: 'G1' },
                            'MobilePhone': { id: 'mobile_phone', display: 'Phone 2', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Linkedin': { id: 'linkedin_url', display: 'Linkedin', group: 'G1' },

                            //'Street': { id: 'Address', display: 'Address', group: 'G2' },
                            'City': { id: 'city', display: 'City', group: 'G2' },
                            'State': { id: 'state', display: 'State/Province', group: 'G2' },
                            //'PostalCode': { id: 'PostalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },


        /**
        * @function toNativeRecord
        * @description Converts Capture Contact to native record. 
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {captureContact} captureRecord - Capture Contact
        * @param {recordType} recordType - Record type. 
        * @return {object} - Native record
        */
        toNativeRecord: function (captureRecord, recordType) {
            recordType = recordType.toLowerCase();
            if (recordType === 'contact') { return toContact(captureRecord); }
            return null;
        },


        /**
        * @function fromNativeRecord
        * @description Converts native record to Capture Contact. 
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {object} nativeRecord - Native record
        * @param {recordType} recordType - Record type. 
        * @return {captureContact} - Capture Contact
        */
        fromNativeRecord: function (nativeRecord, recordType) {
            recordType = recordType.toLowerCase();
            if (recordType === 'contact') { return fromContact(nativeRecord); }
            return null;
        },


        /**
        * @function findDuplicates
        * @description Returns an array of duplicate records of given type.
        * @memberOf captureApp.webServices.exportTargetVer1.salesloft
        * @param {captureContact} recordType - Record type. 
        * @param {captureContact} captureRecord - Source Capture Contact. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the resulting array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback  
        * @return {captureContact[]} - Array of Capture Contacts
        */
        findDuplicates: function (recordType, captureRecord, successCallback, failCallback) {

            console.log('000000000000000000 FINDING DUPLICATES 000000000000000000');

            if (debug) { console.log(debug + 'findcoDuplicates', recordType, captureRecord); }


            var findContact = function () {

                if (debug) { console.log(debug + 'findContact', angular.copy(captureRecord)); }

                var filter;

                if (captureRecord.email){
                    filter = encodeURIComponent(captureRecord.email);
                } else {
                    try { failCallback('Salesloft Requires an Email to create a Contact'); } catch (e) { }
                    return;
                }

                if (debug) { console.log(debug + 'filter', filter); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    console.log('Response: ', successResponse);
                    if (debug) { console.log(debug + 'response', successResponse); }

                    var dups = [];
                    var dup = fromContact(successResponse);
                    dups.push(dup);
                    if (debug) { console.log(debug + 'List Dups', dups); }
                    try { successCallback({ duplicates: dups }); } catch (e) { }
                };

                var buildRequest2 = function (method, filter, successCallback, failCallback) {
                    var urlBody = 'people/' + filter;
                    return {
                        type: 'GET',
                        url: buildUrl(defaultUrl, urlBody),
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'Bearer ' + store.accessToken);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            console.log('Duplicates Found');
                            console.log(successResponse);
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {

                            console.log(errorResponse);
                            var response = errorResponse;
                            if (errorResponse.status === 404) {

                                console.log('FIND DUPLICATE 404');
                                failCallback();
                            } else {

                                console.log('FIND DUPLICATE OTHER ERROR');
                                failCallback(response, errorResponse.status || 500);
                            }
                            
                        }
                    };

                };

                var request = buildRequest2(recordType, filter, successCallback2, failCallback);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                recordType = 'Contacts';
                findContact();
            } else {
                try { successCallback({ duplicates: [] }); } catch (e) { }
            }


        },

        findRecord: function (recordType, query, fields, successCallback, failCallback) {
            console.log('000000000000000000 FINDING RECORD 000000000000000000');

            //var service = this;             
            var urlBody;
            var encodeParam = function (p) {
                return p.replace(/'/g, '%5C%27');
            };

            if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

            if (recordType === 'account') { recordType = 'Account'; }
            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            if (recordType === 'campaign') { recordType = 'Campaign'; }

            var where = [];

            if (query) {

                if (query.email)
                { where.push('Email=\'' + encodeParam(query.email) + '\''); }

                if (query.email_endsWith)
                { successCallback(); }

                if (query.last)
                { where.push('LastName=\'' + encodeParam(query.last) + '\''); }

                if (query.first)
                { where.push('FirstName=\'' + encodeParam(query.first) + '\''); }

                if (recordType === 'Account') {
                    if (query.company)
                    { where.push('Name+LIKE+\'%25' + encodeParam(query.company) + '%25\''); }
                }

                /*if (recordType === 'Campaign') {
                    if (query.campaign)
                    { where.push('Name+LIKE+\'%25' + encodeParam(query.campaign) + '%25\''); }
                }*/

                if (recordType === 'Cadence') {
                    if (query.cadence)
                    {where.push('');}
                }

            }
            var whereStr = where.join('+AND+');
            if (whereStr) { whereStr = '+WHERE+' + whereStr; } else { whereStr = '+'; }
            console.log(whereStr);

            var fieldsStr = '*';
            var f;


            if (recordType === 'Account') {

                console.log('000000000000000000 FINDING RECORD ACCOUNT 000000000000000000');
                console.log('Fields: ', fields);
                console.log('Query: ', query);
                urlBody = 'companies/' + query.website;
                f = [];

                f.push('ID');

                if (fields.indexOf('company') > -1) { f.push('Name'); }
                if (fields.indexOf('website') > -1) { f.push('Website'); }
                if (fields.indexOf('_createdDate') > -1) { f.push('CreatedDate'); }

                fieldsStr = f.join(',');
            }

            if (recordType === 'Contact') {
                urlBody = 'people/';
                f = [];

                f.push('ID');

                if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                if (fields.indexOf('last') > -1) { f.push('LastName'); }
                if (fields.indexOf('email') > -1) { f.push('Email'); }
                //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                fieldsStr = f.join(',');
            }

            if (recordType === 'Cadence') {
                urlBody = '';

            }

            var headers = { 'Content-type': 'application/json', 'Authorization': 'Bearer ' + store.accessToken, 'Accept': 'application/json' };
            var config = {
                method: 'GET',
                url: buildUrl(defaultUrl, urlBody),
                headers: headers
            };
            if (debug) { console.log(debug + 'findRecord->config:', config); }

            var allRecords = [];

            var errorHandler = function (response, status) {

                if (debug) { console.log(debug + 'findRecord->failResponse', response); }
                var msg = '';
                if (response && response.length > 0) {

                    if (response[0].errorCode === 'INVALID_SESSION_ID') {
                        console.log(service);
                        service.logout();
                        failCallback('Session expired. Please log in.');
                    }

                    var i = 0;
                    while (i < response.length) {
                        if (response[i].message)
                        { msg += response[i].message + ' '; }
                        i++;
                    }
                }
                if (status === 404) {
                    try { successCallback(allRecords); } catch (e) { }
                } else {
                    try { failCallback(response, status || 500); } catch (e) { }
                }
                

            };

            var successHandler = function (response) {

                if (debug) { console.log(debug + 'findRecord->successResponse', response); }

                allRecords = allRecords.concat(response);

                /*if (!response.done && response.nextRecordsUrl) {
                    config.url = store.url + response.nextRecordsUrl;
                    $http(config).success(successHandler).error(errorHandler);
                }
                else { try { successCallback(allRecords); } catch (e) { } }
                */
                try { successCallback(allRecords); } catch (e) { }
            };

            $http(config).success(successHandler).error(errorHandler);

        },

        /**
        * @function retrieveRecord
        * @description Returns single recor.
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {string} recordId - Record ID 
        * @param {recordType} recordType - Record type
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the native record as a parameter
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - Return error message
        */
        retrieveRecord: function (recordId, recordType, successCallback, failCallback) {

            console.log('000000000000000000 RETREIVE RECORD 000000000000000000');

            if (recordType.toLowerCase() === 'lead') { recordType = 'Leads'; }
            if (recordType.toLowerCase() === 'contact') { recordType = 'Contacts'; }

            var buildRequest2 = function (method, id, successCallback, failCallback) {
                var urlBody = 'people/';
                return {
                    type: 'GET',
                    url: buildUrl(defaultUrl, urlBody) + id,
                    contentType: 'application/json',
                    crossDomain: true,
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader('Authorization', 'Bearer ' + store.accessToken);
                    },
                    success: function (successResponse, textStatus, xhr) {
                        successCallback(successResponse, textStatus, xhr);
                    },
                    error: function (errorResponse) {
                        var response = handleErrorMessageText(errorResponse);
                        failCallback(response, errorResponse.status || 500);
                    }
                };
            };

            var successCallback2 = function (successResponse, textStatus, xhr) {

                if (debug) { console.log(debug + 'response', successResponse); }

                try { successCallback(successResponse); } catch (e) { }
            };

            var request = buildRequest2(recordType, recordId, successCallback2, failCallback);

            jQuery.ajax(request);
        },


        /*
        * Returns JSON with all Team Pipeline Clients. Function is supposed to help obtain value for OWNER_ID field.
        * E.g.: {
        *   "Stefan Smihla (stefan.smihla@pipelinersales)": 12345,
        *   "Example User (example@user.com)": 56789
        * }
        */
        getClients: function (successCallback, failCallback) {

            if (debug) { console.log(debug + 'getClients'); }

            var successFunc = function (successResponse) {
                var clients = {};
                for (var i in successResponse) {
                    var item = successResponse[i];
                    var firstname = item.FIRSTNAME || '';
                    var surname = item.LASTNAME || '';
                    var fullname = firstname + ' ' + surname + ' (' + item.EMAIL + ')';
                    clients[fullname] = item.ID;
                }
                //successCallback(JSON.stringify(clients));
                successCallback(clients);
            };

            service.getEntities('Clients', successFunc, failCallback);
        },

        /* Sets Sales Unit ID. This value will be needed fpr required SALES_UNIT_ID. */
        setSalesUnit: function (salesUnit) {
            store.salesUnit = salesUnit;
        },

        getEntities: function (nativeRecordType, successCallback, failCallback) {

            if (debug) { console.log(debug + 'getEntities', nativeRecordType); }

            var request = buildRequest(nativeRecordType, successCallback, failCallback);
            request.success = successCallback;
            jQuery.ajax(request);
        },

    };

    return service;
}]);
/**
 * @class captureApp.webServices.exportTargetVer1.marketo
 * @memberOf captureApp.webServices.exportTargetVer1
 * @description This is Marketo AngularJS service.
 * @constructor
 * @param {object} $http - Angular HTTP service.
 * @param {object} $q - Angular q service.
 * @param {object} endpoints - Capture enpoints service.
 * @param {object} dialogs - Capture dialogs service.
 */

/**********************************************************************
* Marketo AngularJS service
* Author: Justin Stull  
* Email: jstull@ringlead.com
* Version: 0.0.1

failCallback: function( errorMessage, statusCode (optional), other (optional) )

Minimum implementation:

- createRecord
- isLoggedIn
- login

**********************************************************************/
'use strict';

/* global angular: false */
/* global jQuery: false */
/* global geographyData: false */
/* global backgroundUtility: false */

angular.module('webServices')
.factory('marketo', ['$http', '$q', 'endpoints', 'dialogs', function ($http, $q, endpoints, dialogs) {

    var debug = 'marketo.js->';
    var defaultUrl = 'mktorest.com';
    var store = {};

    /* Builds basic Marketo REST url from provided Service URL and Marketo ID*/
    var buildUrl = function (instance, domain, body) {
        return 'https://' + instance + '.' + domain + body;
    };

    var getVenue = function (record, domain) {
        if (record && record.venues) {
            var venueCount = record.venues.length;
            for (var i = 0; i < venueCount; i++) {
                var profile = record.venues[i].website;
                if (profile && profile.indexOf(domain) >= 0) {
                    return profile;
                }
            }
        }
        return '';
    };

    /* Handles error response from Marketo API. It should try to return string message if provided. 
    *
    * r - HTTP response
    * asJson - if true, then error message will returns as JSON object, otherwise as String.
    */
    var handleErrorMessageText = function (r, asJson) {
        var status = r.status || 500;
        var msg = '';
        if (r.responseJSON) { msg = r.responseJSON; }
        else if (r.responseText) {
            try {
                msg = JSON.parse(r.responseText);
            } catch (err) {
                msg = r.responseText;
            }
        } else if (r.statusText) {
            msg = r.statusText;
        } else {
            msg = 'Unknown error';
        }
        if (asJson !== undefined) {
            return msg;
        } else {
            if (msg.hasOwnProperty('message')) { msg = msg.message; }
            return msg;
        }
    };


    var mapField = function (source, sourceKey, target, targetKey) {
        var sourceKeyParts = sourceKey.split('.');

        if (sourceKeyParts.length === 2) {
            try {
                target[targetKey] = source[sourceKeyParts[0]][sourceKeyParts[1]];
            } catch (e) {
                target[targetKey] = null;
            }
        }
        else { target[targetKey] = source[sourceKey]; }
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };


    var toContact = function (captureRecord) {

        if (debug) {
            console.log(debug + 'toContact:IN', captureRecord);
        }

        var nativeRecord = {};
        mapField(captureRecord, 'first', nativeRecord, 'firstName');
        mapField(captureRecord, 'last', nativeRecord, 'lastName');
        mapField(captureRecord, 'jobtitle', nativeRecord, 'title');
        mapField(captureRecord, 'company', nativeRecord, 'company');
        mapField(captureRecord, 'website', nativeRecord, 'website');
        mapField(captureRecord, 'email', nativeRecord, 'email');
        mapField(captureRecord, 'phone', nativeRecord, 'mainPhone');
        mapField(captureRecord, 'phone2', nativeRecord, 'phone');
        //mapField(captureRecord, 'bio', nativeRecord, 'Notes');
        mapField(captureRecord, 'address1', nativeRecord, 'address');
        mapField(captureRecord, 'city', nativeRecord, 'city');
        mapField(captureRecord, 'state', nativeRecord, 'state');
        mapField(captureRecord, 'zip', nativeRecord, 'postalCode');
        mapField(captureRecord, 'country', nativeRecord, 'country');
        mapField(captureRecord, 'linkedin', nativeRecord, 'linkedInProfileURL');
        mapField(captureRecord, 'facebook', nativeRecord, 'facebookProfileURL');
        mapField(captureRecord, 'twitter', nativeRecord, 'twitterProfileURL');

        if (debug) {
            console.log(debug + 'toContact:OUT', nativeRecord);
        }

        return nativeRecord;
    };

    var fromContact = function (nativeRecord) {


        if (debug) {
            console.log(debug + 'fromContact:IN', nativeRecord);
        }
        var captureRecord = {};
        captureRecord.venues = [{}, {}, {}];
        mapFromField(captureRecord, 'first', nativeRecord, 'firstName');
        mapFromField(captureRecord, 'last', nativeRecord, 'lastName');
        mapFromField(captureRecord, 'jobtitle', nativeRecord, 'title');
        mapFromField(captureRecord, 'company', nativeRecord, 'company');
        mapFromField(captureRecord, 'website', nativeRecord, 'website');
        mapFromField(captureRecord, 'email', nativeRecord, 'email');
        mapFromField(captureRecord, 'phone', nativeRecord, 'mainPhone');
        mapFromField(captureRecord, 'phone2', nativeRecord, 'phone');
        //mapFromField(captureRecord, 'bio', nativeRecord, 'Notes');
        mapFromField(captureRecord, 'address1', nativeRecord, 'address');
        mapFromField(captureRecord, 'city', nativeRecord, 'city');
        mapFromField(captureRecord, 'state', nativeRecord, 'state');
        mapFromField(captureRecord, 'zip', nativeRecord, 'postalCode');
        mapFromField(captureRecord, 'country', nativeRecord, 'country');
        mapFromField(captureRecord.venues[0], 'website', nativeRecord, 'linkedInProfileURL');
        mapFromField(captureRecord.venues[1], 'website', nativeRecord, 'facebookProfileURL');
        mapFromField(captureRecord.venues[2], 'website', nativeRecord, 'twitterProfileURL');
        //mapFromField(captureRecord, 'sourceurl', nativeRecord, 'LinkedIn');
        captureRecord._link = 'https://app-sjh.marketo.com/leadDatabase/loadLeadDetail?leadId=' + nativeRecord.id;
        captureRecord._type = 'Contact';
        captureRecord._id = nativeRecord.id;

        if (debug) {
            console.log(debug + 'fromContact:OUT', captureRecord);
        }

        return captureRecord;
    };

    /*
    Handles the expiration counter. Clears the access token in store when the expiration is up.
    */
    var currentTime = function () {
        var time = new Date();
        return time.getTime();
    };

    var expirationMarker = function (time, duration) {
        return time + (duration * 1000);
    };

    var checkExpiration = function () {
        return currentTime() < store.keyExpires;
    };

    var service = {


        /**
        * @function getName
        * @description Return name of export target.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        */
        getName: function () {
            return 'Marketo';
        },


        /**
        * @function init
        * @description Initializes store object. Sets user credentials, owner and team pipeline id.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {object} o - List of target-specific settings.
        */
        init: function (o) {

            if (debug) { console.log(debug + 'Initializing Credentials ...'); }
            console.log(o);
            store.username = o.username;
            store.password = o.password;
            store.marketoId = o.marketoId;

        },


        /**
        * @function login
        * @description Logs user in. Either silently (if possible) or interactively.
        * There is need to provide Username, Password, Database ID, API Key and App ID.
        * Follow 'http://www.marketo.net/apidocs_v2/ to see how to obtain the API key and App ID.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - This callback informs that user was logged in successfully. 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - This callback informs that user cannot log in.
        */
        login: function (successCallback, failCallback) {
            if (debug) { console.log(debug + 'Logging into Marketo...'); }

            var username = store.username;
            var password = store.password;
            var marketoId = store.marketoId;

            var url = buildUrl(store.marketoId, defaultUrl, '/identity/oauth/token?grant_type=client_credentials&client_id=' + username + '&client_secret=' + password);
            $http.get(url)
                    .success(function (data, status, headers, config) {
                        if (debug) { console.log(debug + 'MARKETO LOGIN SUCCESSFUL', data, status); }
                        store.authToken = data.access_token;
                        store.keyExpires = expirationMarker(currentTime(), data.expires_in);
                    })
                    .error(function (data, status, headers, config) {
                        console.log(debug + 'ERROR in GET', data, status, headers, config);
                        try { failCallback(); } catch (e) { }
                    });
        },

        /**
         * @function logout
         * @description Logs user out. Cleans up store variable.I
         * @memberOf captureApp.webServices.exportTargetVer1.marketo
         */
        logout: function () {

            //var urlBody = 'access-token?SessionId=' + store.authId + '&AppId=' + appId + '&ApiKey=' + apiKey;

            //var request = buildRequest('', function () { }, function () { });

            //request.url = buildUrl(defaultUrl, urlBody);
            //request.type = 'DELETE';
            //jQuery.ajax(request);
            store = {};
            if (debug) { console.log(debug + 'Logged out...'); }
        },


        /**
         * @function isLoggedIn
         * @description Checks if user is logged in.
         * @memberOf captureApp.webServices.exportTargetVer1.marketo
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInSuccessCallback} successCallback - This callback informs that user is currently logged in.
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInFailCallback} failCallback - This callback informs that user is not currently logged in.
         */
        isLoggedIn: function (successCallback, failCallback) {
            var isLogged = !!(store.authToken !== undefined && checkExpiration());

            if (debug) { console.log(debug + 'isLogged', isLogged); }

            if (!isLogged) {
                // Since we can do it... Do silent login.
                service.login(successCallback, failCallback);
            }
            else { try { successCallback(); } catch (e) { } }
        },


        /**
       * @function createRecord
       * @description Creates record.
       * @memberOf captureApp.webServices.exportTargetVer1.marketo
       * @param {recordType} recordType - Destination Record Type
       * @param {captureContact} captureRecord - Source Capture Record.
       * @param {object} createOptions - Options (For future use)
       * @param {captureApp.webServices.exportTargetVer1~createRecordSuccessCallback} successCallback 
       * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
       */
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {

            console.log(captureRecord.venues);

            if (debug) { console.log(debug + 'createRecord', captureRecord); }

            var createLead = function (nativeRecordType) {

                var input = {
                    'firstName': (captureRecord.first || ''),
                    'lastName': (captureRecord.last || ''),
                    'email': (captureRecord.email || ''),
                    'title': (captureRecord.jobtitle || ''),
                    'company': (captureRecord.company || ''),
                    'mainPhone': (captureRecord.phone || ''),
                    'phone': (captureRecord.phone2 || ''),
                    'website': (captureRecord.website || ''),
                    //'Notes': 'Created by Capture!' + '\n\n' + (captureRecord.bio || ''),
                    'address': (captureRecord.address1 || '') + '\n' + (captureRecord.address2 || ''),
                    'city': (captureRecord.city || ''),
                    'state': (captureRecord.state || ''),
                    'postalCode': (captureRecord.zip || ''),
                    'country': (captureRecord.country || ''),
                    'linkedInProfileURL': getVenue(captureRecord, 'linkedin.com'),
                    'facebookProfileURL': getVenue(captureRecord, 'facebook.com'),
                    'twitterProfileURL': getVenue(captureRecord, 'twitter.com')
                };

                console.log('THIS IS THE LINKEDIN RESULT');
                console.log(input.linkedInProfileURL);

                var record = {
                    'action': 'createOnly',
                    'lookupField': 'email',
                    'input': [input]
                };

                if (createOptions && createOptions.mappedProperties) {
                    var j = createOptions.mappedProperties.length;
                    while (j--)
                    { record[createOptions.mappedProperties[j].name] = createOptions.mappedProperties[j].value; }
                }

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var url = buildUrl(store.marketoId, defaultUrl, '/rest/v1/leads.json');

                var config = {
                    headers: {
                        'Authorization': 'Bearer ' + store.authToken
                    }
                };

                $http.post(url, record, config)
                    .success(function (data, status, headers, config) {
                        var id = data.result[0].id;
                        var link = 'https://app-sjh.marketo.com/leadDatabase/loadLeadDetail?leadId=' + id;
                        if (debug) { console.log(debug + 'response', data, status); }
                        if (id !== undefined) {
                            try { successCallback(link, id); } catch (e) { }
                        } else {
                            try { failCallback('Not Processed. ' + data.result[0].reasons[0].message + '.'); } catch (e) { }
                        }

                    })
                    .error(function (data, status, headers, config) {
                        console.log(debug + 'ERROR in POST', data, status, headers, config);
                        try { failCallback(); } catch (e) { }
                    });

            };


            if (recordType.toUpperCase() === 'CONTACT') {
                createLead('Contacts');
            } else {
                failCallback('Invalid record type');
            }

        },


        /**
        * @function updateRecord
        * @description Updates record.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {string} recordId - Record ID
        * @param {recordType} recordType - Record Type ('lead', 'contact' or 'account')
        * @param {object} record - Native record. Include only fields to be updated. 
        * @param {captureApp.webServices.exportTargetVer1~updateRecordSuccessCallback} successCallback 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
        */
        updateRecord: function (recordId, recordType, record, successCallback, failCallback) {

            if (debug) { console.log(debug + 'updateRecord', recordId, recordType, record); }

            var updateContact = function (nativeRecordType) {

                var info = {
                    'action': 'updateOnly',
                    'lookupField': 'email',
                    'input': [record]
                };

                var config = {
                    headers: {
                        'Authorization': 'Bearer ' + store.authToken
                    }
                };

                var url = buildUrl(store.marketoId, defaultUrl, '/rest/v1/leads.json');

                $http.post(url, info, config)
                    .success(function (data, status, headers, config) {
                        if (debug) { console.log(debug + 'response', data, status); }
                        try { successCallback(recordId); } catch (e) { }
                    })
                    .error(function (data, status, headers, config) {
                        if (debug) { console.log(debug + 'ERROR in Update', data, status, headers, config); }
                        try { failCallback(); } catch (e) { }
                    });

            };

            if (recordType.toUpperCase() === 'CONTACT') {
                updateContact('Contacts');
            } else {
                failCallback('Invalid record type');
            }

        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {
            if (debug) { console.log(debug + 'toLookupObject->entityType', entityType, '->crmObject', crmObject); }

            entityType = entityType.toLowerCase();
            var lookupObject = { label: '', link: '' };
            var appObject = null;
            //if (entityType === 'contact') { appObject = this.fromContact(crmObject); }
            //if (entityType === 'lead') {
            //    appObject = this.fromLead(crmObject);
            //}
            if (entityType === 'account') {
                var cityState = '';
                lookupObject.label = (crmObject.CompanyName || '(no name)') + cityState;
                lookupObject.link = 'https://pcr.com/?cid=' + crmObject.CompanyId; // Fake link. TODO: Make real link.
                lookupObject.id = crmObject.CompanyId;
            }
            //if (entityType === 'campaign') {
            //    lookupObject.label = (crmObject.Name || '(no name)');
            //    lookupObject.link = store.url + '/' + crmObject.Id;
            //    lookupObject.id = crmObject.Id;
            //}
            if (debug) { console.log(debug + 'toLookupObject->result', lookupObject); }
            return lookupObject;
        },

        /**
        * @function getRequiredLookups
        * @description Returns an array of lookups required prior to saving a record .
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {recordType} recordType - Record type 
        * @return {captureApp.webServices.exportTargetVer1~lookup[]}
        */
        getRequiredLookups: function (entityType, actualMap) {
            return;
        },

        resolveLookup: function (actionId, lookupId, objectId, successCallback, failCallback) {

            console.log(debug + 'resolveLookup->action->', actionId);
            console.log(debug + 'resolveLookup->lookup->', lookupId);
            console.log(debug + 'resolveLookup->object->', objectId);

            if (actionId === 'createNewAccount') {

                console.log('NEW ACCOUNT', lookupId);

                if (!lookupId.newName) {
                    // existing account, quit
                    try { successCallback(); } catch (e) { }
                    return;
                }

                var createSourceRecord = angular.copy(lookupId.record);
                createSourceRecord.company = lookupId.newName;

                service.createRecord('Account', createSourceRecord, null,

                    // created successfully
                    function (accountLink, accountId) {
                        console.log('account was created', accountLink, accountId);
                        var updateData = {};
                        updateData[lookupId.crmProperty] = accountId;
                        // update the new candidate
                        service.updateRecord(objectId, 'Contact', updateData, successCallback, failCallback);
                    },

                    // create failed
                    function (msg) {
                        console.log('account was not created', msg);
                        failCallback('Account was not created');
                    }

                );

            } else {

                console.log('ERROR: Unknown action', lookupId);
                failCallback('Unknown action');

            }

        },


        /**
        * @function getDefaultExportMaps
        * @description (Reserved for future use) Return an empty array. 
        * maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefaultExportMaps: function (successCallback, failureCallback) {

            var maps = [];

            //maps.push({ name: 'contact', label: 'Contact', map: null });

            successCallback(maps);
        },


        /**
        * @function getDefinition
        * @description Returns configuration for Multi-Merge dialog. 
        * How to modify:
        * 1. Put native field names in def.fields.map.{Field}.id
        * 2. Remove lines that do not have corresponding native fields, or where fields are read-only
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {string} recordType - 'lead', 'contact' or 'account'. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefinition: function (recordType, successCallback, failureCallback) {


            if (debug) { console.log(debug + 'getDefinition', recordType); }


            var def = {};
            recordType = recordType.toLowerCase();
            /*if (recordType === 'lead') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { display: 'First Name', group: 'G1' },
                            'LastName': { display: 'Last Name', group: 'G1' },
                            'Title': { display: 'Job Title', group: 'G1' },
                            'Company': { display: 'Company', group: 'G1' },
                            'Email': { display: 'Email', group: 'G1' },
                            'Phone': { display: 'Phone', group: 'G1' },
                            'MobilePhone': { display: 'Mobile Phone', group: 'G1' },
                            'Website': { display: 'Website', group: 'G1' },
                            'Description': { display: 'Description', group: 'G1' },

                            'Street': { display: 'Street', group: 'G2' },
                            'City': { display: 'City', group: 'G2' },
                            'State': { display: 'State/Province', group: 'G2' },
                            'PostalCode': { display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { display: 'Country', group: 'G2' },
                        }
                    }
                };

            } else*/ if (recordType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Linkedin', 'Facebook', 'Twitter'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Linkedin', 'Facebook', 'Twitter', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'firstName', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'lastName', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'title', display: 'Position', group: 'G1' },
                            'Company': { id: 'company', display: 'Company', group: 'G1' },
                            'Email': { id: 'email', display: 'Email', group: 'G1' },
                            'Phone': { id: 'mainPhone', display: 'Main Phone', group: 'G1' },
                            'MobilePhone': { id: 'phone', display: 'Secondary Phone', group: 'G1' },
                            'Website': { id: 'website', display: 'Website', group: 'G1' },
                            'Linkedin': { id: 'linkedin', display: 'Linkedin', group: 'G1' },
                            'Facebook': { id: 'facebook', display: 'Facebook', group: 'G1' },
                            'Twitter': { id: 'twitter', display: 'Twitter', group: 'G1' },
                            //'Description': { id: 'Notes', display: 'Comments', group: 'G1' },

                            'Street': { id: 'address', display: 'Address', group: 'G2' },
                            'City': { id: 'city', display: 'City', group: 'G2' },
                            'State': { id: 'state', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'postalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },


        /**
        * @function toNativeRecord
        * @description Converts Capture Contact to native record. 
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {captureContact} captureRecord - Capture Contact
        * @param {recordType} recordType - Record type. 
        * @return {object} - Native record
        */
        toNativeRecord: function (captureRecord, recordType) {
            recordType = recordType.toLowerCase();
            console.log('CAPTURE RECORD');
            console.log(captureRecord);
            if (recordType === 'contact') { return toContact(captureRecord); }
            return null;
        },


        /**
        * @function fromNativeRecord
        * @description Converts native record to Capture Contact. 
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {object} nativeRecord - Native record
        * @param {recordType} recordType - Record type. 
        * @return {captureContact} - Capture Contact
        */
        fromNativeRecord: function (nativeRecord, recordType) {
            recordType = recordType.toLowerCase();
            console.log(nativeRecord);
            if (recordType === 'contact') {
                console.log('RETURNING POSITIVE FROM NATIVE RECORD');
                return fromContact(nativeRecord.result[0]);
            }
            console.log('RETURNING NULL FROM NATIVE RECORD');
            return null;
        },


        /**
        * @function findDuplicates
        * @description Returns an array of duplicate records of given type.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {captureContact} recordType - Record type. 
        * @param {captureContact} captureRecord - Source Capture Contact. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the resulting array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback  
        * @return {captureContact[]} - Array of Capture Contacts
        */
        findDuplicates: function (recordType, captureRecord, successCallback, failCallback) {

            if (debug) { console.log(debug + 'findcoDuplicates', recordType, captureRecord); }


            var findContact = function () {

                if (debug) { console.log(debug + 'findContact', angular.copy(captureRecord)); }


                var successCallback2 = function (successResponse, textStatus, xhr) {


                    if (debug) { console.log(debug + 'response', successResponse); }

                    if (successResponse.errors && successResponse.errors.length > 0) {
                        try { failCallback(successResponse.errors[0].message); } catch (e) { }
                    }

                    var dups = [];
                    if (successResponse.result.length > 0) {
                        for (var i = 0; i < successResponse.result.length; i++) {
                            var dup;
                            dup = fromContact(successResponse.result[i]);
                            dups.push(dup);
                        }
                    }
                    if (debug) { console.log(debug + 'List Dups', dups); }
                    try { successCallback({ duplicates: dups }); } catch (e) { }
                };

                var buildRequest2 = function (method, filter, successCallback, failCallback) {
                    return {
                        type: 'GET',
                        url: buildUrl(store.marketoId, defaultUrl, '/rest/v1/leads.json') + filter,
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'Bearer ' + store.authToken);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            console.log('Duplicates Found');
                            console.log(successResponse);
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {

                            console.log(errorResponse);
                            var response = handleErrorMessageText(errorResponse);

                            failCallback(response, errorResponse.status || 500);
                        }
                    };

                };

                if (captureRecord.email) {

                    var emails = captureRecord.email;
                    if (captureRecord.email2) {
                        emails += ','+ captureRecord.email2;
                    }

                    var filter = '?filterType=email&filterValues=' + emails + '&fields=firstName,lastName,email,title,website,company,mainPhone,phone,address,city,state,postalCode,country,linkedInProfileURL,facebookProfileURL,twitterProfileURL';
                    if (debug) {
                        console.log(debug + 'filter', filter);
                    }
                    var request = buildRequest2(recordType, filter, successCallback2, failCallback);
                    jQuery.ajax(request);

                } else {
                    // no email = no dups 
                    try { successCallback({ duplicates: [] }); } catch (e) { }
                }

            };

            if (recordType.toUpperCase() === 'CONTACT') {
                recordType = 'Contacts';
                findContact();
            } else {
                try { successCallback({ duplicates: [] }); } catch (e) { }
            }

        },

        /*findDuplicates: function (recordType, contact, successCallback, failCallback) {

            var encode = function (s) {
                if (typeof s === 'undefined') { s = ''; }
                return s.replace(/'/g, '\\\'');
            };

            if (recordType === 'contact') { recordType = 'Contact'; }

            var fields = 'ID,LastName,FirstName,Email,Company,Phone,Title';
            if (recordType === 'Contact') { fields = 'ID,LastName,FirstName,Email,Title,Phone,Account.Name'; }

            var from = recordType;
            if (recordType === 'Contact')
            { from = 'Contact,Contact.Account'; }

            var where = '';

            var dups = [];

            var reponseHandle = null;
            var returnResponse = function() {
                try {
                    successCallback({ duplicates: dups });
                } catch (e) {}
            };

            var query = function (q) {
                var urlBody = 'candidates';

                try {

                    //calls Salesforce REST API with jQuery
                    jQuery.ajax({
                        type: 'GET',
                        url: buildUrl(defaultUrl, urlBody),
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                            xhr.setRequestHeader('Accept', 'application/json');
                        },
                        success: function (sfdata) {
                            console.log('findDuplicates results', sfdata);

                            if (!sfdata.records)
                            { try { failCallback(); } catch (e) { } }

                            
                            for (var i = 0; i < sfdata.records.length; i++) {
                                var dup = {};
                                if (recordType === 'Lead') { dup = service.fromLead(sfdata.records[i]); }
                                else if (recordType === 'Contact') { dup = service.fromContact(sfdata.records[i]); }
                                dups.push(dup);
                            }

                            if (reponseHandle) {
                                window.clearTimeout(reponseHandle);
                            }
                            reponseHandle = window.setTimeout(returnResponse, 2000);

                        },
                        failure: function (error) {
                            console.log('ERROR in findDuplicates', error);
                            try { failCallback(); } catch (e) { }
                        }
                    });

                } catch (e) {
                    console.log('ERROR in query', e.message);
                    try { failCallback(); } catch (e) { }
                }

            };

            if (recordType.toUpperCase() === 'CONTACT') {
                query('?query=FirstName eq ' + (captureRecord.first || '') + ' AND LastName eq ' + (captureRecord.last || ''));
            }

            //if (contact.phone && contact.last) {
            //    where = 'LastName=\'' + encode(contact.last) + '\'+AND+Phone=\'' + encode(contact.phone) + '\'';
            //    if (recordType === 'Lead')
            //    { where += '+AND+IsConverted=False'; }
            //    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
            //}

            //if (contact.email2) {
            //    where = 'Email=\'' + contact.email2 + '\'';
            //    if (recordType === 'Lead')
            //    { where += '+AND+IsConverted=False'; }
            //    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
            //}


        },*/



        findRecord: function (recordType, query, fields, successCallback, failCallback) {

            //var service = this;             
            var urlBody;
            var encodeParam = function (p) {
                return p.replace(/'/g, '%5C%27');
            };

            if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

            if (recordType === 'account') { recordType = 'Account'; }
            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            if (recordType === 'campaign') { recordType = 'Campaign'; }

            var where = [];

            if (query) {

                if (query.email)
                { where.push('Email=\'' + encodeParam(query.email) + '\''); }

                if (query.email_endsWith)
                { where.push('Email+LIKE+\'%25' + encodeParam(query.email_endsWith) + '\''); }

                if (query.last)
                { where.push('LastName=\'' + encodeParam(query.last) + '\''); }

                if (query.first)
                { where.push('FirstName=\'' + encodeParam(query.first) + '\''); }

                if (recordType === 'Account') {
                    if (query.company)
                    { where.push('Name+LIKE+\'%25' + encodeParam(query.company) + '%25\''); }
                }

                if (recordType === 'Campaign') {
                    if (query.campaign)
                    { where.push('Name+LIKE+\'%25' + encodeParam(query.campaign) + '%25\''); }
                }

            }
            var whereStr = where.join('+AND+');
            if (whereStr) { whereStr = '+WHERE+' + whereStr; } else { whereStr = '+'; }
            console.log(whereStr);

            var fieldsStr = '*';
            var f;

            if (recordType === 'Account') {
                urlBody = 'companies';
                f = [];

                f.push('ID');

                if (fields.indexOf('company') > -1) { f.push('Name'); }
                if (fields.indexOf('website') > -1) { f.push('Website'); }
                if (fields.indexOf('_createdDate') > -1) { f.push('CreatedDate'); }

                f.push('BillingCity');
                f.push('BillingState');

                fieldsStr = f.join(',');
            }

            if (recordType === 'Contact') {
                urlBody = 'candidates';
                f = [];

                f.push('ID');

                if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                if (fields.indexOf('last') > -1) { f.push('LastName'); }
                if (fields.indexOf('email') > -1) { f.push('Email'); }
                //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                fieldsStr = f.join(',');
            }

            if (recordType === 'Lead') {
                f = [];

                f.push('ID');

                if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                if (fields.indexOf('last') > -1) { f.push('LastName'); }
                if (fields.indexOf('email') > -1) { f.push('Email'); }
                //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                fieldsStr = f.join(',');
            }

            if (recordType === 'Campaign') {

                f = [];

                f.push('ID');
                f.push('Name');

                fieldsStr = f.join(',');
            }

            var headers = { 'Content-type': 'application/json', 'Authorization': 'BEARER ' + store.authId, 'Accept': 'application/json' };
            var config = {
                method: 'GET',
                url: buildUrl(defaultUrl, urlBody),
                headers: headers
            };
            if (debug) { console.log(debug + 'findRecord->config:', config); }

            var allRecords = [];

            var errorHandler = function (response, status) {

                if (debug) { console.log(debug + 'findRecord->failResponse', response); }
                var msg = '';
                if (response && response.length > 0) {

                    if (response[0].errorCode === 'INVALID_SESSION_ID') {
                        console.log(service);
                        service.logout();
                        failCallback('Session expired. Please log in.');
                    }

                    var i = 0;
                    while (i < response.length) {
                        if (response[i].message)
                        { msg += response[i].message + ' '; }
                        i++;
                    }
                }
                try { failCallback('Cannot find PCRecruiter record: (' + status + ') ' + (msg || response)); } catch (e) { }

            };

            var successHandler = function (response) {

                if (debug) { console.log(debug + 'findRecord->successResponse', response); }

                allRecords = allRecords.concat(response.Results);

                /*if (!response.done && response.nextRecordsUrl) {
                    config.url = store.url + response.nextRecordsUrl;
                    $http(config).success(successHandler).error(errorHandler);
                }
                else { try { successCallback(allRecords); } catch (e) { } }
                */
                try { successCallback(allRecords); } catch (e) { }
            };

            $http(config).success(successHandler).error(errorHandler);

        },

        /**
        * @function retrieveRecord
        * @description Returns single recor.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {string} recordId - Record ID 
        * @param {recordType} recordType - Record type
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the native record as a parameter
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - Return error message
        */
        retrieveRecord: function (recordId, recordType, successCallback, failCallback) {

            if (recordType.toLowerCase() === 'lead') { recordType = 'Leads'; }
            if (recordType.toLowerCase() === 'contact') { recordType = 'Contacts'; }

            var fields = 'id,firstName,lastName,email,website,title,company,mainPhone,phone,address,city,state,postalCode,country,linkedInProfileURL,facebookProfileURL,twitterProfileURL';

            var buildRequest2 = function (method, id, successCallback, failCallback) {
                console.log('Marketo Lead Id --> ' + id);
                if (debug) { console.log(debug + buildUrl(store.marketoId, defaultUrl, '/rest/v1/lead/' + id + '.json?fields=' + fields)); }
                return {
                    type: 'GET',
                    url: buildUrl(store.marketoId, defaultUrl, '/rest/v1/lead/' + id + '.json?fields=' + fields),
                    contentType: 'application/json',
                    crossDomain: true,
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader('Authorization', 'Bearer ' + store.authToken);
                    },
                    success: function (successResponse, textStatus, xhr) {
                        successCallback(successResponse, textStatus, xhr);
                    },
                    error: function (errorResponse) {
                        var response = handleErrorMessageText(errorResponse);
                        failCallback(response, errorResponse.status || 500);
                    }
                };
            };

            var successCallback2 = function (successResponse, textStatus, xhr) {

                if (debug) { console.log(debug + 'response', successResponse); }

                try { successCallback(successResponse); } catch (e) { }
            };

            var request = buildRequest2(recordType, recordId, successCallback2, failCallback);

            jQuery.ajax(request);
        },


        /*
        * Returns JSON with all Team Pipeline Clients. Function is supposed to help obtain value for OWNER_ID field.
        * E.g.: {
        *   "Stefan Smihla (stefan.smihla@pipelinersales)": 12345,
        *   "Example User (example@user.com)": 56789
        * }
        */
        getClients: function (successCallback, failCallback) {

            if (debug) { console.log(debug + 'getClients'); }

            var successFunc = function (successResponse) {
                var clients = {};
                for (var i in successResponse) {
                    var item = successResponse[i];
                    var firstname = item.FIRSTNAME || '';
                    var surname = item.LASTNAME || '';
                    var fullname = firstname + ' ' + surname + ' (' + item.EMAIL + ')';
                    clients[fullname] = item.ID;
                }
                //successCallback(JSON.stringify(clients));
                successCallback(clients);
            };

            service.getEntities('Clients', successFunc, failCallback);
        },

        /* Sets Sales Unit ID. This value will be needed fpr required SALES_UNIT_ID. */
        setSalesUnit: function (salesUnit) {
            store.salesUnit = salesUnit;
        },

        getEntities: function (nativeRecordType, successCallback, failCallback) {
            try {
                failCallback('Not implemented');
            } catch (e) {

            } 
            //if (debug) { console.log(debug + 'getEntities', nativeRecordType); }

            //var request = buildRequest(nativeRecordType, successCallback, failCallback);
            //request.success = successCallback;
            //jQuery.ajax(request);
        },

        /**
        * @function validateRecord
        * @description Validates if record can be exported. Returns list of errors.
        * @memberOf captureApp.webServices.exportTargetVer1.marketo
        * @param {recordType} recordType - Record type
        * @param {captureContact} captureRecord - Source Capture Contact. 
        */
        validateRecord: function (recordType, captureRecord) {

            var errors = [];

            if (!captureRecord) {
                errors.push('Record does not exist');
            } else {
                if (!captureRecord.email) {
                    errors.push('Email is required');
                }
            }

            return errors;
        }

    };

    return service;
}]);
/**
 * @class captureApp.webServices.dynamicsCrm
 * @memberOf captureApp.webServices
 * @description This is Microsoft Dynamics CRM AngularJS service.
 */

'use strict';

/* global angular: false */

angular.module('webServices')
.factory('dynamicsCrm', ['$http', '$q', function ($http, $q) {
    var debug = true;

    var store = {};

    var mapField = function (source, sourceKey, target, targetKey) {
        target[targetKey] = source[sourceKey];
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };

    var service = {

        /**
         * @function getName
         * @description Return name of export target.
         * @memberOf captureApp.webServices.dynamicsCrm
         */
        getName: function () {
            return 'Microsoft Dynamics CRM';
        },


        /**
         * @function init
         * @description Initializes store object.
         * @memberOf captureApp.webServices.dynamicsCrm
         * @param {object} o - List of target-specific settings.
         */
        init: function (o) {
            store.defaultUrl = o.url;
            if (store.defaultUrl && store.defaultUrl[store.defaultUrl.length - 1] !== '/') {
                store.defaultUrl += '/';
            }
        },


        /**
        * @function login
        * @description Logs user in. Either silently (if possible) or interactively.
        * @memberOf captureApp.webServices.dynamicsCrm
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - This callback informs that user was logged in successfully. 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - This callback informs that user cannot log in.
        */
        login: function (successCallback, failCallback, silent) {

            if (debug) {
                console.log('Logging into Dynamics CRM...', store.url);
            }

            if (store.url) {
                try { successCallback(); } catch (e) { }
            } else {

                if (silent) {
                    try { failCallback(); } catch (e) { }
                } else {
                    chrome.tabs.create({ url: store.url || store.defaultUrl || 'http://www.microsoft.com/en-us/dynamics/crm-login.aspx' }, function () { });
                }
            }
        },


        /**
         * @function logout
         * @description Logs user out. Cleans up store variable.
         * @memberOf captureApp.webServices.dynamicsCrm
         */
        logout: function () {
            store = {};
            if (debug) { console.log(debug + 'Logged out...'); }
        },


        /**
         * @function isLoggedIn
         * @description Checks if user is logged in.
         * @memberOf captureApp.webServices.dynamicsCrm
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInSuccessCallback} successCallback - This callback informs that user is currently logged in.
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInFailCallback} failCallback - This callback informs that user is not currently logged in.
         */
        isLoggedIn: function (successCallback, failCallback) {

            if (store.url) {
                if (debug) { console.log('store.url found', store.url); }
                try { successCallback(); } catch (e) { }
                return;
            }

            var checkUrl = function (url) {
                var found = false;
                if (url) {
                    if (store.defaultUrl) {
                        found = url.indexOf(store.defaultUrl) > -1;
                        if (found) {
                            store.url = store.defaultUrl;
                            console.log('STORE URL SET TO' + store.url);
                        }
                    }
                    else {
                        found = url.indexOf('https://') === 0 && url.indexOf('dynamics.com/') > 0;
                        if (found) {
                            store.url = url.substring(0, url.indexOf('dynamics.com/') + 13);
                            console.log('STORE URL SET TO' + store.url);
                        }
                    }
                }
                //console.log('tab.url', angular.copy(url), found, angular.copy(store.url));
                return found;
            };

            if (debug) { console.log('Looking for Dynamics CRM session...'); }
            var checkTabs = function (tabs) {
                if (!tabs || tabs.length === 0) {
                    try { failCallback(); } catch (e) { }
                    return;
                }

                var tab = tabs.pop();


                if (checkUrl(tab.url)) {
                    if (debug) { console.log('dynamics tab found', tab.url); }
                    try { successCallback(); } catch (e) { }
                    return;
                } else {
                    checkTabs(tabs);
                }
            };

            chrome.tabs.query({ windowId: chrome.windows.WINDOW_ID_CURRENT }, checkTabs);
        },

        //asyncIsLoggedIn: function () {
        //    var deferred = $q.defer();
        //    service.isLoggedIn(
        //        function () { deferred.resolve(true); },
        //        function (msg) { deferred.reject(msg); }
        //    );
        //    return deferred.promise;
        //},

        /**
         * @function getDefinition
         * @description Maps CRM record to multimerge candidate
         * @memberOf captureApp.webServices.dynamicsCrm
         * @param {captureApp.webServices.exportTargetVer1~getDeninitionSuccessCallback} successCallback
         * @param {captureApp.webServices.exportTargetVer1~failureCallback} failCallback
         */
        getDefinition: function (entityType, successCallback, failureCallback) {
            var def = {};
            entityType = entityType.toLowerCase();
            if (entityType === 'lead') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description',
                            'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'FirstName', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'LastName', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'JobTitle', display: 'Job Title', group: 'G1' },
                            'Company': { id: 'CompanyName', display: 'Company', group: 'G1' },
                            'Email': { id: 'EMailAddress1', display: 'Email', group: 'G1' },
                            'Phone': { id: 'Telephone1', display: 'Phone', group: 'G1' },
                            'MobilePhone': { id: 'Telephone2', display: 'Phone 2', group: 'G1' },
                            'Website': { id: 'WebSiteUrl', display: 'Website', group: 'G1' },
                            'Description': { id: 'Description', display: 'Description', group: 'G1' },

                            'Street': { id: 'Address1_Line1', display: 'Address1_Line1', group: 'G2' },
                            'City': { id: 'Address1_City', display: 'City', group: 'G2' },
                            'State': { id: 'Address1_StateOrProvince', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'Address1_PostalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Address1_Country', display: 'Country', group: 'G2' },
                        }
                    }
                };
            } else if (entityType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { id: 'G1', display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description'] },
                            'G2': { id: 'G2', display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description',
                            'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'FirstName', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'LastName', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'JobTitle', display: 'Job Title', group: 'G1' },
                            'Email': { id: 'EMailAddress1', display: 'Email', group: 'G1' },
                            'Phone': { id: 'Telephone1', display: 'Phone', group: 'G1' },
                            'MobilePhone': { id: 'Telephone2', display: 'Phone 2', group: 'G1' },
                            //'Website': { id: 'WebSiteUrl', display: 'Website', group: 'G1' },
                            'Description': { id: 'Description', display: 'Description', group: 'G1' },

                            'Street': { id: 'Address1_Line1', display: 'Street', group: 'G2' },
                            'City': { id: 'Address1_City', display: 'City', group: 'G2' },
                            'State': { id: 'Address1_StateOrProvince', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'Address1_PostalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Address1_Country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },

        //  From CRM lead to app contact
        fromLead: function (crmObject) {
            var contact = {};
            mapFromField(contact, 'first', crmObject, 'FirstName');
            //mapFromField(contact, 'middle', crmObject, 'MiddleName');
            mapFromField(contact, 'last', crmObject, 'LastName');
            mapFromField(contact, 'jobtitle', crmObject, 'JobTitle');
            mapFromField(contact, 'company', crmObject, 'CompanyName');
            mapFromField(contact, 'email', crmObject, 'EMailAddress1');
            mapFromField(contact, 'phone', crmObject, 'Telephone1');
            mapFromField(contact, 'phone2', crmObject, 'Telephone2');
            mapFromField(contact, 'website', crmObject, 'WebSiteUrl');
            mapFromField(contact, 'bio', crmObject, 'Description');
            mapFromField(contact, 'address1', crmObject, 'Address1_Line1');
            mapFromField(contact, 'city', crmObject, 'Address1_City');
            mapFromField(contact, 'state', crmObject, 'Address1_StateOrProvince');
            mapFromField(contact, 'zip', crmObject, 'Address1_PostalCode');
            mapFromField(contact, 'country', crmObject, 'Address1_Country');
            contact._link = store.url + 'main.aspx?etn=lead&id=' + String(crmObject.LeadId) + '&pagetype=entityrecord';
            contact._type = 'Lead';
            contact._id = crmObject.LeadId;
            return contact;
        },
        //  From app contact to CRM lead
        toLead: function (contact) {
            var crmObject = {};
            mapField(contact, 'first', crmObject, 'FirstName');
            //mapField(contact, 'middle', crmObject, 'MiddleName');
            mapField(contact, 'last', crmObject, 'LastName');
            mapField(contact, 'jobtitle', crmObject, 'JobTitle');
            mapField(contact, 'company', crmObject, 'CompanyName');
            mapField(contact, 'email', crmObject, 'EMailAddress1');
            mapField(contact, 'phone', crmObject, 'Telephone1');
            mapField(contact, 'phone2', crmObject, 'Telephone2');
            mapField(contact, 'website', crmObject, 'WebSiteUrl');
            mapField(contact, 'bio', crmObject, 'Description');
            mapField(contact, 'address1', crmObject, 'Address1_Line1');
            mapField(contact, 'city', crmObject, 'Address1_City');
            mapField(contact, 'state', crmObject, 'Address1_StateOrProvince');
            mapField(contact, 'zip', crmObject, 'Address1_PostalCode');
            mapField(contact, 'country', crmObject, 'Address1_Country');
            return crmObject;
        },
        //  From CRM contact to app contact
        fromContact: function (crmObject) {
            var contact = {};
            mapFromField(contact, 'first', crmObject, 'FirstName');
            mapFromField(contact, 'last', crmObject, 'LastName');
            mapFromField(contact, 'jobtitle', crmObject, 'JobTitle');
            mapFromField(contact, 'email', crmObject, 'EMailAddress1');
            mapFromField(contact, 'phone', crmObject, 'Telephone1');
            mapFromField(contact, 'phone2', crmObject, 'Telephone2');
            mapFromField(contact, 'bio', crmObject, 'Description');
            mapFromField(contact, 'address1', crmObject, 'Address1_Line1');
            mapFromField(contact, 'city', crmObject, 'Address1_City');
            mapFromField(contact, 'state', crmObject, 'Address1_StateOrProvince');
            mapFromField(contact, 'zip', crmObject, 'Address1_PostalCode');
            mapFromField(contact, 'country', crmObject, 'Address1_Country');
            contact._link = store.url + 'main.aspx?etn=contact&id=' + String(crmObject.ContactId) + '&pagetype=entityrecord';
            contact._type = 'Contact';
            contact._id = crmObject.ContactId;
            return contact;
        },
        //  from app contact to CRM contact
        toContact: function (contact) {
            var crmObject = {};
            mapField(contact, 'first', crmObject, 'FirstName');

            mapField(contact, 'last', crmObject, 'LastName');
            mapField(contact, 'jobtitle', crmObject, 'JobTitle');
            mapField(contact, 'email', crmObject, 'EMailAddress1');
            mapField(contact, 'phone', crmObject, 'Telephone1');
            mapField(contact, 'phone2', crmObject, 'Telephone2');
            mapField(contact, 'bio', crmObject, 'Description');
            mapField(contact, 'address1', crmObject, 'Address1_Line1');
            mapField(contact, 'city', crmObject, 'Address1_City');
            mapField(contact, 'state', crmObject, 'Address1_StateOrProvince');
            mapField(contact, 'zip', crmObject, 'Address1_PostalCode');
            mapField(contact, 'country', crmObject, 'Address1_Country');
            return crmObject;
        },
        fromAccount: function (crmObject) {
            var contact = {};
            //mapFromField(contact, 'first', crmObject, 'FirstName');
            //mapFromField(contact, 'last', crmObject, 'LastName');
            //mapFromField(contact, 'jobtitle', crmObject, 'JobTitle');
            mapFromField(contact, 'company', crmObject, 'Name');
            mapFromField(contact, 'email', crmObject, 'EMailAddress1');
            mapFromField(contact, 'phone', crmObject, 'Telephone1');
            mapFromField(contact, 'phone2', crmObject, 'Telephone2');
            mapFromField(contact, 'website', crmObject, 'WebSiteUrl');
            mapFromField(contact, 'bio', crmObject, 'Description');
            mapFromField(contact, 'address1', crmObject, 'Address1_Line1');
            mapFromField(contact, 'city', crmObject, 'Address1_City');
            mapFromField(contact, 'state', crmObject, 'Address1_StateOrProvince');
            mapFromField(contact, 'zip', crmObject, 'Address1_PostalCode');
            mapFromField(contact, 'country', crmObject, 'Address1_Country');
            contact._link = store.url + 'main.aspx?etn=account&id=' + String(crmObject.AccountId) + '&pagetype=entityrecord';
            contact._type = 'Account';
            contact._id = crmObject.AccountId;
            return contact;
        },
        //  From app contact to CRM object
        toNativeRecord: function (contact, entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') { return this.toContact(contact); }
            if (entityType === 'lead') { return this.toLead(contact); }
        },
        //  From CRM object to app contact
        fromNativeRecord: function (crmObject, entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') { return this.fromContact(crmObject); }
            if (entityType === 'lead') { return this.fromLead(crmObject); }
            if (entityType === 'account') { return this.fromAccount(crmObject); }
        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {
            entityType = entityType.toLowerCase();
            var lookupObject = { label: '', link: '' };
            var appObject = null;
            if (entityType === 'contact') { appObject = this.fromContact(crmObject); }
            if (entityType === 'lead') { appObject = this.fromLead(crmObject); }
            if (entityType === 'account') {
                appObject = this.fromAccount(crmObject);
                var cityState = '';
                if (appObject.city) { cityState = appObject.city; }
                if (appObject.state) {
                    if (cityState) { cityState = cityState + ', ' + appObject.state; }
                    else { cityState = appObject.state; }
                }
                if (cityState) { cityState = ' (' + cityState + ')'; }
                lookupObject.label = (appObject.company || '(no name)') + cityState;
                lookupObject.link = appObject._link;
                lookupObject.id = appObject._id;
            }
            if (entityType === 'systemuser') {
                lookupObject.label = crmObject.FullName;
                lookupObject.link = crmObject.__metadata.uri;
                lookupObject.id = crmObject.SystemUserId;
            }
            return lookupObject;
        },


        /**
       * @function getRequiredLookups
       * @description Returns an array of lookups required prior to saving a record .
       * @memberOf captureApp.webServices.dynamicsCrm
       * @param {string} entityType - 'lead', 'contact' or 'account'. 
       * @return {captureApp.webServices.exportTargetVer1~lookup[]}
       */
        getRequiredLookups: function (entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') {
                return [{ crmProperty: 'ParentCustomerId', appProperty: 'company', message: 'Select parent account', type: 'Account', required: false, allowNew: false }
                    //,
                    //    { crmProperty: 'OwnerId', appProperty: 'full', message: 'Select account owner', type: 'SystemUser', required: false, allowNew: false }
                ];
            }
            if (entityType === 'lead') { return []; }
            if (entityType === 'account') { return []; }

            return [];
        },

        //asyncGetDefinition: function (entityType) {
        //    var deferred = $q.defer();
        //    service.getDefinition(entityType,
        //        function (def) { deferred.resolve(def); },
        //        function (msg) { deferred.reject(msg); }
        //    );
        //    return deferred.promise;
        //},

        //-- CRUD --//
        //  Create a record with data provided
        //      successCallback: function(recordId)

        /**
       * @function createRecord
       * @description Creates record.
       * @memberOf captureApp.webServices.dynamicsCrm
       * @param {recordType} recordType - Destination Record Type
       * @param {captureContact} captureRecord - Source Capture Record.
       * @param {object} createOptions - Options (For future use) 
       * @param {captureApp.webServices.exportTargetVer1~createRecordSuccessCallback} successCallback
       * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
       */
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {
            var self = this;
            var record = {};
            recordType = recordType.toLowerCase();
            if (recordType === 'lead') {
                recordType = 'Lead';
                record = this.toLead(captureRecord);
            }
            if (recordType === 'contact') {
                recordType = 'Contact';
                record = this.toContact(captureRecord);
            }
            if (recordType === 'account') {
                recordType = 'Account';
                record = this.toAccount(captureRecord);
            }
            var headers = { 'Content-type': 'application/json; charset=utf-8', 'Accept': 'application/json' };
            var url = store.url + 'XRMServices/2011/OrganizationData.svc/' + recordType + 'Set';


            var config = { method: 'POST', url: url, data: record, headers: headers };
            console.log('dynamics.createRecord...', config, store);
            $http(config).success(function (response) {
                if (debug) { console.log('dynamics.createRecord:', response); }
                var newRecord = { _link: null };
                if (recordType === 'Lead') { newRecord = self.fromLead(response.d); }
                if (recordType === 'Contact') { newRecord = self.fromContact(response.d); }
                try { successCallback(newRecord._link, newRecord._id); } catch (e) { }
            }).error(function (response, status) {
                if (debug) { console.log('dynamics.createRecord:', response); }
                try { failCallback('Cannot create Dynamics record: (' + status + ') ' + response); } catch (e) { }
            });
        },

        //  Update an existing record with data
        //      successCallback: function(recordId)

        /**
      * @function updateRecord
      * @description Updates record.
      * @memberOf captureApp.webServices.dynamicsCrm
      * @param {string} recordId - Record ID. 
      * @param {string} recordType - Record Type. 
      * @param {captureApp.webServices.exportTargetVer1~createRecordParameters} data - Data. 
      * @param {captureApp.webServices.exportTargetVer1~updateRecordSuccessCallback} successCallback 
      * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
      */
        updateRecord: function (recordId, recordType, data, successCallback, failCallback) {
            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            var headers = { 'Content-type': 'application/json; charset=utf-8', 'Accept': 'application/json', 'X-HTTP-Method': 'MERGE' };
            var url = store.url + 'XRMServices/2011/OrganizationData.svc/' + recordType + 'Set' + '(guid\'' + recordId + '\')';
            var config = { method: 'POST', url: url, data: data, headers: headers };
            console.log('dynamics.updateRecord...', config);
            $http(config).success(function (response) {
                if (debug) { console.log('dynamics.updateRecord:', response); }
                try {
                    var id = null;
                    if (response && response.d) {
                        if (recordType === 'Lead') { id = response.d.LeadId; }
                        if (recordType === 'Contact') { id = response.d.ContactId; }
                        if (recordType === 'Account') { id = response.d.AccountId; }
                    }
                    successCallback(id);
                } catch (e) { }
            }).error(function (response, status) {
                if (debug) { console.log('dynamics.updateRecord:', response); }
                try { failCallback('Cannot update Dynamics record: (' + status + ') ' + response); } catch (e) { }
            });
        },

        //  Retrieve record from service
        //      successCallback: function(recordId, data)
        retrieveRecord: function (recordId, recordType, successCallback, failCallback) {
            var self = this;

            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            if (recordType === 'account') { recordType = 'Account'; }

            var headers = { 'Content-type': 'application/json; charset=utf-8', 'Accept': 'application/json' };
            var url = store.url + 'XRMServices/2011/OrganizationData.svc/' + recordType + 'Set(guid\'' + recordId + '\')';
            var config = { method: 'GET', url: url, headers: headers };
            console.log('dynamics.retrieveRecord...', config, store);
            $http(config).success(function (response) {
                if (debug) { console.log('dynamics.retrieveRecord:', response); }

                if (!response.d)
                { try { failCallback(); } catch (e) { } }

                try { successCallback(response.d); } catch (e) { }
            }).error(function (response, status) {
                if (debug) { console.log('dynamics.retrieveRecord:', response); }
                try { failCallback('Cannot retrieve Dynamics record: (' + status + ') ' + response); } catch (e) { } //.error.message.value
            });
        },

        //asyncRetrieveRecord: function (recordId, recordType) {
        //    var deferred = $q.defer();
        //    service.retrieveRecord(recordId, recordType,
        //        function (response) { deferred.resolve(response); },
        //        function (msg) { deferred.reject(msg); }
        //    );
        //    return deferred.promise;
        //},

        //  Delete record from service
        //      successCallback: function(recordId)
        //deleteRecord: function (recordId, successCallback, failCallback) {
        //},
        //-- /CRUD --//


        //-- Search --//
        //  Find records using a query: { first:'', last:'', email:''} object
        //      recordType: string
        //      query: object
        //      fields: array of app contact property names
        //      successCallback: function(arrayOfNativeRecords)
        findRecord: function (recordType, query, fields, successCallback, failCallback) {

            if (recordType === 'account') { recordType = 'Account'; }
            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }

            //try { failCallback('Not implemented'); } catch (e) { }

            var where = [];

            if (query) {

                if (recordType === 'Account') {

                    if (query.company)
                    { where.push('substringof(\'' + encodeURIComponent(query.company.replace(/'/g, '\'\'')) + '\',Name)'); }

                    if (query.email)
                    { where.push('substringof(\'' + encodeURIComponent(query.email.replace(/'/g, '\'\'')) + '\',EMailAddress1)'); }

                }
                else {

                    if (query.email)
                    { where.push('EMailAddress1=\'' + query.email + '\''); }

                    if (query.last)
                    { where.push('LastName=\'' + query.last + '\''); }

                    if (query.first)
                    { where.push('FirstName=\'' + query.first + '\''); }
                }

            }

            var whereStr = '';

            if (where.length > 0)
            { whereStr = '$filter=' + where.join(' and '); }

            console.log(whereStr);

            var fieldStr = '';

            if (recordType === 'Account')
            { fieldStr = '$select=Name,AccountId,Address1_StateOrProvince,Address1_City'; }
            else if (recordType === 'SystemUser')
            { fieldStr = '$select=FullName,SystemUserId'; }

            var headers = { 'Content-type': 'application/json; charset=utf-8', 'Accept': 'application/json' };
            var url = store.url + 'XRMServices/2011/OrganizationData.svc/' + recordType + 'Set/' + ((whereStr || fieldStr) ? '?' : '') + whereStr + (whereStr ? '&' : '') + fieldStr;
            var config = { method: 'GET', url: url, headers: headers };
            console.log('dynamics.retrieveRecord...', config, store);
            $http(config).success(function (response) {
                if (debug) { console.log('dynamics.retrieveRecord:', response); }

                if (!response.d)
                { try { failCallback(); } catch (e) { } }

                try { successCallback(response.d.results); } catch (e) { }
            }).error(function (response, status) {
                if (debug) { console.log('dynamics.retrieveRecord:', response); }
                try { failCallback('Cannot retrieve Dynamics record: (' + status + ') ' + response); } catch (e) { } //.error.message.value
            });

        },
        //-- /Search --//

        //-- Define --//
        //  Get a list of all available entities (lead, contact, account, etc)
        //      successCallback: function(entityList)
        listEntities: function (successCallback, failCallback) {
        },

        //  Get the definition for an entity (field names of a lead or contact)
        //      successCallback: function(entityDefinition)
        defineEntity: function (entity, successCallback, failCallback) {
        },
        //-- /Define --//



        /**
       * @function findDuplicates
       * @description Returns an array of duplicate records of given type.
       * 
       * @memberOf captureApp.webServices.dynamicsCrm
       * @param {string} recordType - 'lead', 'contact' or 'account'. 
       * @param {captureContact} contact - Capture contact. 
       * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the resulting array
       * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback  
       * @return {object[]}
       */
        findDuplicates: function (recordType, contact, successCallback, failCallback) {

            var self = this;

            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }

            var dups = [];

            var reponseHandle = null;
            var returnResponse = function () {
                try {
                    if (debug) { console.log(debug + 'dups (final)', angular.copy(dups)); }

                    successCallback({ duplicates: dups });
                } catch (e) { }
            };

            var findRecords = function (recordType, where) {

                var headers = { 'Content-type': 'application/json; charset=utf-8', 'Accept': 'application/json' };
                var url = store.url + 'XRMServices/2011/OrganizationData.svc/' + recordType + 'Set?$filter=' + where;
                var config = { method: 'GET', url: url, headers: headers };
                console.log('dynamics.findDuplicates...', config, store);
                $http(config).success(function (response) {
                    if (debug) { console.log('dynamics.findDuplicates:', response); }

                    if (!response.d.results) { try { failCallback(); } catch (e) { } }


                    for (var i = 0; i < response.d.results.length; i++) {
                        var dup = {};
                        if (recordType === 'Lead') { dup = self.fromLead(response.d.results[i]); }
                        else if (recordType === 'Contact') { dup = self.fromContact(response.d.results[i]); }
                        dups.push(dup);
                    }

                    //try { successCallback({ duplicates: dups }); } catch (e) { }

                    if (reponseHandle) {
                        window.clearTimeout(reponseHandle);
                    }
                    reponseHandle = window.setTimeout(returnResponse, 2000);

                }).error(function (response, status) {
                    if (debug) { console.log('dynamics.findDuplicates:', response); }
                    try { failCallback('Cannot find duplicate Dynamics record: (' + status + ') ' + response.error.message.value); } catch (e) { }
                });

            };

            var where = '';

            if (contact.email) {
                where = 'EMailAddress1 eq \'' + encodeURIComponent(contact.email) + '\'';
                if (contact.email2) {
                    where = '(' + where + ')+or+(EMailAddress1 eq \'' + encodeURIComponent(contact.email2) + '\')';
                }
                findRecords(recordType, where);
            }


            if (contact.last) {
                where = '(LastName eq \'' + encodeURIComponent(contact.last) + '\')+and+(FirstName eq \'' + encodeURIComponent(contact.first) + '\')';
                findRecords(recordType, where);
            }


        }
    };
    return service;
}]);
/**
 * @class captureApp.webServices.jobscience
 * @memberOf captureApp.webServices.exportTargetVer2
 * @description This is Job Science AngularJS service.
 */

'use strict';

/* global angular: false */
/* global jQuery: false */
/* global geographyData: false */
/* global backgroundUtility: false */


angular.module('webServices')//exportService 
//angular.module('exportService')
//.factory('jobscience', ['$http', '$q', '$timeout', 'endpoints', 'dialogs', function ($http, $q, $timeout, endpoints, dialogs) {
.factory('jobscience', ['$http', '$q', '$timeout', 'dialogs', function ($http, $q, $timeout, dialogs) {
    var debug = 'jobscience.js->';
    const consolePrefix = 'Job Science > ';
    var store = { cache: {} };
    var invalidSessions = {};
    var enteredValues = {};

    var mapField = function (source, sourceKey, target, targetKey) {
        var sourceKeyParts = sourceKey.split('.');
        if (sourceKeyParts.length === 2) {
            try {
                target[targetKey] = source[sourceKeyParts[0]][sourceKeyParts[1]];
            } catch (e) {
                target[targetKey] = null;
            }
        }
        else { target[targetKey] = source[sourceKey]; }
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };
    var initStore = function (session, url) {
        const functionName = 'Init Store';
        try {
            store = { cache: {} };
            if (session && url) {
                store.id = session;
                store.url = url;
                store.ts = new Date();
            }
            if (debug) { console.log(consolePrefix + functionName, angular.copy(store)); }
        } catch (e) {
            console.error(functionName, e.message);
        }
    };

    var defaultOnSuccessHandler = function (data, status, headers, config, successCallback, failureCallback) {

        if (!data) {
            var message = 'Job Science API call failed';

            //Read header: Sforce-Limit-Info: api-usage=50035/48000
            var apiUsage = headers('Sforce-Limit-Info');
            if (apiUsage) {
                message += ': ' + apiUsage;
            }

            failureCallback(message);

            return;
        }

        successCallback(data);
    };

    var defaultOnErrorHandler = function (errorResponse, status, failureCallback) {
        const functionName = 'On Error';
        try {
            console.error(consolePrefix + functionName + ' > Status > ', status, ' > Response > ', angular.copy(errorResponse));

            if (errorResponse) {
                if (errorResponse.responseJSON && errorResponse.responseJSON.length > 0 && errorResponse.responseJSON[0].message) {
                    failureCallback(errorResponse.responseJSON[0].message);
                }
                else if (errorResponse.statusText) {
                    failureCallback(errorResponse.statusText);
                }
                else if (errorResponse.length > 0) {

                    var errorCode = errorResponse[0].errorCode;

                    if (errorCode === 'INVALID_SESSION_ID') {
                        service.logout(true);
                        failureCallback('Session expired. Please log in.');
                    }
                }
                else { failureCallback(errorResponse); }
            }
            else { failureCallback('Job Science API Error'); }

        } catch (e) {
            console.error(functionName + ' > On Error > ', e.message);
            failureCallback('Job Science API Exception');
        }

    };

    var checkSession = function () {

        if (!store || typeof store.url === 'undefined') {
            console.error('Session Not initialized > ', angular.copy(store));
            throw { message: 'Session expired. Please log in.' };
        }

    };

    var service = {

        getName: function () {
            return 'Job Science';
        },

        getInterfaceVersion: function () {
            return 2;
        },

        /**
        * @function init
        * @description Initializes store object. Not used for Job Science.
        * @memberOf captureApp.webServices.exportTargetVer1.jobscience
        * @param {object} settings - List of target-specific settings.
        */
        init: function (settings) {
            if (settings) {
                if (settings.Session && settings.Url) {
                    initStore(settings.Session, settings.Url);
                }
            }
        },

        //  Log us in
        login: function (successCallback, failCallback, silent) {
            const functionName = 'Is Logged In';
            try {
                if (debug) { console.log('Logging into jobscience... silent=', silent); }
                //chrome.tabs.create({ url: 'https://na1.salesforce.com/001/o' }, function () { });

                if (debug) { console.log(debug + 'Looking for jobscience session...'); }
                var checkTabs = function (tabs) {
                    if (!tabs || tabs.length === 0) {
                        if (debug) { console.log(debug + 'jobscience tab not found'); }
                        if (silent) {
                            try { failCallback(); } catch (e) { }
                        }
                        else {
                            chrome.tabs.create({ url: 'https://login.salesforce.com' }, function () { });
                            //chrome.tabs.create({ url: 'https://na1.salesforce.com/001/o' }, function () { });
                        }
                        return;
                    }

                    var tab = tabs.pop();
                    //if (tab.url && tab.url.indexOf('https://') === 0 && tab.url.indexOf('salesforce.com/') > 0) {
                    if (tab.url && tab.url.indexOf('https://') === 0 && (tab.url.indexOf('.salesforce.com/') > 0 || tab.url.indexOf('.visual.force.com/') > 0)) {
                        if (debug) { console.log(functionName + ' > Job Science tab found > ', tab.url); }
                        var url;
                        if (tab.url.indexOf('.visual.force.com/') > 0) {
                            url = tab.url.substring(0, tab.url.indexOf('.visual.force.com/'));// + 'visual.force.com'; // no ending "/"
                            var parts = url.split('.');
                            url = 'https://' + parts[parts.length - 1] + '.salesforce.com';
                        }
                        else {
                            url = tab.url.substring(0, tab.url.indexOf('.salesforce.com/') + 15); // no ending "/"
                        }

                        //if (debug) { console.log(debug + 'salesforce tab found, querying for session id', tab.url); }

                        chrome.cookies.getAll({ 'url': tab.url }, function (cookies) {
                            for (var i = 0; i < cookies.length; i++) {
                                try {
                                    var cookie = cookies[i];
                                    if (cookie.name === 'sid' && invalidSessions[cookie.value] !== true) {
                                        var session = cookie.value;
                                        //var url = tab.url.substring(0, tab.url.indexOf('salesforce.com/') + 14);// no ending "/"
                                        initStore(session, url);
                                        if (debug) { console.log(debug + 'store.ts:', store.ts); }
                                        try { successCallback(); } catch (e) { }
                                        return;
                                    }
                                } catch (e) {
                                    console.log('ERROR in cookie', e.message);
                                }
                            }
                            checkTabs(tabs);
                        });

                    } else {
                        checkTabs(tabs);
                    }
                };

                //chrome.tabs.query({ windowId: chrome.windows.WINDOW_ID_CURRENT }, checkTabs);
                chrome.tabs.query({}, checkTabs);
            } catch (e) {
                console.error(functionName, e.message);
                failCallback(e.message);
            }
        },

        logout: function (expireSession) {
            console.log('logout. expire? ', expireSession);
            if (expireSession && store.id) {
                invalidSessions[store.id] = true;
            }
            initStore();
        },

        //  Get login info
        isLoggedIn: function (successCallback, failCallback) {
            const functionName = 'Is Logged In';
            try {
                if (store.id) {
                    if (debug) { console.log(debug + 'store.ts:', store.ts); }

                    if (store.ts) {
                        try {
                            var daysOld = (new Date().getTime() - store.ts.getTime()) / (1000 * 60 * 60 * 24);
                            if (debug) { console.log(debug + 'daysOld:', daysOld); }
                            if (daysOld < 1) {
                                try { successCallback(); } catch (e) { }
                                return;
                            } else {
                                // force expire
                                initStore();
                            }
                        } catch (e) {
                            console.log('*** ERROR in SF daysOld', e.message);
                        }
                    }

                }
                if (debug) { console.log(debug + 'Looking for jobscience session...'); }
                var checkTabs = function (tabs) {
                    if (!tabs || tabs.length === 0) {
                        if (debug) { console.log(debug + 'jobscience tab not found'); }
                        try { failCallback(); } catch (e) { }
                        return;
                    }

                    var tab = tabs.pop();
                    //if (debug) { console.log(debug + 'tab', tab.url, angular.copy(tabs)); }
                    //if (tab.url && tab.url.indexOf('https://') === 0 && tab.url.indexOf('salesforce.com/') > 0) {

                    //    if (debug) { console.log(debug + 'salesforce tab found, querying for session id', tab.url); }

                    if (tab.url && tab.url.indexOf('https://') === 0 && (tab.url.indexOf('.salesforce.com/') > 0 || tab.url.indexOf('.visual.force.com/') > 0)) {
                        if (debug) { console.log(functionName + ' > Job Science tab found > ', tab.url); }
                        var url;
                        if (tab.url.indexOf('.visual.force.com/') > 0) {
                            url = tab.url.substring(0, tab.url.indexOf('.visual.force.com/'));// + 'visual.force.com'; // no ending "/"
                            var parts = url.split('.');
                            url = 'https://' + parts[parts.length - 1] + '.salesforce.com';
                        }
                        else {
                            url = tab.url.substring(0, tab.url.indexOf('.salesforce.com/') + 15); // no ending "/"
                        }

                        chrome.cookies.getAll({ 'url': tab.url },

                            function (cookies) {
                                //console.log('cookies', cookies);
                                for (var i = 0; i < cookies.length; i++) {
                                    try {
                                        var cookie = cookies[i];
                                        if (cookie.name === 'sid') {
                                            var session = cookie.value;
                                            //var url = tab.url.substring(0, tab.url.indexOf('salesforce.com/') + 14); // no ending "/"
                                            initStore(session, url);
                                            if (debug) { console.log(debug + 'store.ts:', store.ts); }
                                            try { successCallback(); } catch (e) { }
                                            return;
                                        }
                                    } catch (e) {
                                        console.log('ERROR in cookie', e.message);
                                    }
                                }
                                if (debug) { console.log(debug + 'WARNING: Cookie not found'); }
                                checkTabs(tabs);
                            }

                        );

                    } else {
                        checkTabs(tabs);
                    }
                };

                chrome.tabs.query({}, checkTabs);

            } catch (e) {
                console.error(functionName, e.message);
                failCallback(e.message);
            }
        },

        asyncIsLoggedIn: function () {

            console.log('CHECKING IF ASYNC LOGGED IN');

            var deferred = $q.defer();
            service.isLoggedIn(
                function () { deferred.resolve(true); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        getEntities: function (successCallback, failureCallback) {
            const functionName = 'Get Entities';
            try {
                if (debug) { console.log(consolePrefix + functionName); }
                //successCallback([{ name: 'Lead', type: 'lead' }]);

                checkSession();

                //if (typeof store.url === 'undefined') {
                //    console.error(functionName + ' > Not initialized > ', store);
                //    try { failureCallback('Session expired. Please log in.'); } catch (e) { }
                //    return;
                //}

                //// Use cached values
                //if (store.cache.entities) {
                //    var list = angular.copy(store.cache.entities);
                //    console.log(consolePrefix + functionName + ' > Read from cache > ', list);
                //    successCallback(list);
                //    return;
                //}

                var config = {
                    method: 'GET',
                    url: store.url + '/services/data/v34.0/sobjects',
                    headers: { 'Authorization': 'OAuth ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' }
                };
                if (debug) { console.log(consolePrefix + functionName + ' > Request > ', config); }

                $http(config).success(function (data, status, headers, config) {

                    var onTrueSuccess = function (data) {
                        try {

                            var list = [];
                            angular.forEach(data.sobjects, function (sobject, index) {
                                list.push({ name: sobject.name, label: sobject.label });
                            });

                            // Cache 
                            store.cache.entities = angular.copy(list);

                            successCallback(list);

                        } catch (e) {
                            console.error(functionName + ' > On True Success > ', e.message);
                            failureCallback('Job Science API response is invalid');
                        }
                    };

                    defaultOnSuccessHandler(data, status, headers, config, onTrueSuccess, failureCallback);
                }

                ).error(function (data, status) {
                    defaultOnErrorHandler(data, status, failureCallback);
                });

            } catch (e) {
                console.error(functionName, e.message);
                failureCallback(e.message);
            }

        },

        // successCallback: function(fields)
        // fields: [ {name: '', label: '' } ]
        getFields: function (entityType, successCallback, failureCallback) {
            if (entityType === 'candidate') {
                entityType = 'contact';
            }
            const functionName = 'Get Fields';
            try {
                if (debug) { console.log(consolePrefix + functionName + ' > Type > ', entityType); }

                var config = {
                    method: 'GET',
                    url: store.url + '/services/data/v34.0/sobjects/' + entityType + '/describe',
                    headers: { 'Authorization': 'OAuth ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' }
                };
                if (debug) { console.log(consolePrefix + functionName + ' > Request > ', config); }

                $http(config).success(function (data, status, headers, config) {

                    var onTrueSuccess = function (data) {
                        try {

                            var list = [];
                            angular.forEach(data.fields, function (field, index) {

                                if (!field.updateable) { return; }

                                var values = [];
                                if (field.picklistValues) {
                                    angular.forEach(field.picklistValues, function (picklistValue) {
                                        values.push({ value: picklistValue.value, label: picklistValue.label });
                                    });
                                }

                                var f = { name: field.name, label: field.label, length: field.length };

                                f.required = !field.nillable && field.updateable;

                                if (values.length > 0) {
                                    f.values = values;
                                }

                                list.push(f);

                            });

                            //store.cache['fields:' + entityType] = angular.copy(list);

                            successCallback(list);

                        } catch (e) {
                            console.error(functionName + ' > On True Success > ', e.message);
                            failureCallback('Job Science API response is invalid');
                        }
                    };

                    defaultOnSuccessHandler(data, status, headers, config, onTrueSuccess, failureCallback);
                }

                ).error(function (data, status) {
                    defaultOnErrorHandler(data, status, failureCallback);
                });

                //jQuery.ajax({
                //    type: 'GET',
                //    url: url,
                //    contentType: 'application/json',
                //    beforeSend: function (xhr) {
                //        xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
                //        xhr.setRequestHeader('Accept', 'application/json');
                //    },
                //    success: function (successResponse) {

                //        console.log('successResponse=', successResponse);

                //        if (!successResponse) {
                //            console.error('null response!');
                //            failureCallback('Cannot get Job Science object description');
                //            return;
                //        }

                //        var ff = [];
                //        angular.forEach(successResponse.fields, function (field, index) {

                //            //var def = null;
                //            var vv = [];
                //            if (field.picklistValues) {
                //                angular.forEach(field.picklistValues, function (pv, pvi) {
                //                    vv.push({ value: pv.value, label: pv.label });
                //                    //if()
                //                    //default: value.default
                //                });
                //            }

                //            if (field.updateable) {
                //                var f = { name: field.name, label: field.label, length: field.length };

                //                f.required = !field.nillable && field.updateable;

                //                if (vv.length > 0) {
                //                    f.values = vv;
                //                }

                //                ff.push(f);
                //            }
                //        });

                //        successCallback(ff);
                //    },
                //    error: function (errorResponse) {

                //        console.error('errorResponse=', errorResponse);
                //        failureCallback(errorResponse);
                //    }

                //});
            } catch (e) {
                console.error(functionName, e.message);
                failureCallback(e.message);
            }
        },

        // successCallback: function(maps)
        // maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        getDefaultExportMaps: function (successCallback, failureCallback) {

            console.log('GETTING DEFAULT EXPORT MAPS');

            var defaultCaptureMap = {
                fields: [
                    { captureField: 'first', label: 'First Name', crmField: null },
                    { captureField: 'last', label: 'Last Name', crmField: null },
                    { captureField: 'jobtitle', label: 'Job Title', crmField: null },
                    { captureField: 'company', label: 'Company Name', crmField: null },
                    { captureField: 'email', label: 'Email', crmField: null },
                    { captureField: 'phone', label: 'Phone', crmField: null },
                    { captureField: 'phone2', label: 'Phone 2', crmField: null },
                    { captureField: 'website', label: 'Website', crmField: null },
                    { captureField: 'bio', label: 'Bio', crmField: null },
                    { captureField: 'address1', label: 'Address Line 1', crmField: null },
                    { captureField: 'address2', label: 'Address Line 2', crmField: null },
                    { captureField: 'city', label: 'City', crmField: null },
                    { captureField: 'state', label: 'State', crmField: null },
                    { captureField: 'zip', label: 'Zip Code', crmField: null },
                    { captureField: 'country', label: 'Country', crmField: null },
                ]
            };

            //var contactMap = {
            //    fields: [
            //        { captureField: 'first', label: 'First Name',  crmField: { name: 'FirstName', label: 'First Name' } },
            //        { captureField: 'last', label: 'Last Name', crmField: { name: 'LastName', label: 'Last Name' } },
            //        { captureField: 'jobtitle', label: 'Job Title', crmField: { name: 'Title', label: 'Title' } },
            //        { captureField: 'company', label: 'Company Name', crmField: { name: 'Account.Name', label: 'Account Name' } },
            //        { captureField: 'email', label: 'Email', crmField: { name: 'Email', label: 'Email' } },
            //        { captureField: 'phone', label: 'Phone', crmField: { name: 'Phone', label: 'Phone' } },
            //        { captureField: 'phone2', label: 'Phone 2', crmField: { name: 'MobilePhone', label: 'Mobile Phone' } },
            //        { captureField: 'website', label: 'Website', crmField: null },
            //        { captureField: 'bio', label: 'Bio', crmField: { name: 'Description', label: 'Description' } },
            //        { captureField: 'address1', label: 'Address Line 1', crmField: { name: 'MailingStreet', label: 'Mailing Street' } },
            //        { captureField: 'address2', label: 'Address Line 2', crmField: null },
            //        { captureField: 'city', label: 'City', crmField: { name: 'MailingCity', label: 'Mailing City' } },
            //        { captureField: 'state', label: 'State', crmField: { name: 'MailingState', label: 'Mailing State' } },
            //        { captureField: 'zip', label: 'Zip Code', crmField: { name: 'MailingPostalCode', label: 'Mailing Postal Code' } },
            //        { captureField: 'country', label: 'Country', crmField: { name: 'MailingCountry', label: 'Mailing Country' } },
            //    ]
            //};

            var contactMap = {
                fields: [
                    { target: { name: 'FirstName', label: 'First Name' }, source: { type: 'capture', value: { captureField: 'first', label: 'First Name' } } },
                    { target: { name: 'LastName', label: 'Last Name' }, source: { type: 'capture', value: { captureField: 'last', label: 'Last Name' } } },
                    { target: { name: 'Title', label: 'Title' }, source: { type: 'capture', value: { captureField: 'jobtitle', label: 'Job Title' } } },
                    { target: { name: 'Company', label: 'Company' }, source: { type: 'capture', value: { captureField: 'company', label: 'Company Name' } } },
                    { target: { name: 'Email', label: 'Email' }, source: { type: 'capture', value: { captureField: 'email', label: 'Email' } } },
                    { target: { name: 'Phone', label: 'Phone' }, source: { type: 'capture', value: { captureField: 'phone', label: 'Phone' } } },
                    { target: { name: 'MobilePhone', label: 'Mobile Phone' }, source: { type: 'capture', value: { captureField: 'phone2', label: 'Phone 2' } } },
                    { target: { name: 'Description', label: 'Description' }, source: { type: 'capture', value: { captureField: 'bio', label: 'Bio' } } },
                    { target: { name: 'MailingStreet', label: 'Street' }, source: { type: 'capture', value: { captureField: 'address', label: 'Address Line 1 and 2' } } },
                    { target: { name: 'MailingCity', label: 'City' }, source: { type: 'capture', value: { captureField: 'city', label: 'City' } } },
                    { target: { name: 'MailingStateCode', label: 'State/Province Code' }, source: { type: 'capture', value: { captureField: 'stateCode', label: 'State Code' } } },
                    { target: { name: 'MailingPostalCode', label: 'Postal Code' }, source: { type: 'capture', value: { captureField: 'zip', label: 'Zip Code' } } },
                    { target: { name: 'MailingCountryCode', label: 'Country Code' }, source: { type: 'capture', value: { captureField: 'countryCode', label: 'Country Code' } } },
                    {
                        target: { name: 'AccountId', label: 'Account Name' }, source: {
                            type: 'lookup',
                            value: {
                                appProperty: 'company',
                                message: 'Select Account',
                                type: 'Account',
                                required: false,
                                allowNew: true,
                                resolve: 'createNewAccount'
                            }
                        }
                    },
                ]
            };

            var candidateMap = {
                fields: [
                    { target: { name: 'FirstName', label: 'First Name' }, source: { type: 'capture', value: { captureField: 'first', label: 'First Name' } } },
                    { target: { name: 'LastName', label: 'Last Name' }, source: { type: 'capture', value: { captureField: 'last', label: 'Last Name' } } },
                    { target: { name: 'Title', label: 'Title' }, source: { type: 'capture', value: { captureField: 'jobtitle', label: 'Job Title' } } },
                    { target: { name: 'Company', label: 'Company' }, source: { type: 'capture', value: { captureField: 'company', label: 'Company Name' } } },
                    { target: { name: 'Email', label: 'Email' }, source: { type: 'capture', value: { captureField: 'email', label: 'Email' } } },
                    { target: { name: 'Phone', label: 'Phone' }, source: { type: 'capture', value: { captureField: 'phone', label: 'Phone' } } },
                    { target: { name: 'MobilePhone', label: 'Mobile Phone' }, source: { type: 'capture', value: { captureField: 'phone2', label: 'Phone 2' } } },
                    { target: { name: 'Website', label: 'Website' }, source: { type: 'capture', value: { captureField: 'website', label: 'Website' } } },
                    { target: { name: 'Description', label: 'Description' }, source: { type: 'capture', value: { captureField: 'bio', label: 'Bio' } } },
                    { target: { name: 'Street', label: 'Street' }, source: { type: 'capture', value: { captureField: 'address', label: 'Address Line 1 and 2' } } },
                    { target: { name: 'City', label: 'City' }, source: { type: 'capture', value: { captureField: 'city', label: 'City' } } },
                    { target: { name: 'StateCode', label: 'State/Province Code' }, source: { type: 'capture', value: { captureField: 'stateCode', label: 'State Code' } } },
                    { target: { name: 'PostalCode', label: 'Postal Code' }, source: { type: 'capture', value: { captureField: 'zip', label: 'Zip Code' } } },
                    { target: { name: 'CountryCode', label: 'Country Code' }, source: { type: 'capture', value: { captureField: 'countryCode', label: 'Country Code' } } },


                //return [{
                //    crmProperty: 'Campaign', appProperty: 'campaign', message: 'Select Campaign', type: 'Campaign', required: false, allowNew: false,
                //    resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //        service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    },
                //}, {
                //    crmProperty: 'LeadSource', appProperty: null, message: 'Select Lead Source', type: 'Lead', required: true, allowNew: false,
                //    picklist: true//,
                //    //resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //    //    console.log('resolve called', lookupId, objectId)
                //    //    //service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    //},
                //}];

                    //{ captureField: 'first', label: 'First Name', crmField: { name: 'FirstName', label: 'First Name' } },
                    //{ captureField: 'last', label: 'Last Name', crmField: { name: 'LastName', label: 'Last Name' } },
                    //{ captureField: 'jobtitle', label: 'Job Title', crmField: { name: 'Title', label: 'Title' } },
                    //{ captureField: 'company', label: 'Company Name', crmField: { name: 'Company', label: 'Company' } },
                    //{ captureField: 'email', label: 'Email', crmField: { name: 'Email', label: 'Email' } },
                    //{ captureField: 'phone', label: 'Phone', crmField: { name: 'Phone', label: 'Phone' } },
                    //{ captureField: 'phone2', label: 'Phone 2', crmField: { name: 'MobilePhone', label: 'Mobile Phone' } },
                    //{ captureField: 'website', label: 'Website', crmField: { name: 'Website', label: 'Website' } },
                    //{ captureField: 'bio', label: 'Bio', crmField: { name: 'Description', label: 'Description' } },
                    //{ captureField: 'address1', label: 'Address Line 1', crmField: { name: 'Street', label: 'Street' } },
                    //{ captureField: 'address2', label: 'Address Line 2', crmField: null },
                    //{ captureField: 'city', label: 'City', crmField: { name: 'City', label: 'City' } },
                    //{ captureField: 'state', label: 'State', crmField: { name: 'State', label: 'State' } },
                    //{ captureField: 'zip', label: 'Zip Code', crmField: { name: 'PostalCode', label: 'Postal Code' } },
                    //{ captureField: 'country', label: 'Country', crmField: { name: 'Country', label: 'Country' } },
                ]
            };


            var maps = [];

            maps.push({ name: 'candidate', label: 'Candidate', map: candidateMap });
            maps.push({ name: 'contact', label: 'Contact', map: contactMap });

            successCallback(maps);
        },

        resolveLookup: function (actionId, lookupId, objectId, successCallback, failCallback) {

            console.log('RESOLVING LOOKUP');

            if (actionId === 'addLeadToCampaign') {
                service.createRecord('CampaignMember', { CampaignId: lookupId, LeadId: objectId }, {}, successCallback, failCallback);
            } else if (actionId === 'addContactToCampaign') {
                service.createRecord('CampaignMember', { CampaignId: lookupId, ContactId: objectId }, {}, successCallback, failCallback);
            } else if (actionId === 'createNewAccount') {

                if (lookupId && typeof lookupId.newName === 'undefined') {
                    console.log('EXISTING ACCOUNT', lookupId);
                    //service.updateRecord(objectId, 'Contact', { AccountId: lookupId }, successCallback, failCallback); // No need: was already posted
                    successCallback();
                } else {

                    console.log('NEW ACCOUNT', lookupId.newName);

                    var createSourceRecord = angular.copy(lookupId.record);
                    //Replace new Account name with user-entered value
                    createSourceRecord.company = lookupId.newName;
                    var createOptions = { map: lookupId.map };

                    service.createRecord('Account', createSourceRecord, createOptions,

                        // account was created
                        function (accountLink, accountId) {
                            console.log('account was created', accountLink, accountId, lookupId, objectId);
                            if (objectId) {
                                // Link was requested
                                var updateData = {};
                                updateData[lookupId.crmProperty] = accountId;
                                service.updateRecord(objectId, 'Contact', updateData, successCallback, failCallback);
                            } else {
                                // Link was not requested
                                successCallback(accountLink, accountId);
                            }
                        },

                        // Account was not created
                        function (msg) {
                            console.error('account was not created', msg);
                            failCallback('Account was not created');
                        }
                    );
                }
            } else {
                console.log('ERROR: Unknown action', lookupId);
                failCallback('Unknown action');
            }
        },

        getDefinition: function (entityType, successCallback, failureCallback) {

            console.log('GETTING DEFINITION');

            var def = {};
            entityType = entityType.toLowerCase();
            if (entityType === 'candidate') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'RevenueAvg', 'EmployeesAvg'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'RevenueAvg', 'EmployeesAvg', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { display: 'First Name', group: 'G1' },
                            'LastName': { display: 'Last Name', group: 'G1' },
                            'Title': { display: 'Job Title', group: 'G1' },
                            'Company': { display: 'Company', group: 'G1' },
                            'Email': { display: 'Email', group: 'G1' },
                            'Phone': { display: 'Phone', group: 'G1' },
                            'MobilePhone': { display: 'Mobile Phone', group: 'G1' },
                            'Website': { display: 'Website', group: 'G1' },
                            'Description': { display: 'Description', group: 'G1' },

                            'Street': { display: 'Street', group: 'G2' },
                            'City': { display: 'City', group: 'G2' },
                            'State': { display: 'State/Province', group: 'G2' },
                            'PostalCode': { display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { display: 'Country', group: 'G2' },
                        }
                    }
                };

            } else if (entityType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { id: 'G1', display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description'] },
                            'G2': { id: 'G2', display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'FirstName', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'LastName', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'Title', display: 'Job Title', group: 'G1' },
                            'Email': { id: 'Email', display: 'Email', group: 'G1' },
                            'Phone': { id: 'Phone', display: 'Phone', group: 'G1' },
                            'MobilePhone': { id: 'MobilePhone', display: 'Mobile Phone', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Description': { id: 'Description', display: 'Description', group: 'G1' },

                            'Street': { id: 'Street', display: 'Street', group: 'G2' },
                            'City': { id: 'City', display: 'City', group: 'G2' },
                            'State': { id: 'State', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'PostalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },

        //  From sf candidate to app contact
        fromCandidate: function (sfObject) {
            var contact = {};
            mapFromField(contact, 'first', sfObject, 'FirstName');
            mapFromField(contact, 'last', sfObject, 'LastName');
            mapFromField(contact, 'jobtitle', sfObject, 'Title');
            mapFromField(contact, 'company', sfObject, 'Company');
            mapFromField(contact, 'email', sfObject, 'Email');
            mapFromField(contact, 'phone', sfObject, 'Phone');
            mapFromField(contact, 'phone2', sfObject, 'MobilePhone');
            mapFromField(contact, 'website', sfObject, 'Website');
            mapFromField(contact, 'bio', sfObject, 'Description');
            mapFromField(contact, 'address1', sfObject, 'Street');
            mapFromField(contact, 'city', sfObject, 'City');
            mapFromField(contact, 'state', sfObject, 'State');
            mapFromField(contact, 'zip', sfObject, 'PostalCode');
            mapFromField(contact, 'country', sfObject, 'Country');
            contact._link = store.url + '/' + sfObject.Id;
            contact._type = 'Candidate';
            contact._id = sfObject.Id;
            return contact;
        },
        //  From app contact to sf candidate
        toCandidate: function (contact) {
            var sfObject = {};
            mapField(contact, 'first', sfObject, 'FirstName');
            mapField(contact, 'last', sfObject, 'LastName');
            mapField(contact, 'jobtitle', sfObject, 'Title');
            mapField(contact, 'company', sfObject, 'Company');
            mapField(contact, 'email', sfObject, 'Email');
            mapField(contact, 'phone', sfObject, 'Phone');
            mapField(contact, 'phone2', sfObject, 'MobilePhone');
            mapField(contact, 'website', sfObject, 'Website');
            mapField(contact, 'bio', sfObject, 'Description');
            mapField(contact, 'address1', sfObject, 'Street');
            mapField(contact, 'city', sfObject, 'City');
            mapField(contact, 'state', sfObject, 'State');
            mapField(contact, 'zip', sfObject, 'PostalCode');
            mapField(contact, 'country', sfObject, 'Country');
            return sfObject;
        },
        //  From sf contact to app contact
        fromContact: function (sfObject) {
            var contact = {};
            mapFromField(contact, 'first', sfObject, 'FirstName');
            mapFromField(contact, 'last', sfObject, 'LastName');
            mapFromField(contact, 'jobtitle', sfObject, 'Title');
            mapFromField(contact, 'company', sfObject, 'Account.Name');
            mapFromField(contact, 'email', sfObject, 'Email');
            mapFromField(contact, 'phone', sfObject, 'Phone');
            mapFromField(contact, 'phone2', sfObject, 'MobilePhone');
            mapFromField(contact, 'bio', sfObject, 'Description');
            mapFromField(contact, 'address1', sfObject, 'MailingStreet');
            mapFromField(contact, 'city', sfObject, 'MailingCity');
            mapFromField(contact, 'state', sfObject, 'MailingState');
            mapFromField(contact, 'zip', sfObject, 'MailingPostalCode');
            mapFromField(contact, 'country', sfObject, 'MailingCountry');
            contact._link = store.url + '/' + sfObject.Id;
            contact._type = 'Contact';
            contact._id = sfObject.Id;
            return contact;
        },
        //  from app contact to sf contact
        toContact: function (contact) {
            var sfObject = {};
            mapField(contact, 'first', sfObject, 'FirstName');
            mapField(contact, 'last', sfObject, 'LastName');
            mapField(contact, 'jobtitle', sfObject, 'Title');
            mapField(contact, 'email', sfObject, 'Email');
            mapField(contact, 'phone', sfObject, 'Phone');
            mapField(contact, 'phone2', sfObject, 'MobilePhone');
            mapField(contact, 'bio', sfObject, 'Description');
            mapField(contact, 'address1', sfObject, 'MailingStreet');
            mapField(contact, 'city', sfObject, 'MailingCity');
            mapField(contact, 'state', sfObject, 'MailingState');
            mapField(contact, 'zip', sfObject, 'MailingPostalCode');
            mapField(contact, 'country', sfObject, 'MailingCountry');
            return sfObject;
        },
        //  From sf account to app contact
        fromAccount: function (sfObject) {
            var contact = {};
            mapFromField(contact, 'website', sfObject, 'Website');
            mapFromField(contact, 'company', sfObject, 'Name');
            //mapFromField(contact, 'jobtitle', sfObject, 'Title');
            //mapFromField(contact, 'email', sfObject, 'Email');
            //mapFromField(contact, 'phone', sfObject, 'Phone');
            //mapFromField(contact, 'phone2', sfObject, 'MobilePhone');
            //mapFromField(contact, 'bio', sfObject, 'Description');
            //mapFromField(contact, 'address1', sfObject, 'MailingStreet');
            mapFromField(contact, 'city', sfObject, 'BillingCity');
            mapFromField(contact, 'state', sfObject, 'BillingState');
            //mapFromField(contact, 'zip', sfObject, 'MailingPostalCode');
            //mapFromField(contact, 'country', sfObject, 'MailingCountry');
            //mapFromField(contact, 'country', sfObject, 'MailingCountry');
            contact._createdDate = sfObject.CreatedDate;
            contact._link = store.url + '/' + sfObject.Id;
            //contact._link = store.url + sfObject.attributes.url;
            contact._type = 'Account';
            contact._id = sfObject.Id;
            return contact;
        },
        //  From app contact to sf object
        toNativeRecord: function (contact, entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') { return this.toContact(contact); }
            if (entityType === 'candidate') { return this.toCandidate(contact); }
        },
        //  From sf entity to app contact
        fromNativeRecord: function (sfEntity, entityType) {
            entityType = entityType.toLowerCase();
            if (entityType === 'contact') { return this.fromContact(sfEntity); }
            if (entityType === 'candidate') { return this.fromCandidate(sfEntity); }
            if (entityType === 'account') { return this.fromAccount(sfEntity); }
        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {
            if (debug) { console.log(debug + 'toLookupObject->entityType', entityType, '->crmObject', crmObject); }

            entityType = entityType.toLowerCase();
            var lookupObject = { label: '', link: '' };
            var appObject = null;
            if (entityType === 'contact') { appObject = this.fromContact(crmObject); }
            else if (entityType === 'candidate') {
                appObject = this.fromCandidate(crmObject);
            }
            else if (entityType === 'account') {
                appObject = this.fromAccount(crmObject);
                var cityState = '';
                if (appObject.city) { cityState = appObject.city; }
                if (appObject.state) {
                    if (cityState) { cityState = cityState + ', ' + appObject.state; }
                    else { cityState = appObject.state; }
                }
                if (cityState) { cityState = ' (' + cityState + ')'; }
                lookupObject.label = (appObject.company || '(no name)') + cityState;
                lookupObject.link = appObject._link;
                lookupObject.id = appObject._id;
            }
            else if (entityType === 'campaign') {
                lookupObject.label = (crmObject.Name || '(no name)');
                lookupObject.link = store.url + '/' + crmObject.Id;
                lookupObject.id = crmObject.Id;
            } else {
                // Assume there is Id and Name fields
                lookupObject.label = (crmObject.Name || '(no name)');
                lookupObject.link = store.url + '/' + crmObject.Id;
                lookupObject.id = crmObject.Id;
            }
            if (debug) { console.log(debug + 'toLookupObject->result', lookupObject); }
            return lookupObject;
        },

        getRequiredLookups: function (entityType, actualMap) {

            console.log('GETTING REQUIRED LOOKUPS');

            entityType = entityType.toLowerCase();

            if (actualMap) {

                if (debug) { console.log(debug + 'getRequiredLookups->map', actualMap); }

                var aa = [];

                // convert map def to lookup def

                for (var i = 0, l = actualMap.fields.length; i < l; i++) {
                    var f = actualMap.fields[i];
                    if (f.source && (f.source.type === 'lookup' || f.source.type === 'picklist' || f.source.type === 'action')) {

                        if (f.source && f.source.value && f.source.value.enabled === false) {
                            console.log('disabled action', angular.copy(f));
                            continue;
                        }

                        var a;

                        if (f.source.value) {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: f.source.value.appProperty,
                                message: f.source.value.message,
                                type: f.source.value.type,
                                defaultValue: f.source.value.defaultValue ? { id: f.source.value.defaultValue.value, label: f.source.value.defaultValue.label } : null,
                                required: f.source.value.required,
                                allowNew: f.source.value.allowNew,
                                picklist: f.source.value.picklist || f.source.type === 'picklist',
                                resolve: f.source.value.resolve,
                                hidden: f.source.value.hidden
                            };

                            if (a.crmProperty === 'CampaignMember' && !a.appProperty) {
                                a.appProperty = 'campaign';
                            }
                        } else {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: '',
                                message: '',
                                type: '',
                                defaultValue: '',
                                required: false,
                                allowNew: false,
                                picklist: f.source.type === 'picklist',
                                resolve: null,
                            };
                        }

                        if (f.source.type === 'picklist') {
                            a.type = entityType;
                            a.allowNew = false;
                        }


                        aa.push(a);
                    }
                }

                if (debug) { console.log(debug + 'getRequiredLookups->result', aa); }

                return aa;
            }

            if (entityType === 'contact') {
                return [{ crmProperty: 'AccountId', appProperty: 'company', message: 'Select Account', type: 'Account', required: false, allowNew: true }
                    //,
                    //    { crmProperty: 'OwnerId', appProperty: 'full', message: 'Select account owner', type: 'SystemUser', required: false, allowNew: false }
                ];
            }
            if (entityType === 'candidate') {
                //return [{
                //    crmProperty: 'Campaign', appProperty: 'campaign', message: 'Select Campaign', type: 'Campaign', required: false, allowNew: false,
                //    resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //        service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    },
                //}, {
                //    crmProperty: 'LeadSource', appProperty: null, message: 'Select Lead Source', type: 'Lead', required: true, allowNew: false,
                //    picklist: true//,
                //    //resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //    //    console.log('resolve called', lookupId, objectId)
                //    //    //service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    //},
                //}];
            }
            if (entityType === 'account') { return []; }
            return [];
        },


        asyncGetDefinition: function (entityType) {
            var deferred = $q.defer();
            service.getDefinition(entityType,
                function (def) { deferred.resolve(def); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        //-- CRUD --//
        //  Create a record with data provided
        //      successCallback: function(recordId)
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {

            console.log('CREATING RECORD WITH');
            console.log(recordType);

            if (recordType === 'candidate') { recordType = 'Candidate'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            if (recordType === 'account') { recordType = 'Account'; }

            //var service = this;
            var attemptsLeft = 10;
            var record = {};
            var url = store.url + '/services/data/v34.0/sobjects/' + recordType + '/';

            var createRecordWithMap = function (map, captureRecord) {

                var r = {};

                if (map && map.fields) {
                    var i = map.fields.length;
                    while (i--) {
                        var f = map.fields[i];
                        if (f.target && f.target.name) {
                            if (f.source) {
                                var a = r[f.target.name];
                                var b = '';
                                var l = f.target.length || 0;
                                if (f.source.type === 'capture') {
                                    b = captureRecord[f.source.value.captureField] || '';
                                    if (a) {
                                        r[f.target.name] = service.limitstr(a + ' ' + b, l);
                                    } else {
                                        r[f.target.name] = service.limitstr(b, l);
                                    }
                                } else if (f.source.type === 'text' && f.source.value) {
                                    b = f.source.value.text || '';
                                    if (r[f.target.name]) {
                                        r[f.target.name] = service.limitstr(a + ' ' + b, l);
                                    } else {
                                        r[f.target.name] = service.limitstr(b, l);
                                    }
                                }
                                //else if (f.source.type === 'lookup')
                                //{ r[f.target.name] = f.source.value.text; }
                            }
                        }
                    }
                }

                if (createOptions && createOptions.mappedProperties) {
                    var j = createOptions.mappedProperties.length;
                    while (j--)
                    { r[createOptions.mappedProperties[j].name] = createOptions.mappedProperties[j].value; }
                }

                console.log('SF record', r);

                return r;
            };

            var handleError = function (errorResponse, f) {

                if (debug) { console.log(debug + 'handleError', errorResponse); }

                var tryAgain = false;
                var delayDecision = false;
                var msg = '';
                var text = '';

                var makeDecision = function () {

                    if (tryAgain) {
                        if (debug) { console.log(debug + 'trying again', record); }
                        f();
                    }
                    else {
                        if (msg === '') {
                            msg = errorResponse.responseText;
                        }
                        if (typeof msg === 'undefined' || msg === '') {
                            msg = 'Export error';
                        }
                        failCallback(msg);
                    }
                };


                if (errorResponse.responseJSON) {

                    var i = errorResponse.responseJSON.length;

                    if (i--) {

                        msg += errorResponse.responseJSON[i].message + '  ';

                        var errorCode = errorResponse.responseJSON[i].errorCode;

                        if (errorCode === 'INVALID_SESSION_ID') {
                            service.logout(true);
                            failCallback('Session expired. Please log in.');
                            //} else if (errorCode === 'INVALID_FIELD_FOR_INSERT_UPDATE') {
                            //    var k = errorResponse.responseJSON[i].fields.length;
                            //    while (k--) {
                            //        delete record[errorResponse.responseJSON[i].fields[k]];
                            //        tryAgain = attemptsLeft > 0;
                            //        attemptsLeft--;
                            //    }
                        } else if (errorCode === 'FIELD_INTEGRITY_EXCEPTION') {
                            var j = errorResponse.responseJSON[i].fields.length;
                            while (j--) {
                                delete record[errorResponse.responseJSON[i].fields[j]];
                                tryAgain = attemptsLeft > 0;
                                attemptsLeft--;
                            }
                        } else if (errorCode === 'REQUIRED_FIELD_MISSING') {

                            var requiredField = errorResponse.responseJSON[i].message.split('[')[1];

                            if (requiredField) {
                                requiredField = requiredField.split(']')[0];

                                if (typeof enteredValues[requiredField] !== 'undefined') {
                                    record[requiredField] = enteredValues[requiredField];
                                    tryAgain = attemptsLeft > 0;
                                    attemptsLeft--;
                                }
                                else {
                                    //msg = 'Please map value of required field ' + requiredField + ' and try again';
                                    //attemptsLeft = 0;

                                    text = 'Please enter value of required field ' + requiredField + ':';
                                    delayDecision = true;

                                    $timeout(function () {
                                        dialogs.text.show({ message: text, value: '' }).confirm(function (value) {

                                            console.log('New Value = ' + value);
                                            enteredValues[requiredField] = value;
                                            record[requiredField] = value;

                                            if (typeof value === 'undefined') {
                                                attemptsLeft = 0;
                                            }

                                            tryAgain = attemptsLeft > 0;
                                            attemptsLeft--;

                                            makeDecision();

                                        });
                                    }, 500);
                                }

                            }

                        } else if (errorCode === 'INVALID_OR_NULL_FOR_RESTRICTED_PICKLIST') {

                            var fieldLabel = errorResponse.responseJSON[i].message.split(':')[0];
                            var invalidValue = errorResponse.responseJSON[i].message.split(':')[2];

                            var fieldIndex = 0;
                            if (fieldIndex < errorResponse.responseJSON[i].fields.length) {
                                var fieldName = errorResponse.responseJSON[i].fields[fieldIndex];

                                if (typeof enteredValues[fieldName] !== 'undefined') {
                                    record[fieldName] = enteredValues[fieldName];
                                    tryAgain = attemptsLeft > 0;
                                    attemptsLeft--;
                                }
                                else {
                                    //msg = 'Please map picklist value of field ' + fieldLabel + ' and try again';
                                    //attemptsLeft = 0;

                                    text = 'Please enter valid picklist value of ' + fieldLabel + ':';
                                    delayDecision = true;

                                    $timeout(function () {
                                        dialogs.text.show({ message: text, value: invalidValue }).confirm(function (value) {

                                            console.log('New Value = ' + value);
                                            enteredValues[fieldName] = value;
                                            record[fieldName] = value;

                                            if (!record[fieldName]) {
                                                attemptsLeft = 0;
                                            }

                                            makeDecision();

                                        });
                                    }, 500);
                                }
                                fieldIndex++;
                            }

                            tryAgain = attemptsLeft > 0;
                            attemptsLeft--;

                        } else if (errorCode === 'INVALID_FIELD') {

                            if (errorResponse.responseJSON[i].message === 'No such column \'MailingStateCode\' on sobject of type Contact' ||
                                errorResponse.responseJSON[i].message === 'No such column \'MailingCountryCode\' on sobject of type Contact') {

                                delete record.MailingStateCode;
                                delete record.MailingCountryCode;

                                record.MailingState = service.limitstr(captureRecord.state, 0);
                                record.MailingCountry = service.limitstr(captureRecord.country, 0);

                                tryAgain = attemptsLeft > 0;
                                attemptsLeft--;

                            } else if (errorResponse.responseJSON[i].message === 'No such column \'StateCode\' on sobject of type Candidate' ||
                                errorResponse.responseJSON[i].message === 'No such column \'CountryCode\' on sobject of type Candidate') {

                                delete record.StateCode;
                                delete record.CountryCode;

                                record.State = service.limitstr(captureRecord.state, 0);
                                record.Country = service.limitstr(captureRecord.country, 0);

                                tryAgain = attemptsLeft > 0;
                                attemptsLeft--;

                            } else {

                                if (errorResponse.responseJSON[i].message.indexOf('No such column' >= 0)) {
                                    var missingField = errorResponse.responseJSON[i].message.split('\'')[1];
                                    if (missingField) {
                                        delete record[missingField];
                                        tryAgain = attemptsLeft > 0;
                                        attemptsLeft--;
                                    }
                                }

                            }
                        }

                    }
                }

                if (!delayDecision)
                { makeDecision(); }

            };

            var handleSuccess = function (successResponse) {

                if (debug) { console.log(debug + 'handleSuccess', successResponse); }

                //var fields = {};
                //fields[data.mappedProperties[0].name] = '0014000001Ym7q7'; //data.mappedProperties[0].value;
                //updateRecord(successResponse.id, { 'FirstName': 'Alex' });
                //updateRecord(successResponse.id, { 'accid': '0014000001Ym7q7' });

                if (successResponse && successResponse.success)
                { successCallback(store.url + '/' + successResponse.id, successResponse.id); }
                else
                { failCallback('Record was not created'); }

            };

            var composeDescription = function (contact) {
                var s = [];
                s.push('Added by Capture!');
                if (contact.mark && contact.mark !== 'Default') { s.push('List: [' + contact.mark + ']'); }
                if (contact.email2) { s.push('Email 2: ' + contact.email2); }
                if (contact.sourceurl) { s.push('Source URL: ' + contact.sourceurl); }
                if (contact.venues) {
                    s.push('Social Links:');
                    for (var i = 0; i < contact.venues.length; i++)
                    { s.push(contact.venues[i].website); }
                    //{ s.push(contact.venues[i].type + ': ' + contact.venues[i].website); }
                }
                if (contact.bio) { s.push('Bio:\n' + contact.bio); }


                return s.join('\n').trim();
            };

            var createCandidate = function (contact) { //, session, url, crmid, sitekey) {

                //console.log('SF', session, url, store.id);


                var countryCode = service.convertCountryToJobScienceCountryCode(contact.country);
                var stateCode = service.convertStateToJobScienceStateCode(contact.state);

                if (service.isUSState(stateCode)) {
                    countryCode = 'US';
                }

                record = {
                    'LastName': service.limitstr(contact.last, 80),
                    'FirstName': service.limitstr(contact.first, 40),
                    'Email': service.limitstr(contact.email, 0),
                    'Company': service.limitstr(contact.company ? contact.company : 'Unknown', 255),
                    'Title': service.limitstr(contact.jobtitle, 128),
                    'Street': service.limitstr((contact.address1 ? contact.address1 : '') + (contact.address2 ? ' ' + contact.address2 : ''), 0),
                    'City': service.limitstr(contact.city, 0),
                    'State': service.limitstr(contact.state, 0),
                    'StateCode': service.limitstr(stateCode, 0),
                    'PostalCode': service.limitstr(contact.zip, 0),
                    'Country': service.limitstr(contact.country, 0),
                    'CountryCode': service.limitstr(countryCode, 0),
                    'Website': service.limitstr(contact.website, 255),
                    'Phone': service.limitstr(contact.phone, 0),
                    'MobilePhone': service.limitstr(contact.phone2, 0),
                    'Fax': service.limitstr(contact.fax, 0),
                    //'LeadSource': service.limitstr((contact.mark && contact.mark !== 'Default' ? contact.mark : 'Capture!'), 0),
                    'Description': service.limitstr(composeDescription(contact), 32000)
                };

                if (record.StateCode !== '') {
                    delete record.State;
                }
                if (record.CountryCode !== '') {
                    delete record.Country;
                }

                if (createOptions && createOptions.mappedProperties) {
                    var i = createOptions.mappedProperties.length;
                    while (i--)
                    { record[createOptions.mappedProperties[i].name] = createOptions.mappedProperties[i].value; }
                }

                console.log('SF Record', JSON.stringify(record), JSON.stringify(contact));

                var f = function () {
                    try {
                        if (debug) { console.log(debug + 'post', angular.copy(record)); }
                        //calls Job Science REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: url, //url + code + 'Lead/',
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                handleError(errorResponse, f);
                            }

                        });
                    } catch (e) {
                        console.log('create sf candidate failed', e);
                        failCallback('Record was not created');
                    }
                };

                f();

            };

            var createContact = function (contact) {

                var countryCode = service.convertCountryToJobScienceCountryCode(contact.country);
                var stateCode = service.convertStateToJobScienceStateCode(contact.state);

                if (service.isUSState(stateCode))
                { countryCode = 'US'; }

                record = {
                    //'AccountId': '', // passed as mappedProperties
                    'LastName': service.limitstr(contact.last, 80),
                    'FirstName': service.limitstr(contact.first, 40),
                    'Email': service.limitstr(contact.email, 0),
                    'Title': service.limitstr(contact.jobtitle, 128),
                    'MailingStreet': service.limitstr((contact.address1 ? contact.address1 : '') + (contact.address2 ? ' ' + contact.address2 : ''), 0),
                    'MailingCity': service.limitstr(contact.city, 0),
                    'MailingState': service.limitstr(contact.state, 0),
                    'MailingStateCode': service.limitstr(stateCode, 0),
                    'MailingPostalCode': service.limitstr(contact.zip, 0),
                    'MailingCountry': service.limitstr(contact.country, 0),
                    'MailingCountryCode': service.limitstr(countryCode, 0),
                    'Phone': service.limitstr(contact.phone, 0),
                    'MobilePhone': service.limitstr(contact.phone2, 0),
                    'Fax': service.limitstr(contact.fax, 0),
                    'Description': service.limitstr(composeDescription(contact), 32000)
                };

                if (record.MailingStateCode !== '') {
                    delete record.MailingState;
                }
                if (record.MailingCountryCode !== '') {
                    delete record.MailingCountry;
                }

                if (createOptions && createOptions.mappedProperties) {
                    var i = createOptions.mappedProperties.length;
                    while (i--) {
                        var fieldName = createOptions.mappedProperties[i].name;
                        record[fieldName] = createOptions.mappedProperties[i].value;
                    }
                }

                var f = function () {

                    if (debug) { console.log(debug + 'post', url, angular.copy(record)); }
                    try {
                        //calls Job Science REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: url,
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                handleError(errorResponse, f);
                            }
                        });
                    } catch (e) {
                        console.log('create sf contact failed', e);
                        failCallback('Record was not created');
                    }
                };

                f();

            };

            var createAccount = function (contact) {

                //if (map && map.fields && map.fields.length > 0) {
                //    record = createRecordWithMap(map, contact);
                //} else {
                var countryCode = service.convertCountryToJobScienceCountryCode(contact.country);
                var stateCode = service.convertStateToJobScienceStateCode(contact.state);

                if (service.isUSState(stateCode)) {
                    countryCode = 'US';
                }

                record = {
                    'Name': service.limitstr(contact.company || 'Unknown', 255),
                    'BillingStreet': service.limitstr((contact.address1 ? contact.address1 : '') + (contact.address2 ? ' ' + contact.address2 : ''), 0),
                    'BillingCity': service.limitstr(contact.city, 40),
                    'BillingState': service.limitstr(contact.state, 80),
                    'BillingStateCode': service.limitstr(stateCode, 0),
                    'BillingPostalCode': service.limitstr(contact.zip, 20),
                    'BillingCountry': service.limitstr(contact.country, 80),
                    'BillingCountryCode': service.limitstr(countryCode, 0),
                    'Website': service.limitstr(contact.website, 255),
                    'Phone': service.limitstr(contact.phone, 0),
                    'Fax': service.limitstr(contact.fax, 0),
                    'Description': service.limitstr('Added by Capture!', 32000)
                };

                if (record.BillingStateCode !== '') {
                    delete record.BillingState;
                }
                if (record.BillingCountryCode !== '') {
                    delete record.BillingCountry;
                }
                //}

                if (createOptions && createOptions.mappedProperties) {
                    var i = createOptions.mappedProperties.length;
                    while (i--)
                    { record[createOptions.mappedProperties[i].name] = createOptions.mappedProperties[i].value; }
                }

                console.log('SF Record', JSON.stringify(record), JSON.stringify(contact));

                var f = function () {
                    try {
                        if (debug) { console.log(debug + 'post', angular.copy(record)); }

                        //calls Job Science REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: url,
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                console.log('**** CREATE ACCOUNT SUCCESS');
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                console.log('**** CREATE ACCOUNT FAIL');
                                handleError(errorResponse, f);
                            }

                        });
                    } catch (e) {
                        console.log('create sf account failed', e);
                        failCallback(e.message);
                    }
                };

                f();

            };

            var createNewRecord = function (recordType, record2) {

                record = record2; // fixing the scope

                if (debug) { console.log(debug + 'createNewRecord->type:', recordType, '->record:', record); }

                var f = function () {
                    try {
                        if (recordType === 'Candidate') {
                            recordType = 'Contact';
                            record.RecordTypeID = '01236000000dz4B';
                        }
                        if (debug) { console.log(debug + 'post', angular.copy(record)); }
                        //calls Job Science REST API with jQuery
                        jQuery.ajax({
                            type: 'POST',
                            url: store.url + '/services/data/v34.0/sobjects/' + recordType + '/',
                            contentType: 'application/json',
                            dataType: 'json',
                            data: JSON.stringify(record),
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (successResponse) {
                                handleSuccess(successResponse);
                            },
                            error: function (errorResponse) {
                                handleError(errorResponse, f);
                            }

                        });
                    } catch (e) {
                        console.log('create failed', e);
                        failCallback(e.message);
                    }
                };

                f();

            };


            console.log('SF create record', captureRecord);


            if (createOptions && createOptions.map && createOptions.map.fields && createOptions.map.fields.length > 0) {

                captureRecord.address = ((captureRecord.address1 ? captureRecord.address1 : '') +
                    (captureRecord.address2 ? ' ' + captureRecord.address2 : '')).trim();

                captureRecord.stateCode = service.convertStateToJobScienceStateCode(captureRecord.state);
                captureRecord.countryCode = service.convertCountryToJobScienceCountryCode(captureRecord.country);
                if (service.isUSState(captureRecord.stateCode)) {
                    captureRecord.countryCode = 'US';
                }

                var rec = createRecordWithMap(createOptions.map, captureRecord);

                createNewRecord(recordType, rec);

            } else {

                if (recordType.toUpperCase() === 'CANDIDATE')
                { createCandidate(captureRecord); }
                else if (recordType.toUpperCase() === 'CONTACT')
                { createContact(captureRecord); }
                else if (recordType.toUpperCase() === 'ACCOUNT')
                { createAccount(captureRecord); }
                else
                { createNewRecord(recordType, captureRecord); }

            }

        },

        //  Update an existing record with data
        //      successCallback: function(recordId)
        updateRecord: function (recordId, recordType, record, successCallback, failCallback, original) {
            if (recordType === 'candidate') { recordType = 'Candidate'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            var headers = { 'Content-type': 'application/json', 'Authorization': 'OAuth ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' };
            var url = store.url + '/services/data/v34.0/sobjects/' + recordType + '/' + recordId;

            if (original) {
                // remove fields that did not change
                for (var a in original) {
                    if (record[a] === original[a]) {
                        delete record[a];
                    }
                }
                console.log(consolePrefix + 'Update > Cleaned Record > ', record);
            }

            var config = { method: 'PATCH', url: url, data: record, headers: headers };
            console.log('salesforce.updateRecord...', config);
            $http(config).success(function (response) {
                if (debug) { console.log('salesforce.updateRecord:', response); }
                try { successCallback(response); } catch (e) { }
            }).error(function (response, status) {
                if (debug) { console.error('salesforce.updateRecord:', status, response); }
                var msg = '';
                if (response && response.length > 0) {
                    var i = 0;
                    while (i < response.length) {
                        if (response[i].message)
                        { msg += response[i].message + ' '; }
                        i++;
                    }
                }
                try { failCallback('Cannot update Job Science record: (' + status + ') ' + (msg || response)); } catch (e) { }
            });
        },

        //  Retrieve record from service
        //      successCallback: function(recordId, data)
        retrieveRecord: function (recordId, recordType, successCallback, failureCallback) {

            console.log('RETRIEVING RECORD');
            try {
                if (recordType === 'candidate') { recordType = 'Candidate'; }
                if (recordType === 'contact') { recordType = 'Contact'; }
                var config = { headers: { 'Content-type': 'application/json', 'Authorization': 'OAuth ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' } };
                var url = store.url + '/services/data/v34.0/sobjects/' + recordType + '/' + recordId;
                console.log('salesforce.retrieveRecord...', { url: url, config: config });
                $http.get(url, config).success(

                    //function (response) {
                    //    if (debug) { console.log('salesforce.retrieveRecord:', response); }
                    //    try { successCallback(response); } catch (e) { }
                    //}

                    function (data, status, headers, config) {
                        defaultOnSuccessHandler(data, status, headers, config, successCallback, failureCallback);
                    }

                ).error(function (response, status) {
                    console.error('Retrieve Record > Error > ', response, status);
                    var error = '';
                    if (response.message) { error = response.message; }
                    else { error = JSON.stringify(response); }
                    try { failureCallback('Cannot retrieve Job Science record: (' + status + ') ' + error, status); } catch (e) { }
                });
            } catch (e) {
                console.error('Retrieve Record > Exception > ', e.message);
                var details = 'Chrome exception';
                if (e && e.message) {
                    details = e.message;
                }
                failureCallback('Cannot retrieve Job Science record: ' + details);
            }
        },

        asyncRetrieveRecord: function (recordId, recordType) {
            var deferred = $q.defer();
            service.retrieveRecord(recordId, recordType,
                function (response) { deferred.resolve(response); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        //  Delete record from service
        //      successCallback: function(recordId)
        deleteRecord: function (recordId, successCallback, failCallback) {
        },
        //-- /CRUD --//


        //-- Search --//
        //  Find a record using a query: { first:'', last:'', email:''} object
        //      successCallback: function(nativeRecords[])
        findRecord: function (recordType, query, fields, successCallback, failureCallback) {
            const functionName = 'Find Record';
            try {

                console.log(consolePrefix + functionName, ' > Type > ', recordType, ' > Query > ', query, ' > Fields >', fields);

                checkSession();

                //var service = this;

                var encodeParam = function (p) {
                    p = p || '';
                    p = p.replace('\\', '\\\\');
                    p = p.replace('\'', '\\\'');
                    p = p.replace('\"', '\\\"');
                    return encodeURIComponent(p);
                    //return p.replace(/'/g, '%5C%27');
                };

                if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

                if (recordType === 'account') { recordType = 'Account'; }
                if (recordType === 'candidate') { recordType = 'Contact'; }
                if (recordType === 'contact') { recordType = 'Contact'; }
                if (recordType === 'campaign') { recordType = 'Campaign'; }

                var where = [];

                if (query) {

                    if (query.email)
                    { where.push('Email=\'' + encodeParam(query.email) + '\''); }

                    if (query.email_endsWith)
                    { where.push('Email+LIKE+\'%25' + encodeParam(query.email_endsWith) + '\''); }

                    if (query.last)
                    { where.push('LastName=\'' + encodeParam(query.last) + '\''); }

                    if (query.first)
                    { where.push('FirstName=\'' + encodeParam(query.first) + '\''); }

                    if (query.middle)
                    { where.push('MiddleName=\'' + encodeParam(query.middle) + '\''); } // The field may be disabled!

                    if (recordType === 'Account') {
                        if (query.company)
                        { where.push('Name+LIKE+\'%25' + encodeParam(query.company) + '%25\''); }
                        if (query.website)
                        { where.push('Website+LIKE+\'%25' + encodeParam(query.website) + '%25\''); }
                    }

                    if (recordType === 'Campaign') {
                        if (query.campaign)
                        { where.push('Name+LIKE+\'%25' + encodeParam(query.campaign) + '%25\''); }
                    }

                }
                var whereStr = where.join('+AND+');
                if (recordType === 'Account') {
                    whereStr = where.join('+OR+');
                }
                if (whereStr) { whereStr = '+WHERE+' + whereStr; } else { whereStr = '+'; }
                console.log(whereStr);

                var fieldsStr = 'Id,Name'; // * is not supported by SOQL SELECT Syntax
                var f;

                if (recordType === 'user') {
                    fieldsStr = 'Id,Name';
                }

                if (recordType === 'Account') {
                    f = [];

                    f.push('ID');

                    if (fields.indexOf('company') > -1) { f.push('Name'); }
                    if (fields.indexOf('website') > -1) { f.push('Website'); }
                    if (fields.indexOf('_createdDate') > -1) { f.push('CreatedDate'); }

                    f.push('BillingCity');
                    f.push('BillingState');

                    fieldsStr = f.join(',');
                }

                if (recordType === 'Contact') {
                    f = [];

                    f.push('ID');

                    if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                    if (fields.indexOf('last') > -1) { f.push('LastName'); }
                    if (fields.indexOf('email') > -1) { f.push('Email'); }
                    //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                    fieldsStr = f.join(',');
                }

                if (recordType === 'Candidate') {
                    f = [];

                    f.push('ID');

                    if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                    if (fields.indexOf('last') > -1) { f.push('LastName'); }
                    if (fields.indexOf('email') > -1) { f.push('Email'); }
                    //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                    fieldsStr = f.join(',');
                }

                if (recordType === 'Campaign') {
                    f = [];

                    f.push('ID');
                    f.push('Name');

                    fieldsStr = f.join(',');
                }

                var headers = { 'Content-type': 'application/json', 'Authorization': 'OAuth ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' };
                var url = store.url + '/services/data/v34.0/query/?q=SELECT+' + fieldsStr + '+FROM+' + recordType + whereStr;

                if (query && query.limit > 0)
                { url = url + '+LIMIT+' + query.limit; }
                else if (query && query.limit === 0)
                { }
                else
                { url = url + '+LIMIT+50'; }

                var config = { method: 'GET', url: url, headers: headers };
                if (debug) { console.log(debug + 'findRecord->config:', config); }

                var allRecords = [];

                var errorHandler = function (response, status) {
                    try {
                        if (debug) { console.error(consolePrefix + functionName + '> Failure Response > ', response); }
                        var msg = '';
                        if (response && response.length > 0) {

                            if (response[0].errorCode === 'INVALID_SESSION_ID') {
                                service.logout(true);
                            }

                            var i = 0;
                            while (i < response.length) {
                                if (response[i].message)
                                { msg += response[i].message + ' '; }
                                i++;
                            }
                        }
                        try { failureCallback('Cannot find Job Science record: (' + (status || '') + ') ' + (msg || response)); } catch (e) { }
                    } catch (e) {
                        console.error(functionName, e.message);
                        failureCallback(e.message);
                    }
                };

                var successHandler = function (response) {
                    try {
                        if (debug) { console.log(consolePrefix + functionName + ' > Success Response > ', response); }

                        allRecords = allRecords.concat(response.records);

                        if (!response.done && response.nextRecordsUrl) {
                            config.url = store.url + response.nextRecordsUrl;
                            $http(config).success(successHandler).error(errorHandler);
                        }
                        else { try { successCallback(allRecords); } catch (e) { } }
                    } catch (e) {
                        console.error(functionName, e.message);
                        failureCallback(e.message);
                    }

                };

                $http(config).success(successHandler).error(errorHandler);

            } catch (e) {
                console.error(functionName, e.message);
                failureCallback(e.message);
            }

        },
        //-- /Search --//


        //-- Auth --//
        //  Authenticate with the service
        //      successCallback: function(authId)
        authenticate: function (credentials, successCallback, failCallback) {
            // https://login.salesforce.com/services/oauth2/authorize?response_type=code&client_id= &redirect_uri=
        },

        //  is this client currently authenticated?
        //      return true/false
        isAuthenticated: function () {
        },
        //-- /Auth --//


        //-- Define --//
        //  Get a list of all available entities (lead, contact, account, etc)
        //      successCallback: function(entityList)
        listEntities: function (successCallback, failCallback) {
        },

        //  Get the definition for an entity (field names of a lead or contact)
        //      successCallback: function(entityDefinition)
        defineEntity: function (entity, successCallback, failCallback) {
        },
        //-- /Define --//


        findDuplicates: function (recordType, contact, successCallback, failCallback) {
            const functionName = 'Find Duplicates';
            try {

                if (debug) { console.log(consolePrefix + functionName, recordType, contact); }

                if (typeof store.url === 'undefined') {
                    console.error(functionName + ' > Not initialized > ', store);
                    try { failCallback('Session expired. Please log in.'); } catch (e) { }
                    return;
                }

                var encode = function (s) {
                    if (typeof s === 'undefined') { s = ''; }
                    return s.replace(/'/g, '\\\'');
                };

                if (recordType === 'candidate') { recordType = 'Contact'; }
                if (recordType === 'contact') { recordType = 'Contact'; }

                var fields = 'ID,LastName,FirstName,Email,Company,Phone,Title';
                if (recordType === 'Contact') { fields = 'ID,LastName,FirstName,Email,Title,Phone,Account.Name'; }

                var from = recordType;
                if (recordType === 'Contact')
                { from = 'Contact,Contact.Account'; }

                var where = '';

                var dups = [];

                var reponseHandle = null;
                var returnResponse = function () {
                    try {
                        successCallback({ duplicates: dups });
                    } catch (e) { }
                };

                var query = function (q) {

                    try {

                        //calls Job Science REST API with jQuery
                        jQuery.ajax({
                            type: 'GET',
                            url: store.url + '/services/data/v34.0/query/?q=' + q,
                            beforeSend: function (xhr) {
                                xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
                                xhr.setRequestHeader('Accept', 'application/json');
                            },
                            success: function (sfdata) {
                                console.log('findDuplicates results', sfdata);

                                if (!sfdata.records)
                                { try { failCallback(); } catch (e) { } }


                                for (var i = 0; i < sfdata.records.length; i++) {
                                    var dup = {};
                                    if (recordType === 'Candidate') { dup = service.fromCandidate(sfdata.records[i]); }
                                    else if (recordType === 'Contact') { dup = service.fromContact(sfdata.records[i]); }
                                    dups.push(dup);
                                }

                                if (reponseHandle) {
                                    window.clearTimeout(reponseHandle);
                                }
                                reponseHandle = window.setTimeout(returnResponse, 2000);

                            },
                            failure: function (error) {
                                console.log('ERROR in findDuplicates', error); // 401 [{"message":"Session expired or invalid","errorCode":"INVALID_SESSION_ID"}]
                                try { failCallback(); } catch (e) { }
                            },
                            xhr: function () {
                                var xhr = new window.XMLHttpRequest();
                                xhr.addEventListener('error', function (evt) {
                                    console.log('XHR Event: an error occured');
                                }, false);
                                xhr.addEventListener('abort', function () {
                                    console.log('XHR Event: cancelled');
                                }, false);
                                return xhr;
                            },
                            error: function (errorResponse) {
                                console.log('AJAX error in request: ' + JSON.stringify(errorResponse || '', null, 2));

                                if (errorResponse && errorResponse.responseJSON && errorResponse.responseJSON.length > 0 && errorResponse.responseJSON[0].errorCode === 'INVALID_SESSION_ID') {
                                    try {
                                        service.logout(true);
                                        service.login(function () {
                                            service.findDuplicates(recordType, contact, successCallback, failCallback);
                                        }, function (error) {
                                            console.error(functionName + ' > Login Failure > ', error);
                                            try { failCallback(error); } catch (e) { }
                                        }, true);
                                    } catch (e) {
                                        console.error(functionName + ' > Relogin Failure > ', e.message);
                                        try { failCallback(e.message); } catch (e) { }
                                    }
                                }
                                else {
                                    try { failCallback(); } catch (e) { }
                                }
                            }
                        })
                        ;

                    } catch (e) {
                        console.log('ERROR in query', e.message);
                        try { failCallback(); } catch (e) { }
                    }

                };


                if (contact.email) {
                    where = 'Email=\'' + encode(contact.email) + '\'';
                    if (recordType === 'Candidate')
                    { where += '+AND+IsConverted=False'; }
                    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                }

                if (contact.last && contact.first) {
                    where = 'LastName=\'' + encode(contact.last) + '\'+AND+FirstName=\'' + encode(contact.first) + '\'';
                    if (recordType === 'Candidate')
                    { where += '+AND+IsConverted=False'; }
                    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                }

                //if (contact.phone && contact.last) {
                //    where = 'LastName=\'' + encode(contact.last) + '\'+AND+Phone=\'' + encode(contact.phone) + '\'';
                //    if (recordType === 'Lead')
                //    { where += '+AND+IsConverted=False'; }
                //    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                //}

                if (contact.email2) {
                    where = 'Email=\'' + contact.email2 + '\'';
                    if (recordType === 'Candidate')
                    { where += '+AND+IsConverted=False'; }
                    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
                }

            } catch (e) {
                console.error(functionName, e.message);
                failCallback(e.message);
            }
        },


        getDetails: function (captureRecord, parentRecordType, successCallback, failCallback) {





            console.log('getDetails', captureRecord);

            var recordId = captureRecord._id;



            var config = { headers: { 'Content-type': 'application/json', 'Authorization': 'OAuth ' + store.id, 'Accept': 'application/json', 'Cache-Control': 'no-cache' } };
            var url = null;

            if (parentRecordType.toLowerCase() === 'candidate') {
                url = store.url + '/services/data/v33.0/query/?q=SELECT LastActivityDate, ' +
                    ' (SELECT ActivityDate, ActivityType, Description, Status, Subject, Owner.Name FROM ActivityHistories LIMIT 10),' +
                    ' (SELECT ActivityDate, Description, Status, Subject, Owner.Name FROM Tasks LIMIT 10)' +
                    ' FROM Contact WHERE Id = \'' + recordId + '\'';
            }
            else if (parentRecordType.toLowerCase() === 'contact') {
                url = store.url + '/services/data/v33.0/query/?q=SELECT LastActivityDate, ' +
                    ' Account.Name, Account.Website, ' +
                    ' (SELECT ActivityDate, ActivityType, Description, Status, Subject, Owner.Name FROM ActivityHistories LIMIT 10),' +
                    ' (SELECT ActivityDate, Description, Status, Subject, Owner.Name FROM Tasks LIMIT 10),' +
                    ' (SELECT Amount, IsClosed, IsWon, CloseDate, LastActivityDate, StageName, Type, Description, Owner.Name FROM Opportunities LIMIT 10)' +
                    ' FROM Contact WHERE Id = \'' + recordId + '\'';
            } else {
                try { failCallback('Cannot retrieve Job Science record type: ' + parentRecordType); } catch (e) { }
                return;
            }

            captureRecord._act = captureRecord._act || {};
            captureRecord._opp = captureRecord._opp || {};

            var parseOpp = function (record) {

                var detailRecord = null;
                var detailRecordId = null;

                if (typeof record.Opportunities === 'object' && record.Opportunities !== null && record.Opportunities.totalSize > 0) {

                    for (var i = 0; i < record.Opportunities.totalSize; i++) {
                        detailRecord = record.Opportunities.records[i];
                        console.log('getDetails->opp', detailRecord);
                        detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                        //console.log('***** opp link', detailRecord.attributes.url, detailRecordId, store.url);
                        var a = detailRecord.Amount;
                        var n;
                        if (detailRecord.Amount && detailRecord.Amount > 1000000) {
                            n = Math.round(detailRecord.Amount / 1000000);
                            a = '$' + n + 'K';
                        }
                        else if (detailRecord.Amount && detailRecord.Amount > 1000) {
                            n = Math.round(detailRecord.Amount / 1000);
                            a = '$' + n + 'K';
                        }
                        var opp = {
                            who: detailRecord.Owner.Name,
                            when: detailRecord.LastActivityDate,
                            what: detailRecord.Name + ' ' + a,
                            details: detailRecord.Description,
                            link: store.url + '/' + detailRecordId
                        };

                        if (i === 0) {
                            captureRecord._opp.last = opp;
                        } else {
                            captureRecord._opp.next = opp;
                        }
                    }
                }
            };

            var successHandler2 = function (response) {
                console.log('getDetails->successCallback2', response);

                try {

                    if (response !== null && response.totalSize > 0) {

                        var record = response.records[0];

                        parseOpp(record);

                    }
                } catch (e) {
                    console.log('********************* ERROR in getDetails->successCallback2: ' + e.message);
                }

                console.log('captureRecord = ', captureRecord);

                try { successCallback(captureRecord); } catch (e) { }

            };

            var successHandler = function (response) {
                console.log('getDetails->successCallback', response);

                var suspendCallback = false;

                try {

                    if (response !== null && response.totalSize > 0) {

                        var record = response.records[0];
                        var detailRecord = null;
                        var detailRecordId = null;

                        captureRecord._dt = record.LastActivityDate;

                        if (typeof record.Account === 'object' && record.Account !== null) {
                            detailRecord = record.Account;
                            console.log('*** getDetails->account', detailRecord);
                            captureRecord.company = captureRecord.company || detailRecord.Name;
                            captureRecord.website = captureRecord.website || detailRecord.Website;
                            captureRecord._website = detailRecord.Website;
                            detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                            captureRecord._companyLink = store.url + '/' + detailRecordId;
                            console.log('*** getDetails->account->captureRecord', captureRecord);
                            // Query for opportunities
                            if (detailRecordId) {

                                url = store.url + '/services/data/v33.0/query/?q=SELECT ' +
                                   ' (SELECT Name, Amount, IsClosed, IsWon, CloseDate, LastActivityDate, StageName, Type, Description, Owner.Name FROM Opportunities LIMIT 10)' +
                                   ' FROM Account WHERE Id = \'' + detailRecordId + '\'';

                                $http.get(url, config)
                                    .success(successHandler2)
                                    .error(function (response, status) {
                                        var error = 'Cannot retrieve Job Science record';
                                        if (response.message) { error = response.message; }
                                        console.log('ERROR in salesforce.retrieveOppRecord:' + JSON.stringify(response));
                                        try { failCallback('Cannot retrieve Job Science record: (' + status + ') ' + response, status); } catch (e) { }
                                    });

                                suspendCallback = true;

                            }

                        }

                        if (typeof record.ActivityHistories === 'object' && record.ActivityHistories !== null && record.ActivityHistories.totalSize > 0) {
                            detailRecord = record.ActivityHistories.records[0];
                            console.log('*** getDetails->activityRecord', detailRecord);
                            detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                            captureRecord._act.last = {
                                who: detailRecord.Owner.Name,
                                when: detailRecord.ActivityDate,
                                what: detailRecord.Subject,
                                details: detailRecord.Description,
                                link: store.url + '/' + detailRecordId
                            };
                        }

                        if (typeof record.Tasks === 'object' && record.Tasks !== null && record.Tasks.totalSize > 0) {
                            detailRecord = record.Tasks.records[record.Tasks.totalSize - 1];
                            console.log('*** getDetails->task', detailRecord);
                            detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.lastIndexOf('/') + 1);
                            captureRecord._act.next = {
                                who: detailRecord.Owner.Name,
                                when: detailRecord.ActivityDate,
                                what: detailRecord.Subject,
                                details: detailRecord.Description,
                                link: store.url + '/' + detailRecordId
                            };
                        }

                        parseOpp(record);

                        //if (typeof record.Opportunities === 'object' && record.Opportunities !== null && record.Opportunities.totalSize > 0) {
                        //    detailRecord = record.Opportunities.records[record.Opportunities.totalSize - 1];
                        //    console.log('getDetails->opp', detailRecord);
                        //    detailRecordId = detailRecord.attributes.url.substring(detailRecord.attributes.url.indexOf('/Opportunities/') + 15);
                        //    captureRecord._opp.last = {
                        //        who: detailRecord.Owner.Name,
                        //        when: detailRecord.LastActivityDate,
                        //        what: detailRecord.Amount,
                        //        details: detailRecord.Description,
                        //        link: store.url + '/' + detailRecordId
                        //    };
                        //}

                    }
                } catch (e) {
                    console.log('********************* ERROR in getDetails->successCallback: ' + e.message);
                }

                console.log('captureRecord = ', captureRecord);

                if (!suspendCallback) {
                    try { successCallback(captureRecord); } catch (e) { }
                }

            };

            $http.get(url, config)
                .success(successHandler)
                .error(function (response, status) {
                    var error = 'Cannot retrieve Job Science record';
                    if (response.message) { error = response.message; }
                    if (debug) { console.log('salesforce.retrieveRecord:' + JSON.stringify(response)); }
                    try { failCallback('Cannot retrieve Job Science record: (' + status + ') ' + response, status); } catch (e) { }
                });

        },
        // ***********************************
        // ** Job Science-specific functions **
        // ***********************************

        convertStateToJobScienceStateCode: function (state) {

            if (typeof state === 'undefined' || state === null || state === '') {
                return '';
            }

            var key = state.toLowerCase();
            var r = geographyData.stateNameLowerToStateCodeDict[key];
            if (!r) {
                r = state;
            }
            return r.toUpperCase();

        },

        convertCountryToJobScienceCountryCode: function (country) {

            if (typeof country === 'undefined' || country === null || country === '') {
                return '';
            }

            var key = country.toLowerCase();
            var r = geographyData.countryNameLowerToCountryCodeDict[key];
            if (!r) {
                r = country;
            }
            return r.toUpperCase();
        },

        isUSState: geographyData.isUSStateCode,

        limitstr: //backgroundUtility.limitstr,
            function (s, limit) {
                if (!s || !limit) {
                    return s;
                }
                if (s.length > limit) {
                    return s.substring(0, limit);
                }
                return s;
            },


        //var updateRecord = function (id, fields) {

        //    if (debug) { console.log(debug + 'updateRecord', id, angular.copy(fields)); }

        //    //calls JobScience REST API with jQuery
        //    jQuery.ajax({
        //        type: 'PATCH',
        //        url: url + id,
        //        contentType: 'application/json',
        //        dataType: 'json',
        //        data: JSON.stringify(fields),
        //        beforeSend: function (xhr) {
        //            xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
        //            xhr.setRequestHeader('Accept', 'application/json');
        //        },
        //        success: function (successResponse) {
        //            handleSuccess(successResponse);
        //        },
        //        error: function (errorResponse) {
        //            handleError(errorResponse, f);
        //        }
        //    });

        //};

        /**
        * @function validateRecord
        * @description Validates if record can be exported. Returns list of errors.
        * @memberOf captureApp.webServices.exportTargetVer1.salesforce
        * @param {recordType} recordType - Record type
        * @param {captureContact} captureRecord - Source Capture Contact. 
        */
        validateRecord: function (recordType, captureRecord) {

            var errors = [];

            if (!captureRecord) {
                errors.push('Record does not exist');
            } else {
                if (!captureRecord.last) {
                    errors.push('Last name is required');
                }
            }

            return errors;
        }

    };
    return service;
}]);
/**
 * @class captureApp.webServices.exportTargetVer1.pipeliner
 * @memberOf captureApp.webServices.exportTargetVer1
 * @description This is Pipeliner AngularJS service.
 * @constructor
 * @param {object} $http - Angular HTTP service.
 * @param {object} $q - jQuery.
 * @param {object} endpoints - Capture enpoints service.
 * @param {object} dialogs - Capture dialogs service.
 */

/**********************************************************************
* PC Recruiter AngularJS service
* Author: Justin Stull  
* Email: jstull@ringlead.com
* Version: 0.0.1

failCallback: function( errorMessage, statusCode (optional), other (optional) )

Minimum implementation:

- createRecord
- isLoggedIn
- login

**********************************************************************/
'use strict';

/* global angular: false */
/* global jQuery: false */
/* global geographyData: false */
/* global backgroundUtility: false */

angular.module('webServices')
.factory('pcrecruiter', ['$http', '$q', 'endpoints', 'dialogs', function ($http, $q, endpoints, dialogs) {

    var debug = 'pcrecruiter.js->';
    var defaultUrl = 'https://pcrecruiter.net';
    var store = {};
    var apiKey = 'fb1b376c2da9b062e49f7da0a3239ebb';
    var appId = '3823a7f1';

    /* Builds basic PC Recruiter REST url from provided Service URL and Team Pipeline ID*/
    var buildUrl = function (serviceUrl, body) {
        return serviceUrl + '/rest/api/' + body;
    };

    var getVenue = function (contact, filter) {
        if (contact.venues) {
            var i;
            for (i = 0; i < contact.venues.length; i++) {
                var w = contact.venues[i].website;
                console.log('*** VENUE ***', w);
                if (w && w.indexOf(filter) >= 0) {
                    return w;
                }
            }
        }
        return null;
    };
    var getCustomFieldValue = function (contact, fieldName) {
        if (contact.CustomFields) {
            var i;
            for (i = 0; i < contact.CustomFields.length; i++) {
                var w = contact.CustomFields[i].Values[0];
                if (w !== undefined && contact.CustomFields[i].FieldName === fieldName) {
                    return w;
                }
            }
        }
        return null;
    };



    /* Handles error response from PCRecruiter SAPI. It should try to return string message if provided. 
    *
    * r - HTTP response
    * asJson - if true, then error message will returns as JSON object, otherwise as String.
    */
    var handleErrorMessageText = function (r, asJson) {
        var status = r.status || 500;
        var msg = '';
        if (r.responseJSON) { msg = r.responseJSON; }
        else if (r.responseText) {
            try {
                msg = JSON.parse(r.responseText);
            } catch (err) {
                msg = r.responseText;
            }
        } else if (r.statusText) {
            msg = r.statusText;
        } else {
            msg = 'Unknown error';
        }
        if (asJson !== undefined) {
            return msg;
        } else {
            if (msg.hasOwnProperty('message')) { msg = msg.message; }
            return msg;
        }
    };

    var getDomain = function (website) {
        var regex = /([a-z0-9-]+)([.]([a-z]{1,3})(?![a-z-])){1,2}/ig;
        var d = regex.exec(website);
        if (d && d.length > 0) { d = d[0]; }
        if (d && d.length > 0) { d = d.toLowerCase(); }
        console.log('domain', d, 'website', website);
        return d;
    };

    var mapField = function (source, sourceKey, target, targetKey) {
        target[targetKey] = source[sourceKey];
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };
    var toContact = function (captureRecord) {

        console.log('000000000000000000 TO CONTACT 000000000000000000');

        if (debug) {
            console.log(debug + 'toContact:in', captureRecord);
        }

        var nativeRecord = {};
        nativeRecord.CustomFields = [];
        mapField(captureRecord, 'first', nativeRecord, 'FirstName');
        mapField(captureRecord, 'last', nativeRecord, 'LastName');
        mapField(captureRecord, 'jobtitle', nativeRecord, 'Title');
        mapField(captureRecord, 'email', nativeRecord, 'EmailAddress');
        mapField(captureRecord, 'phone', nativeRecord, 'WorkPhone');
        mapField(captureRecord, 'phone2', nativeRecord, 'MobilePhone');
        mapField(captureRecord, 'bio', nativeRecord, 'Notes');
        mapField(captureRecord, 'address1', nativeRecord, 'Address');
        mapField(captureRecord, 'city', nativeRecord, 'City');
        mapField(captureRecord, 'state', nativeRecord, 'State');
        mapField(captureRecord, 'zip', nativeRecord, 'PostalCode');
        mapField(captureRecord, 'country', nativeRecord, 'Country');

        nativeRecord.CustomFields.push({
            'FieldName': 'Referrer',
            'FieldType': '',
            'Values': ['Broadlook Capture']
        });

        nativeRecord.CustomFields.push({
            'FieldName': 'ReferrerSource',
            'FieldType': '',
            'Values': ['Broadlook Capture']
        });

        nativeRecord.CustomFields.push({
            'FieldName': 'Referrerdomain',
            'FieldType': '',
            'Values': [getDomain(captureRecord.sourceurl)]
        });

        if (captureRecord.linkedin) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_LinkedIn',
                'FieldType': '',
                'Values': [captureRecord.linkedin]
            });
        }

        if (captureRecord.facebook) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_Facebook',
                'FieldType': '',
                'Values': [captureRecord.facebook]
            });
        }

        if (captureRecord.twitter) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_Twitter',
                'FieldType': '',
                'Values': [captureRecord.twitter]
            });
        }

        if (captureRecord.googlePlus) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_GooglePlus',
                'FieldType': '',
                'Values': [captureRecord.googlePlus]
            });
        }

        if (captureRecord.myspace) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_MySpace',
                'FieldType': '',
                'Values': [captureRecord.myspace]
            });
        }

        if (captureRecord.pinterest) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_Pinterest',
                'FieldType': '',
                'Values': [captureRecord.pinterest]
            });
        }

        if (captureRecord.myLife) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_MyLife',
                'FieldType': '',
                'Values': [captureRecord.myLife]
            });
        }

        if (captureRecord.xing) {
            nativeRecord.CustomFields.push({
                'FieldName': 'Social_Xing',
                'FieldType': '',
                'Values': [captureRecord.xing]
            });
        }

        if (debug) {
            console.log(debug + 'toContact:out', nativeRecord);
        }

        return nativeRecord;
    };


    var fromContact = function (nativeRecord) {

        if (debug) {
            console.log(debug + 'fromContact:in', nativeRecord);
        }

        var captureRecord = {};
        captureRecord.venues = [];

        mapFromField(captureRecord, 'first', nativeRecord, 'FirstName');
        mapFromField(captureRecord, 'last', nativeRecord, 'LastName');
        mapFromField(captureRecord, 'jobtitle', nativeRecord, 'Title');
        mapFromField(captureRecord, 'email', nativeRecord, 'EmailAddress');
        mapFromField(captureRecord, 'phone', nativeRecord, 'WorkPhone');
        mapFromField(captureRecord, 'phone2', nativeRecord, 'MobilePhone');
        mapFromField(captureRecord, 'bio', nativeRecord, 'Notes');
        mapFromField(captureRecord, 'address1', nativeRecord, 'Address');
        mapFromField(captureRecord, 'city', nativeRecord, 'City');
        mapFromField(captureRecord, 'state', nativeRecord, 'State');
        mapFromField(captureRecord, 'zip', nativeRecord, 'PostalCode');
        mapFromField(captureRecord, 'country', nativeRecord, 'Country');

        var socialEndpoints = {
            linkedin: getCustomFieldValue(nativeRecord, 'Social_LinkedIn'),
            facebook: getCustomFieldValue(nativeRecord, 'Social_Facebook'),
            twitter: getCustomFieldValue(nativeRecord, 'Social_Twitter'),
            googlePlus: getCustomFieldValue(nativeRecord, 'Social_GooglePlus'),
            myspace: getCustomFieldValue(nativeRecord, 'Social_MySpace'),
            pinterest: getCustomFieldValue(nativeRecord, 'Social_Pinterest'),
            myLife: getCustomFieldValue(nativeRecord, 'Social_MyLife'),
            xing: getCustomFieldValue(nativeRecord, 'Social_Xing')
        };

        if (socialEndpoints.linkedin) {
            captureRecord.venues.push({ website: socialEndpoints.linkedin, type: 'social' });
        }
        console.log(socialEndpoints.facebook);
        if (socialEndpoints.facebook !== null) {
            captureRecord.venues.push({ website: socialEndpoints.facebook, type: 'social' });
        }
        if (socialEndpoints.twitter) {
            captureRecord.venues.push({ website: socialEndpoints.twitter, type: 'social' });
        }
        if (socialEndpoints.googlePlus) {
            captureRecord.venues.push({ website: socialEndpoints.googlePlus, type: 'social' });
        }
        if (socialEndpoints.myspace) {
            captureRecord.venues.push({ website: socialEndpoints.myspace, type: 'social' });
        }
        if (socialEndpoints.pinterest) {
            captureRecord.venues.push({ website: socialEndpoints.pinterest, type: 'social' });
        }
        if (socialEndpoints.myLife) {
            captureRecord.venues.push({ website: socialEndpoints.myLife, type: 'social' });
        }
        if (socialEndpoints.xing) {
            captureRecord.venues.push({ website: socialEndpoints.xing, type: 'social' });
        }
        if (debug) {
            console.log(debug + 'fromContact:venues', captureRecord.venues);
        }

        //mapFromField(captureRecord, 'sourceurl', nativeRecord, 'LinkedIn');
        //https://us.pipelinersales.com/rest_services/v1/us_BroadlookTechnologies1/Contacts/PY-7FFFFFFF-1DEAC92D-7169-465D-80D7-04B2ABD1DF16
        captureRecord._link = 'https://www2.pcrecruiter.net/pcrbin/editna.exe?i=' + store.username + '&i=' + nativeRecord.CandidateId + '&pcr-id=' + store.authId;
        captureRecord._type = 'Contact';
        captureRecord._id = nativeRecord.CandidateId;

        if (debug) {
            console.log(debug + 'fromContact:out', captureRecord);
        }

        return captureRecord;
    };


    /*
    * Returns default HTTP request template.
    *
    * method - called PCRecruiter REST method
    */
    var buildRequest = function (method, successCallback, failCallback) {
        return {
            type: 'GET',
            contentType: 'application/json',
            crossDomain: true,
            success: function (successResponse, textStatus, xhr) {
                successCallback(successResponse, textStatus, xhr);
            },
            error: function (errorResponse) {
                var response = handleErrorMessageText(errorResponse);
                failCallback(response, errorResponse.status || 500);
            }
        };
    };

    var service = {


        /**
        * @function getName
        * @description Return name of export target.
        * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
        */
        getName: function () {

            return 'PCRecruiter';
        },


        /**
        * @function init
        * @description Initializes store object. Sets user credentials, owner and team pipeline id.
        * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
        * @param {object} o - List of target-specific settings.
        */
        init: function (o) {

            if (debug) { console.log(debug + 'Initializing Login ...'); }
            console.log(o);
            store.username = encodeURIComponent(o.username);
            store.password = encodeURIComponent(o.password);
            store.pcrDatabaseId = o.pcrDatabaseId;

            console.log('STORE PASSWORD ->> ', store.password);
        },


        /**
        * @function login
        * @description Logs user in. Either silently (if possible) or interactively.
        * There is need to provide Username, Password, Database ID, API Key and App ID.
        * Follow 'http://www.pcrecruiter.net/apidocs_v2/ to see how to obtain the API key and App ID.
        * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - This callback informs that user was logged in successfully. 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - This callback informs that user cannot log in.
        */
        login: function (successCallback, failCallback, silent) {

            if (debug) { console.log(debug + 'Logging into PCRecruiter...'); }

            var username = store.username;
            var password = store.password;
            var pcrDatabaseId = store.pcrDatabaseId;

            var urlBody = 'access-token?DatabaseId=' + pcrDatabaseId + '&Username=' + username + '&Password=' + password + '&AppId=' + appId + '&ApiKey=' + apiKey;

            if (!username || !password || !pcrDatabaseId) {
                try { failCallback('Please open Settings and enter your user credentials'); } catch (e) { }
                return;
            }

            var openTab = function () {
                try {
                    // TODO validate the assumption that any pcrDatabaseId contains uid (before period) and that the url form is the same for all PCR users/orgs 
                    var uid = store.pcrDatabaseId.split('.')[0];
                    chrome.tabs.create({ url: 'https://www2.pcrecruiter.net/pcr.asp?uid=odbc.' + uid }, function () { });
                } catch (e) {

                }
            };

            var request = buildRequest('', successCallback, failCallback);
            request.url = buildUrl(defaultUrl, urlBody);
            request.success = function (successResponse, status, xhr) {
                var response = successResponse.SessionId;
                store.authId = response;

                if (silent === false) {
                    openTab();
                }
                successCallback(response);
            };
            jQuery.ajax(request);
            //$http
            //    .get(request.url)
            //    .success(function (response) { request.success(response); })
            //    .error(function (data, status, headers, config) {
            //        openTab();
            //    });
        },

        /**
         * @function logout
         * @description Logs user out. Cleans up store variable.I
         * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
         */
        logout: function () {

            var urlBody = 'access-token?SessionId=' + store.authId + '&AppId=' + appId + '&ApiKey=' + apiKey;

            var request = buildRequest('', function () { }, function () { });

            request.url = buildUrl(defaultUrl, urlBody);
            request.type = 'DELETE';
            jQuery.ajax(request);
            store = {};
            if (debug) { console.log(debug + 'Logged out...'); }
        },


        /**
         * @function isLoggedIn
         * @description Checks if user is logged in.
         * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInSuccessCallback} successCallback - This callback informs that user is currently logged in.
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInFailCallback} failCallback - This callback informs that user is not currently logged in.
         */
        isLoggedIn: function (successCallback, failCallback) {

            var isLogged = store.authId !== undefined ? true : false;

            if (debug) { console.log(debug + 'isLogged', isLogged); }

            if (!isLogged) {
                // Since we can do it... Do silent login.
                service.login(successCallback, failCallback);
            }
            else { try { successCallback(); } catch (e) { } }
        },


        /**
       * @function createRecord
       * @description Creates record.
       * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
       * @param {recordType} recordType - Destination Record Type
       * @param {captureContact} captureRecord - Source Capture Record.
       * @param {object} createOptions - Options (For future use)
       * @param {captureApp.webServices.exportTargetVer1~createRecordSuccessCallback} successCallback 
       * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
       */
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {


            if (debug) { console.log(debug + 'createRecord', captureRecord); }

            var createContact = function (nativeRecordType) {


                var record = {
                    'FirstName': (captureRecord.first || ''),
                    'LastName': (captureRecord.last || ''),
                    'EmailAddress': (captureRecord.email || ''),
                    'Title': (captureRecord.jobtitle || ''),
                    'WorkPhone': (captureRecord.phone || ''),
                    'MobilePhone': (captureRecord.phone2 || ''),
                    'Notes': 'Created by Broadlook Capture!' + '\n\n' + (captureRecord.bio || ''),
                    'Address': (captureRecord.address1 || '') + '\n' + (captureRecord.address2 || ''),
                    'City': (captureRecord.city || ''),
                    'State': (captureRecord.state || ''),
                    'PostalCode': (captureRecord.zip || ''),
                    'Country': (captureRecord.country || ''),
                    'CustomFields': [
                        {
                            'FieldName': 'ReferrerSource',
                            'FieldType': '',
                            'Values': ['Added by Broadlook Capture']
                        },
                        {
                            'FieldName': 'Referrer',
                            'FieldType': '',
                            'Values': ['Added by Broadlook Capture']
                        },
                        {
                            'FieldName': 'ReferrerDomain',
                            'FieldType': '',
                            'Values': [getDomain(captureRecord.sourceurl)]
                        },
                        {
                            'FieldName': 'Email_Other',
                            'FieldType': '',
                            'Values': [(captureRecord.email2 || '')]
                        },
                        {
                            'FieldName': 'Social_LinkedIn',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'linkedin.com') || '')]
                        },
                        {
                            'FieldName': 'Social_Twitter',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'twitter.com') || '')]
                        },
                        {
                            'FieldName': 'Social_Facebook',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'facebook.com') || '')]
                        },
                        {
                            'FieldName': 'Social_GooglePlus',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'google.com') || '')]
                        },
                        {
                            'FieldName': 'Social_MySpace',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'myspace.com') || '')]
                        },
                        {
                            'FieldName': 'Social_Pinterest',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'pinterest.com') || '')]
                        },
                        {
                            'FieldName': 'Social_MyLife',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'mylife.com') || '')]
                        },
                        {
                            'FieldName': 'Social_Xing',
                            'FieldType': '',
                            'Values': [(getVenue(captureRecord, 'xing.com') || '')]
                        }

                    ]
                };

                if (createOptions && createOptions.mappedProperties) {
                    var j = createOptions.mappedProperties.length;
                    while (j--)
                    { record[createOptions.mappedProperties[j].name] = createOptions.mappedProperties[j].value; }
                }

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                //var successCallback2 = function (successResponse, textStatus, xhr) {

                //if (debug) { console.log(debug + 'response', successResponse); }
                /*var urlBody = 'candidates';
                var request = buildRequest(nativeRecordType, successCallback, failCallback);
                request.beforeSend = function (xhr) {
                    xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                request.url = buildUrl(defaultUrl, urlBody);
                request.type = 'POST';
                request.data = JSON.stringify(record);
                jQuery.ajax(request);*/

                var url = buildUrl(defaultUrl, 'candidates');

                var config = {
                    headers: {
                        'Authorization': 'BEARER ' + store.authId
                    }
                };

                $http.post(url, record, config)
                    .success(function (data, status, headers, config) {
                        if (debug) { console.log(debug + 'response', data, status); }
                        var id = data.CandidateId;
                        //https://www2.pcrecruiter.net/pcrbin/editna.exe?i=ADMIN&i=112989394441873&i=List&i=153172544917257&i=Edit&i=3%2F13%2F2015%2011:30:41%20AM&i=7&i=8&i=9&i=&pcr-id=lqd1cK4ZIMDUIh9teyKTeoHazrDUnxqp3hCac6qtOfu4lQefyDnWn%2BJ9XqpPlxgw9uztSKO%2F1vsK
                        //https://www2.pcrecruiter.net/pcrbin/editna.exe?username=ADMIN&nameGUID=112989394441873&menuSelection=xyz&pageLayout=&i5=xyz&i6=NEWACT&i7=&baseurl=&authresult=&databaseName=&pcr-id=1XOCgeYgn6jzu9P4vCaQc3lLdQhHQiZIXaAJYkp6X%2FrrT%2BxIiZaG%2BFb%2FvoYuGOVEqlQEF4aH5msH
                        // pcr-id is our authId... will be different every session TODO: Open link should grab fresh one every time (contact.ui.js)
                        var link = 'https://www2.pcrecruiter.net/pcrbin/editna.exe?i=' + store.username + '&i=' + id + '&pcr-id=' + store.authId;
                        console.log('**** LINK', link);
                        try { successCallback(link, id); } catch (e) { }
                    })
                    .error(function (data, status, headers, config) {
                        console.log(debug + 'ERROR in POST', data, status, headers, config);
                        try { failCallback(); } catch (e) { }
                    });

            };

            var createCompany = function (nativeRecordType) {


                var record = {
                    'CompanyName': (captureRecord.company || ''),
                    'Phone': (captureRecord.phone || ''),
                    'Address': (captureRecord.address1 || '') + '\n' + (captureRecord.address2 || ''),
                    'City': (captureRecord.city || ''),
                    'State': (captureRecord.state || ''),
                    'PostalCode': (captureRecord.zip || ''),
                    'Country': (captureRecord.country || '')
                };

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    if (debug) { console.log(debug + 'response', successResponse); }

                    var id = successResponse.CompanyId;
                    var link = '';

                    try { successCallback(link, id); } catch (e) { }
                };
                var urlBody = 'companies';
                var request = buildRequest(nativeRecordType, successCallback2, failCallback);
                request.beforeSend = function (xhr) {
                    xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                };
                request.url = buildUrl(defaultUrl, urlBody);
                request.type = 'POST';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                createContact('Contacts');
            } else if (recordType.toUpperCase() === 'ACCOUNT') {
                createCompany('Account');
            } else {
                failCallback('Invalid record type: ' + (recordType || 'Null'));
            }

        },


        /**
        * @function updateRecord
        * @description Updates record.
        * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
        * @param {string} recordId - Record ID
        * @param {recordType} recordType - Record Type ('lead', 'contact' or 'account')
        * @param {object} record - Native record. Include only fields to be updated. 
        * @param {captureApp.webServices.exportTargetVer1~updateRecordSuccessCallback} successCallback 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
        */
        updateRecord: function (recordId, recordType, record, successCallback, failCallback) {


            if (debug) { console.log(debug + 'updateRecord', recordId, recordType, record); }

            var updateContact = function (nativeRecordType) {

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    if (debug) { console.log(debug + 'response', successResponse); }

                    try { successCallback(recordId); } catch (e) { }
                };

                var buildRequest2 = function (method, id, successCallback, failCallback) {
                    var urlBody = 'candidates';
                    return {
                        type: 'GET',
                        url: buildUrl(defaultUrl, urlBody) + '/' + id,
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {
                            var response = handleErrorMessageText(errorResponse);
                            failCallback(response, errorResponse.status || 500);
                        }
                    };
                };

                var request = buildRequest2(nativeRecordType, recordId, successCallback2, failCallback);
                request.type = 'PUT';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                updateContact('Contacts');
            } else {
                failCallback('Invalid record type');
            }

        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {
            //if (debug) { console.log(debug + 'toLookupObject->entityType', entityType, '->crmObject', crmObject); }


            var lookupObject = { label: '', link: '' };

            try {
                if (entityType.toLowerCase() === 'account') {
                    var cityState = '';
                    if (crmObject && (crmObject.City || crmObject.State)) {
                        cityState = ' (' + (crmObject.City || '') + ((crmObject.City && crmObject.State) ? ', ' : '') + (crmObject.State || '') + ')';
                    }
                    lookupObject.label = (crmObject.CompanyName || '(no name)') + cityState;
                    lookupObject.link = 'https://www2.pcrecruiter.net/pcrbin/editco.exe?i=' + store.username + '&i=' + crmObject.CompanyId + '&pcr-id=' + store.authId;
                    lookupObject.id = crmObject.CompanyId;
                }
            } catch (e) {
                console.log('ERROR in toLookupObject', e.message);
            }

            //if (debug) { console.log(debug + 'toLookupObject->result', lookupObject); }
            return lookupObject;
        },

        /**
        * @function getRequiredLookups
        * @description Returns an array of lookups required prior to saving a record .
        * @memberOf captureApp.webServices.exportTargetVer1.pcrecruiter
        * @param {recordType} recordType - Record type 
        * @return {captureApp.webServices.exportTargetVer1~lookup[]}
        */
        getRequiredLookups: function (entityType, actualMap) {



            entityType = entityType.toLowerCase();

            if (actualMap) {

                if (debug) { console.log(debug + 'getRequiredLookups->map', actualMap); }

                var aa = [];

                // convert map def to lookup def

                for (var i = 0, l = actualMap.fields.length; i < l; i++) {
                    var f = actualMap.fields[i];
                    if (f.source && (f.source.type === 'lookup' || f.source.type === 'picklist' || f.source.type === 'action')) {

                        if (f.source && f.source.value && f.source.value.enabled === false) {
                            console.log('disabled action', angular.copy(f));
                            continue;
                        }

                        var a;

                        if (f.source.value) {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: f.source.value.appProperty,
                                message: f.source.value.message,
                                type: f.source.value.type,
                                defaultValue: f.source.value.defaultValue ? { id: f.source.value.defaultValue.value, label: f.source.value.defaultValue.label } : null,
                                required: f.source.value.required,
                                allowNew: f.source.value.allowNew,
                                picklist: f.source.value.picklist || f.source.type === 'picklist',
                                resolve: f.source.value.resolve,
                                hidden: f.source.value.hidden
                            };
                        } else {
                            a = {
                                crmProperty: f.target.name,
                                appProperty: '',
                                message: '',
                                type: '',
                                defaultValue: '',
                                required: false,
                                allowNew: false,
                                picklist: f.source.type === 'picklist',
                                resolve: null,
                            };
                        }

                        if (f.source.type === 'picklist') {
                            a.type = entityType;
                            a.allowNew = false;
                        }


                        aa.push(a);
                    }
                }

                if (debug) { console.log(debug + 'getRequiredLookups->result', aa); }

                return aa;
            }

            if (entityType === 'contact') {



                return [{ crmProperty: 'CompanyId', appProperty: 'company', message: 'Select Company', type: 'Account', required: false, allowNew: true, resolve: 'createNewAccount', noLabel: 'Default for Candidates' }
                    //,
                    //    { crmProperty: 'OwnerId', appProperty: 'full', message: 'Select account owner', type: 'SystemUser', required: false, allowNew: false }
                ];
            }
            if (entityType === 'lead') {
                //return [{
                //    crmProperty: 'Campaign', appProperty: 'campaign', message: 'Select Campaign', type: 'Campaign', required: false, allowNew: false,
                //    resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //        service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    },
                //}, {
                //    crmProperty: 'LeadSource', appProperty: null, message: 'Select Lead Source', type: 'Lead', required: true, allowNew: false,
                //    picklist: true//,
                //    //resolve: function (service, lookupId, objectId, successCallback, failCallback) {
                //    //    console.log('resolve called', lookupId, objectId)
                //    //    //service.createRecord({ type: 'CampaignMember', record: { CampaignId: lookupId, LeadId: objectId } }, successCallback, failCallback);
                //    //},
                //}];
            }
            if (entityType === 'account') { return []; }
            return [];
        },

        resolveLookup: function (actionId, lookupId, objectId, successCallback, failCallback) {


            console.log(debug + 'resolveLookup->action->', actionId);
            console.log(debug + 'resolveLookup->lookup->', lookupId);
            console.log(debug + 'resolveLookup->object->', objectId);

            if (actionId === 'createNewAccount') {

                console.log('NEW ACCOUNT', lookupId);

                if (!lookupId.newName) {
                    // existing account, quit
                    try { successCallback(); } catch (e) { }
                    return;
                }

                var createSourceRecord = angular.copy(lookupId.record);
                createSourceRecord.company = lookupId.newName;

                service.createRecord('Account', createSourceRecord, null,

                    // created successfully
                    function (accountLink, accountId) {
                        console.log('account was created', accountLink, accountId);
                        var updateData = {};
                        updateData[lookupId.crmProperty] = accountId;
                        // update the new candidate
                        service.updateRecord(objectId, 'Contact', updateData, successCallback, failCallback);
                    },

                    // create failed
                    function (msg) {
                        console.log('account was not created', msg);
                        failCallback('Account was not created');
                    }

                );

            } else {

                console.log('ERROR: Unknown action', lookupId);
                failCallback('Unknown action');

            }

        },


        /**
        * @function getDefaultExportMaps
        * @description (Reserved for future use) Return an empty array. 
        * maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefaultExportMaps: function (successCallback, failureCallback) {


            var maps = [];

            //maps.push({ name: 'contact', label: 'Contact', map: null });

            successCallback(maps);
        },


        /**
        * @function getDefinition
        * @description Returns configuration for Multi-Merge dialog. 
        * How to modify:
        * 1. Put native field names in def.fields.map.{Field}.id
        * 2. Remove lines that do not have corresponding native fields, or where fields are read-only
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {string} recordType - 'lead', 'contact' or 'account'. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefinition: function (recordType, successCallback, failureCallback) {



            if (debug) { console.log(debug + 'getDefinition', recordType); }


            var def = {};
            recordType = recordType.toLowerCase();
            /*if (recordType === 'lead') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { display: 'First Name', group: 'G1' },
                            'LastName': { display: 'Last Name', group: 'G1' },
                            'Title': { display: 'Job Title', group: 'G1' },
                            'Company': { display: 'Company', group: 'G1' },
                            'Email': { display: 'Email', group: 'G1' },
                            'Phone': { display: 'Phone', group: 'G1' },
                            'MobilePhone': { display: 'Mobile Phone', group: 'G1' },
                            'Website': { display: 'Website', group: 'G1' },
                            'Description': { display: 'Description', group: 'G1' },

                            'Street': { display: 'Street', group: 'G2' },
                            'City': { display: 'City', group: 'G2' },
                            'State': { display: 'State/Province', group: 'G2' },
                            'PostalCode': { display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { display: 'Country', group: 'G2' },
                        }
                    }
                };

            } else*/ if (recordType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description', 'Linkedin', 'Facebook', 'Twitter', 'GooglePlus', 'Myspace', 'Pinterest', 'MyLife', 'Xing'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Email', 'Phone', 'MobilePhone', 'Description', 'Linkedin', 'Facebook', 'Twitter', 'GooglePlus', 'Myspace', 'Pinterest', 'MyLife', 'Xing', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'FirstName', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'LastName', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'Title', display: 'Position', group: 'G1' },
                            //'Company': { id: 'QUICK_ACCOUNT_NAME', display: 'Company', group: 'G1' },
                            'Email': { id: 'EmailAddress', display: 'Email 1', group: 'G1' },
                            'Phone': { id: 'WorkPhone', display: 'Work Phone', group: 'G1' },
                            'MobilePhone': { id: 'MobilePhone', display: 'Phone 2', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Description': { id: 'Notes', display: 'Comments', group: 'G1' },
                            'Linkedin': { id: 'linkedin', display: 'Linkedin', group: 'G1' },
                            'Facebook': { id: 'facebook', display: 'Facebook', group: 'G1' },
                            'Twitter': { id: 'twitter', display: 'Twitter', group: 'G1' },
                            'GooglePlus': { id: 'googlePlus', display: 'Google+', group: 'G1' },
                            'Myspace': { id: 'myspace', display: 'Myspace', group: 'G1' },
                            'Pinterest': { id: 'pinterest', display: 'Pinterest', group: 'G1' },
                            'MyLife': { id: 'myLife', display: 'My Life', group: 'G1' },
                            'Xing': { id: 'xing', display: 'Xing', group: 'G1' },

                            'Street': { id: 'Address', display: 'Address', group: 'G2' },
                            'City': { id: 'City', display: 'City', group: 'G2' },
                            'State': { id: 'State', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'PostalCode', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },


        /**
        * @function toNativeRecord
        * @description Converts Capture Contact to native record. 
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {captureContact} captureRecord - Capture Contact
        * @param {recordType} recordType - Record type. 
        * @return {object} - Native record
        */
        toNativeRecord: function (captureRecord, recordType) {


            recordType = recordType.toLowerCase();
            if (recordType === 'contact') { return toContact(captureRecord); }
            return null;
        },


        /**
        * @function fromNativeRecord
        * @description Converts native record to Capture Contact. 
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {object} nativeRecord - Native record
        * @param {recordType} recordType - Record type. 
        * @return {captureContact} - Capture Contact
        */
        fromNativeRecord: function (nativeRecord, recordType) {


            recordType = recordType.toLowerCase();
            if (recordType === 'contact') { return fromContact(nativeRecord); }
            return null;
        },


        /**
        * @function findDuplicates
        * @description Returns an array of duplicate records of given type.
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {captureContact} recordType - Record type. 
        * @param {captureContact} captureRecord - Source Capture Contact. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the resulting array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback  
        * @return {captureContact[]} - Array of Capture Contacts
        */
        findDuplicates: function (recordType, captureRecord, successCallback, failCallback) {


            if (debug) { console.log(debug + 'findcoDuplicates', recordType, captureRecord); }


            var findContact = function () {

                if (debug) { console.log(debug + 'findContact', angular.copy(captureRecord)); }

                var filter = '?query=FirstName eq ' + (captureRecord.first || '') + ' AND LastName eq ' + (captureRecord.last || '');

                if (debug) { console.log(debug + 'filter', filter); }

                var successCallback2 = function (successResponse, textStatus, xhr) {


                    if (debug) { console.log(debug + 'response', successResponse); }

                    var dups = [];
                    console.log(successResponse.Results.length);
                    if (successResponse.TotalRecords > 0) {
                        for (var i = 0; i < successResponse.Results.length; i++) {
                            var dup;
                            dup = fromContact(successResponse.Results[i]);
                            dups.push(dup);
                        }
                    }
                    if (debug) { console.log(debug + 'List Dups', dups); }
                    try { successCallback({ duplicates: dups }); } catch (e) { }
                };

                var buildRequest2 = function (method, filter, successCallback, failCallback) {
                    var urlBody = 'candidates';
                    return {
                        type: 'GET',
                        url: buildUrl(defaultUrl, urlBody) + filter,
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            console.log('Duplicates Found');
                            console.log(successResponse);
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {

                            console.log(errorResponse);
                            var response = handleErrorMessageText(errorResponse);

                            failCallback(response, errorResponse.status || 500);
                        }
                    };

                };

                var request = buildRequest2(recordType, filter, successCallback2, failCallback);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                recordType = 'Contacts';
                findContact();
            } else {
                try { successCallback({ duplicates: [] }); } catch (e) { }
            }

        },

        /*findDuplicates: function (recordType, contact, successCallback, failCallback) {

            var encode = function (s) {
                if (typeof s === 'undefined') { s = ''; }
                return s.replace(/'/g, '\\\'');
            };

            if (recordType === 'contact') { recordType = 'Contact'; }

            var fields = 'ID,LastName,FirstName,Email,Company,Phone,Title';
            if (recordType === 'Contact') { fields = 'ID,LastName,FirstName,Email,Title,Phone,Account.Name'; }

            var from = recordType;
            if (recordType === 'Contact')
            { from = 'Contact,Contact.Account'; }

            var where = '';

            var dups = [];

            var reponseHandle = null;
            var returnResponse = function() {
                try {
                    successCallback({ duplicates: dups });
                } catch (e) {}
            };

            var query = function (q) {
                var urlBody = 'candidates';

                try {

                    //calls Salesforce REST API with jQuery
                    jQuery.ajax({
                        type: 'GET',
                        url: buildUrl(defaultUrl, urlBody),
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                            xhr.setRequestHeader('Accept', 'application/json');
                        },
                        success: function (sfdata) {
                            console.log('findDuplicates results', sfdata);

                            if (!sfdata.records)
                            { try { failCallback(); } catch (e) { } }

                            
                            for (var i = 0; i < sfdata.records.length; i++) {
                                var dup = {};
                                if (recordType === 'Lead') { dup = service.fromLead(sfdata.records[i]); }
                                else if (recordType === 'Contact') { dup = service.fromContact(sfdata.records[i]); }
                                dups.push(dup);
                            }

                            if (reponseHandle) {
                                window.clearTimeout(reponseHandle);
                            }
                            reponseHandle = window.setTimeout(returnResponse, 2000);

                        },
                        failure: function (error) {
                            console.log('ERROR in findDuplicates', error);
                            try { failCallback(); } catch (e) { }
                        }
                    });

                } catch (e) {
                    console.log('ERROR in query', e.message);
                    try { failCallback(); } catch (e) { }
                }

            };

            if (recordType.toUpperCase() === 'CONTACT') {
                query('?query=FirstName eq ' + (captureRecord.first || '') + ' AND LastName eq ' + (captureRecord.last || ''));
            }

            //if (contact.phone && contact.last) {
            //    where = 'LastName=\'' + encode(contact.last) + '\'+AND+Phone=\'' + encode(contact.phone) + '\'';
            //    if (recordType === 'Lead')
            //    { where += '+AND+IsConverted=False'; }
            //    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
            //}

            //if (contact.email2) {
            //    where = 'Email=\'' + contact.email2 + '\'';
            //    if (recordType === 'Lead')
            //    { where += '+AND+IsConverted=False'; }
            //    query('SELECT+' + fields + '+FROM+' + from + '+WHERE+' + where + '+LIMIT+5');
            //}


        },*/



        findRecord: function (recordType, query, fields, successCallback, failCallback) {


            //var service = this;             
            var urlBody;
            var encodeParam = function (p) {
                return p.replace(/'/g, '%5C%27');
            };

            if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

            if (recordType === 'account') { recordType = 'Account'; }
            if (recordType === 'lead') { recordType = 'Lead'; }
            if (recordType === 'contact') { recordType = 'Contact'; }
            if (recordType === 'campaign') { recordType = 'Campaign'; }

            var where = [];

            if (query) {

                if (query.email)
                { where.push('Email=\'' + encodeParam(query.email) + '\''); }

                if (query.email_endsWith)
                { where.push('Email+LIKE+\'%25' + encodeParam(query.email_endsWith) + '\''); }

                if (query.last)
                { where.push('LastName=\'' + encodeParam(query.last) + '\''); }

                if (query.first)
                { where.push('FirstName=\'' + encodeParam(query.first) + '\''); }

                if (recordType === 'Account') {
                    if (query.company)
                    { where.push('Name+LIKE+\'%25' + encodeParam(query.company) + '%25\''); }
                }

                if (recordType === 'Campaign') {
                    if (query.campaign)
                    { where.push('Name+LIKE+\'%25' + encodeParam(query.campaign) + '%25\''); }
                }

            }
            var whereStr = where.join('+AND+');
            if (whereStr) { whereStr = '+WHERE+' + whereStr; } else { whereStr = '+'; }
            console.log(whereStr);

            var fieldsStr = '*';
            var f;


            if (recordType === 'Account') {
                urlBody = 'companies?Query=CompanyName eq ' + query.company;
                f = [];

                f.push('ID');

                if (fields.indexOf('company') > -1) { f.push('Name'); }
                if (fields.indexOf('website') > -1) { f.push('Website'); }
                if (fields.indexOf('_createdDate') > -1) { f.push('CreatedDate'); }

                f.push('BillingCity');
                f.push('BillingState');

                fieldsStr = f.join(',');
            }

            if (recordType === 'Contact') {
                urlBody = 'candidates';
                f = [];

                f.push('ID');

                if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                if (fields.indexOf('last') > -1) { f.push('LastName'); }
                if (fields.indexOf('email') > -1) { f.push('Email'); }
                //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                fieldsStr = f.join(',');
            }

            if (recordType === 'Lead') {
                f = [];

                f.push('ID');

                if (fields.indexOf('first') > -1) { f.push('FirstName'); }
                if (fields.indexOf('last') > -1) { f.push('LastName'); }
                if (fields.indexOf('email') > -1) { f.push('Email'); }
                //if (fields.indexOf('middle') > -1) { f.push('MiddleName '); }

                fieldsStr = f.join(',');
            }

            if (recordType === 'Campaign') {

                f = [];

                f.push('ID');
                f.push('Name');

                fieldsStr = f.join(',');
            }

            var headers = { 'Content-type': 'application/json', 'Authorization': 'BEARER ' + store.authId, 'Accept': 'application/json' };
            var config = {
                method: 'GET',
                url: buildUrl(defaultUrl, urlBody),
                headers: headers
            };
            if (debug) { console.log(debug + 'findRecord->config:', config); }

            var allRecords = [];

            var errorHandler = function (response, status) {

                if (debug) { console.log(debug + 'findRecord->failResponse', response); }
                var msg = '';
                if (response && response.length > 0) {

                    if (response[0].errorCode === 'INVALID_SESSION_ID') {
                        console.log(service);
                        service.logout();
                        failCallback('Session expired. Please log in.');
                    }

                    var i = 0;
                    while (i < response.length) {
                        if (response[i].message)
                        { msg += response[i].message + ' '; }
                        i++;
                    }
                }
                try { failCallback('Cannot find PCRecruiter record: (' + status + ') ' + (msg || response)); } catch (e) { }

            };

            var successHandler = function (response) {

                if (debug) { console.log(debug + 'findRecord->successResponse', response); }

                allRecords = allRecords.concat(response.Results);

                /*if (!response.done && response.nextRecordsUrl) {
                    config.url = store.url + response.nextRecordsUrl;
                    $http(config).success(successHandler).error(errorHandler);
                }
                else { try { successCallback(allRecords); } catch (e) { } }
                */
                try { successCallback(allRecords); } catch (e) { }
            };

            $http(config).success(successHandler).error(errorHandler);

        },

        /**
        * @function retrieveRecord
        * @description Returns single recor.
        * @memberOf captureApp.webServices.exportTargetVer1.pipeliner
        * @param {string} recordId - Record ID 
        * @param {recordType} recordType - Record type
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the native record as a parameter
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - Return error message
        */
        retrieveRecord: function (recordId, recordType, successCallback, failCallback) {

            if (recordType.toLowerCase() === 'lead') { recordType = 'Leads'; }
            if (recordType.toLowerCase() === 'contact') { recordType = 'Contacts'; }

            var buildRequest2 = function (method, id, successCallback, failCallback) {
                var urlBody = 'candidates';
                console.log('PCR ID --> ' + id);
                return {
                    type: 'GET',
                    url: buildUrl(defaultUrl, urlBody) + '/' + id + '?custom=Social_LinkedIn,Social_Facebook,Social_Twitter,Social_GooglePlus,Social_MySpace,Social_Pinterest,Social_MyLife,Social_Xing',
                    contentType: 'application/json',
                    crossDomain: true,
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader('Authorization', 'BEARER ' + store.authId);
                    },
                    success: function (successResponse, textStatus, xhr) {
                        successCallback(successResponse, textStatus, xhr);
                    },
                    error: function (errorResponse) {
                        var response = handleErrorMessageText(errorResponse);
                        failCallback(response, errorResponse.status || 500);
                    }
                };
            };

            var successCallback2 = function (successResponse, textStatus, xhr) {

                if (debug) { console.log(debug + 'response', successResponse); }

                try { successCallback(successResponse); } catch (e) { }
            };

            var request = buildRequest2(recordType, recordId, successCallback2, failCallback);

            jQuery.ajax(request);
        },


        /*
        * Returns JSON with all Team Pipeline Clients. Function is supposed to help obtain value for OWNER_ID field.
        * E.g.: {
        *   "Stefan Smihla (stefan.smihla@pipelinersales)": 12345,
        *   "Example User (example@user.com)": 56789
        * }
        */
        getClients: function (successCallback, failCallback) {

            if (debug) { console.log(debug + 'getClients'); }

            var successFunc = function (successResponse) {
                var clients = {};
                for (var i in successResponse) {
                    var item = successResponse[i];
                    var firstname = item.FIRSTNAME || '';
                    var surname = item.LASTNAME || '';
                    var fullname = firstname + ' ' + surname + ' (' + item.EMAIL + ')';
                    clients[fullname] = item.ID;
                }
                //successCallback(JSON.stringify(clients));
                successCallback(clients);
            };

            service.getEntities('Clients', successFunc, failCallback);
        },

        /* Sets Sales Unit ID. This value will be needed fpr required SALES_UNIT_ID. */
        setSalesUnit: function (salesUnit) {
            store.salesUnit = salesUnit;
        },

        getEntities: function (nativeRecordType, successCallback, failCallback) {

            if (debug) { console.log(debug + 'getEntities', nativeRecordType); }

            var request = buildRequest(nativeRecordType, successCallback, failCallback);
            request.success = successCallback;
            jQuery.ajax(request);
        },

    };

    return service;
}]);
/**
 * @class captureApp.webServices.pipeliner
 * @memberOf captureApp.webServices
 * @description This is Pipeliner CRM AngularJS service.
 */

'use strict';

/* global angular: false */
/* global jQuery: false */

angular.module('webServices')
.factory('pipeliner', ['$http', '$q', 'endpoints', 'dialogs', function ($http, $q, endpoints, dialogs) {
    //app.factory('pipeliner', ['$http', '$q', 'endpoints', 'dialogs', function ($http, $q, endpoints, dialogs) {
    var debug = 'pipeliner.js->';
    var defaultUrl = 'https://us.pipelinersales.com';
    var store = {};

    /* Builds basic Pipeliner REST url from provided Service URL and Team Pipeline ID */
    var buildUrl = function (serviceUrl, teamPipelineId) {
        console.log('Pipeliner Build URL > ', serviceUrl, ' > Team Pipeline ID > ', teamPipelineId);
        return serviceUrl + '/rest_services/v1/' + teamPipelineId;
    };

    /* 
    * Handles error response from Pipeliner SAPI. It should try to return string message if provided. 
    *
    * r - HTTP response
    * asJson - if true, then error message will returns as JSON object, otherwise as String.
    */
    var handleErrorMessageText = function (r, asJson) {
        var status = r.status || 500;
        var msg = '';
        if (r.responseJSON) { msg = r.responseJSON; }
        else if (r.responseText) {
            try {
                msg = JSON.parse(r.responseText);
            } catch (err) {
                msg = r.responseText;
            }
        } else if (r.statusText) {
            msg = r.statusText;
        } else {
            msg = 'Unknown error';
        }
        if (asJson !== undefined) {
            return msg;
        } else {
            if (msg.hasOwnProperty('message')) { msg = msg.message; }
            return msg;
        }
    };


    var mapField = function (source, sourceKey, target, targetKey) {
        var sourceKeyParts = sourceKey.split('.');
        if (sourceKeyParts.length === 2) {
            try {
                target[targetKey] = source[sourceKeyParts[0]][sourceKeyParts[1]];
            } catch (e) {
                target[targetKey] = null;
            }
        }
        else { target[targetKey] = source[sourceKey]; }
    };
    var mapFromField = function (target, targetKey, source, sourceKey) {
        mapField(source, sourceKey, target, targetKey);
    };
    var toContact = function (captureRecord) {

        if (debug) {
            console.log(debug + 'toContact:in', captureRecord);
        }

        var nativeRecord = {};
        mapField(captureRecord, 'first', nativeRecord, 'FIRST_NAME');
        mapField(captureRecord, 'last', nativeRecord, 'SURNAME');
        mapField(captureRecord, 'jobtitle', nativeRecord, 'POSITION');
        mapField(captureRecord, 'email', nativeRecord, 'EMAIL1');
        mapField(captureRecord, 'phone', nativeRecord, 'PHONE1');
        mapField(captureRecord, 'phone2', nativeRecord, 'PHONE2');
        mapField(captureRecord, 'bio', nativeRecord, 'COMMENTS');
        mapField(captureRecord, 'address1', nativeRecord, 'ADDRESS');
        mapField(captureRecord, 'city', nativeRecord, 'CITY');
        mapField(captureRecord, 'state', nativeRecord, 'STATE_PROVINCE');
        mapField(captureRecord, 'zip', nativeRecord, 'ZIP_CODE');
        mapField(captureRecord, 'country', nativeRecord, 'COUNTRY');

        if (debug) {
            console.log(debug + 'toContact:out', nativeRecord);
        }

        return nativeRecord;
    };
    var fromContact = function (nativeRecord) {

        if (debug) {
            console.log(debug + 'fromContact:in', nativeRecord);
        }

        var captureRecord = {};
        mapFromField(captureRecord, 'first', nativeRecord, 'FIRST_NAME');
        mapFromField(captureRecord, 'last', nativeRecord, 'SURNAME');
        mapFromField(captureRecord, 'jobtitle', nativeRecord, 'POSITION');
        mapFromField(captureRecord, 'company', nativeRecord, 'QUICK_ACCOUNT_NAME');
        mapFromField(captureRecord, 'email', nativeRecord, 'EMAIL1');
        mapFromField(captureRecord, 'phone', nativeRecord, 'PHONE1');
        mapFromField(captureRecord, 'phone2', nativeRecord, 'PHONE2');
        mapFromField(captureRecord, 'bio', nativeRecord, 'COMMENTS');
        mapFromField(captureRecord, 'address1', nativeRecord, 'ADDRESS');
        mapFromField(captureRecord, 'city', nativeRecord, 'CITY');
        mapFromField(captureRecord, 'state', nativeRecord, 'STATE_PROVINCE');
        mapFromField(captureRecord, 'zip', nativeRecord, 'ZIP_CODE');
        mapFromField(captureRecord, 'country', nativeRecord, 'COUNTRY');
        //mapFromField(captureRecord, 'sourceurl', nativeRecord, 'LinkedIn');
        //https://us.pipelinersales.com/rest_services/v1/us_BroadlookTechnologies1/Contacts/PY-7FFFFFFF-1DEAC92D-7169-465D-80D7-04B2ABD1DF16
        captureRecord._link = store.url + '/Contacts/' + nativeRecord.ID;
        captureRecord._type = 'Contact';
        captureRecord._id = nativeRecord.ID;

        if (debug) {
            console.log(debug + 'fromContact:out', captureRecord);
        }

        return captureRecord;
    };


    /*
    * Returns default HTTP request template.
    *
    * method - called Pipeliner REST method
    */
    var buildRequest = function (method, successCallback, failCallback) {
        return {
            type: 'GET',
            url: store.url + '/' + method,
            contentType: 'application/json',
            crossDomain: true,
            beforeSend: function (xhr) {
                xhr.setRequestHeader('Authorization', store.auth);
            },
            success: function (successResponse, textStatus, xhr) {
                try { successCallback(successResponse, textStatus, xhr); } catch (e) { }

            },
            error: function (errorResponse) {
                var response = handleErrorMessageText(errorResponse);
                try { failCallback(response, errorResponse.status || 500); } catch (e) { }
            }
        };
    };

    var service = {


        /**
        * @function getName
        * @description Return name of export target.
        * @memberOf captureApp.webServices.pipeliner
        */
        getName: function () {
            return 'Pipeliner';
        },


        /**
        * @function init
        * @description Initializes store object. Sets user credentials, owner and team pipeline id.
        * @memberOf captureApp.webServices.pipeliner
        * @param {object} o - List of target-specific settings.
        */
        init: function (o) {
            store.username = o.username;
            store.password = o.password;
            store.teamPipelineId = o.teamPipelineId;
            store.ownerId = o.ownerId;
        },


        /**
        * @function login
        * @description Logs user in. Either silently (if possible) or interactively.
        * There is need to provide API Token, API Password and Team Pipeline ID
        * Follow 'http://help.pipelinersales.com/integration/pipeliner-crm-api-key/' to see how to obtain it.
        * @memberOf captureApp.webServices.pipeliner
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - This callback informs that user was logged in successfully. 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - This callback informs that user cannot log in.
        */
        login: function (successCallback, failCallback) {
            if (debug) { console.log(debug + 'Logging into Pipeliner...'); }

            var username = store.username;
            var password = store.password;
            var teamPipelineId = store.teamPipelineId;

            if (!username || !password || !teamPipelineId) {
                try { failCallback('Please open Settings and enter your user credentials'); } catch (e) { }
                return;
            }

            store.auth = 'Basic ' + btoa(username + ':' + password);
            var request = buildRequest('', successCallback, failCallback);

            request.url = buildUrl(defaultUrl, teamPipelineId) + '/teamPipelineUrl';
            request.success = function (successResponse) {
                console.log('Pipeliner Login Response > ', successResponse);
                var response = successResponse.substring(1, successResponse.length - 1);
                if (successResponse[0] === 'h') {
                    response = successResponse.substring(0, successResponse.length - 1);
                }
                store.url = buildUrl(response, teamPipelineId);
                successCallback(response);
            };

            jQuery.ajax(request);
        },

        /**
         * @function logout
         * @description Logs user out. Cleans up store variable.
         * @memberOf captureApp.webServices.pipeliner
         */
        logout: function () {
            store = {};
            if (debug) { console.log(debug + 'Logged out...'); }
        },


        /**
         * @function isLoggedIn
         * @description Checks if user is logged in.
         * @memberOf captureApp.webServices.pipeliner
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInSuccessCallback} successCallback - This callback informs that user is currently logged in.
         * @param {captureApp.webServices.exportTargetVer1~isLoggedInFailCallback} failCallback - This callback informs that user is not currently logged in.
         */
        isLoggedIn: function (successCallback, failCallback) {
            var isLogged = store.url !== undefined ? true : false;

            if (debug) { console.log(debug + 'isLogged', isLogged); }

            if (!isLogged) {
                // Since we can do it... Do silent login.
                service.login(successCallback, failCallback);
            }
            else { try { successCallback(); } catch (e) { } }
        },


        /**
       * @function createRecord
       * @description Creates record.
       * @memberOf captureApp.webServices.pipeliner
       * @param {recordType} recordType - Destination Record Type
       * @param {captureContact} captureRecord - Source Capture Record.
       * @param {object} createOptions - Options (For future use)
       * @param {captureApp.webServices.exportTargetVer1~createRecordSuccessCallback} successCallback 
       * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
       */
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {

            if (debug) { console.log(debug + 'createRecord', captureRecord); }

            var linkedin = '';
            var venueIndex;

            var cutLinkedInUrl = function (url) {
                if (!url) {
                    return null;
                }
                var pos = url.indexOf('linkedin.com/in');
                if (pos < 0) {
                    return null;
                }
                var res = url.substring(pos);
                pos = url.indexOf('?');
                if (pos > 0) {
                    res = res.substring(0, pos);
                }
                return res;
            };

            linkedin = cutLinkedInUrl(captureRecord.sourceurl);
            if (!linkedin && typeof captureRecord.venues !== 'undefined') {
                for (venueIndex = 0; venueIndex < captureRecord.venues.length; venueIndex++) {
                    linkedin = cutLinkedInUrl(captureRecord.venues[venueIndex].website);
                    if (linkedin) {
                        break;
                    }
                }
            }

            var country = captureRecord.country || '';
            if (country.toLowerCase() === 'us' || country.toLowerCase() === 'usa') {
                country = 'United States';
            }

            var comments = 'Created by Capture!';

            if (captureRecord.bio) {
                comments += '\n\n' + captureRecord.bio;
            }

            //if (typeof captureRecord.venues !== 'undefined' && captureRecord.venues.length > 0) {
            //    comments += '\n';
            //    for (venueIndex = 0; venueIndex < captureRecord.venues.length; venueIndex++) {
            //        var w = captureRecord.venues[venueIndex].website;
            //        if (w) {
            //            comments += '\n' + w;
            //        }
            //    }
            //}

            var createMessage = function(parentId, message) {
                var record = {
                    'OWNER_ID': store.ownerId,
                    'ADDRESSBOOK_ID': parentId,
                    'SUBJECT': (message || '')
                };

                var request = buildRequest('Messages');
                request.type = 'POST';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);

            };

            var createContact = function (nativeRecordType) {

                var record = {
                    'OWNER_ID': store.ownerId,
                    'SALES_UNIT_ID': '0',
                    //'TITLE': (captureRecord.prefix || ''), // for future use
                    'FIRST_NAME': (captureRecord.first || ''),
                    'MIDDLE_NAME': (captureRecord.middle || ''),
                    'SURNAME': (captureRecord.last || ''),
                    'EMAIL1': (captureRecord.email || ''),
                    'EMAIL2': (captureRecord.email2 || ''),
                    'POSITION': (captureRecord.jobtitle || ''),
                    'QUICK_ACCOUNT_NAME': (captureRecord.company || ''),
                    'PHONE1': (captureRecord.phone || ''),
                    'PHONE2': (captureRecord.phone2 || ''),
                    'COMMENTS': (comments || ''),
                    'ADDRESS': (captureRecord.address1 || '') + '\n' + (captureRecord.address2 || ''),
                    'CITY': (captureRecord.city || ''),
                    'STATE_PROVINCE': (captureRecord.state || ''),
                    'ZIP_CODE': (captureRecord.zip || ''),
                    'COUNTRY': (country || '')//,
                    //'LinkedIn': (linkedin || '')
                };

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    if (debug) { console.log(debug + 'response', successResponse, textStatus); }
                    var link = xhr.getResponseHeader('Location'); // Example: https://us.pipelinersales.com/rest_services/v1/us_BroadlookTechnologies1/Contacts/PY-7FFFFFFF-B2216806-D8BB-4743-B032-1C66DE20DC6C
                    var key = '/' + nativeRecordType + '/';


                    // Create Feed Messages with Venue Links
                    if (typeof captureRecord.venues !== 'undefined' && captureRecord.venues.length > 0) {
                        var newRecordId = link.substring(link.indexOf(key) + key.length);
                        var message = '';
                        var ww = [];
                        for (venueIndex = 0; venueIndex < captureRecord.venues.length; venueIndex++) {
                            var w = captureRecord.venues[venueIndex].website;
                            if (w) {
                                ww.push(w);
                            }
                        }
                        message = 'Social networks and other links found by Capture:\n\n' + ww.join('\n');
                        createMessage(newRecordId, message);
                    }

                    try { successCallback(link); } catch (e) { }
                };

                var request = buildRequest(nativeRecordType, successCallback2, failCallback);
                request.type = 'POST';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                createContact('Contacts');
            } else {
                failCallback('Invalid record type');
            }

        },


        /**
        * @function updateRecord
        * @description Updates record.
        * @memberOf captureApp.webServices.pipeliner
        * @param {string} recordId - Record ID
        * @param {recordType} recordType - Record Type ('lead', 'contact' or 'account')
        * @param {object} record - Native record. Include only fields to be updated. 
        * @param {captureApp.webServices.exportTargetVer1~updateRecordSuccessCallback} successCallback 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
        */
        updateRecord: function (recordId, recordType, record, successCallback, failCallback) {

            if (debug) { console.log(debug + 'updateRecord', recordId, recordType, record); }

            var updateContact = function (nativeRecordType) {

                if (debug) { console.log(debug + 'post', angular.copy(record)); }

                var successCallback2 = function (successResponse, textStatus, xhr) {

                    if (debug) { console.log(debug + 'response', successResponse); }

                    try { successCallback(recordId); } catch (e) { }
                };

                var buildRequest2 = function (method, id, successCallback, failCallback) {
                    return {
                        type: 'GET',
                        url: store.url + '/' + method + '/' + id,
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', store.auth);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {
                            var response = handleErrorMessageText(errorResponse);
                            failCallback(response, errorResponse.status || 500);
                        }
                    };
                };

                var request = buildRequest2(nativeRecordType, recordId, successCallback2, failCallback);
                request.type = 'PUT';
                request.data = JSON.stringify(record);

                jQuery.ajax(request);
            };

            if (recordType.toUpperCase() === 'CONTACT') {
                updateContact('Contacts');
            } else {
                failCallback('Invalid record type');
            }

        },


        /**
        * @function getRequiredLookups
        * @description Returns an array of lookups required prior to saving a record .
        * @memberOf captureApp.webServices.pipeliner
        * @param {recordType} recordType - Record type 
        * @return {captureApp.webServices.exportTargetVer1~lookup[]}
        */
        getRequiredLookups: function (recordType) {
            return [];
        },


        /**
        * @function getDefaultExportMaps
        * @description (Reserved for future use) Return an empty array. 
        * maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        * @memberOf captureApp.webServices.pipeliner
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefaultExportMaps: function (successCallback, failureCallback) {

            var maps = [];

            //maps.push({ name: 'contact', label: 'Contact', map: null });

            successCallback(maps);
        },


        /**
        * @function getDefinition
        * @description Returns configuration for Multi-Merge dialog. 
        * How to modify:
        * 1. Put native field names in def.fields.map.{Field}.id
        * 2. Remove lines that do not have corresponding native fields, or where fields are read-only
        * @memberOf captureApp.webServices.pipeliner
        * @param {string} recordType - 'lead', 'contact' or 'account'. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefinition: function (recordType, successCallback, failureCallback) {


            if (debug) { console.log(debug + 'getDefinition', recordType); }


            var def = {};
            recordType = recordType.toLowerCase();
            //if (recordType === 'lead') {
            //    def = {
            //        groups: {
            //            list: ['G1', 'G2'],
            //            map: {
            //                'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description'] },
            //                'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
            //            }
            //        },
            //        fields: {
            //            list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Website', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
            //            map: {
            //                //'FirstName': { id: 'FIRST_NAME', display: 'First Name', group: 'G1' },
            //                //'LastName': { id: 'SURNAME', display: 'Last Name', group: 'G1' },
            //                'FullName': { id: 'QUICK_CONTACT_NAME', display: 'Full Name', group: 'G1' },
            //                'Title': { id: 'POSITION', display: 'Job Title', group: 'G1' },
            //                'Company': { id: 'QUICK_ACCOUNT_NAME', display: 'Company', group: 'G1' },
            //                'Email': { id: 'QUICK_EMAIL', display: 'Email', group: 'G1' },
            //                'Phone': { id: 'QUICK_PHONE', display: 'Phone', group: 'G1' },
            //                //'MobilePhone': { id: 'Telephone2', display: 'Phone 2', group: 'G1' },
            //                //'Website': { id: 'WebSiteUrl', display: 'Website', group: 'G1' },
            //                //'Description': { id: 'Description', display: 'Description', group: 'G1' },

            //                //'Street': { id: 'Address1_Line1', display: 'Address1_Line1', group: 'G2' },
            //                //'City': { id: 'Address1_City', display: 'City', group: 'G2' },
            //                //'State': { id: 'Address1_StateOrProvince', display: 'State/Province', group: 'G2' },
            //                //'PostalCode': { id: 'Address1_PostalCode', display: 'Zip/Postal Code', group: 'G2' },
            //                //'Country': { id: 'Address1_Country', display: 'Country', group: 'G2' },
            //            }
            //        }
            //    };

            //} else
            if (recordType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'FIRST_NAME', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'SURNAME', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'POSITION', display: 'Position', group: 'G1' },
                            'Company': { id: 'QUICK_ACCOUNT_NAME', display: 'Company', group: 'G1' },
                            'Email': { id: 'EMAIL1', display: 'Email 1', group: 'G1' },
                            'Phone': { id: 'PHONE1', display: 'Phone 1', group: 'G1' },
                            'MobilePhone': { id: 'PHONE2', display: 'Phone 2', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Description': { id: 'COMMENTS', display: 'Comments', group: 'G1' },

                            'Street': { id: 'ADDRESS', display: 'Address', group: 'G2' },
                            'City': { id: 'CITY', display: 'City', group: 'G2' },
                            'State': { id: 'STATE_PROVINCE', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'ZIP_CODE', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'COUNTRY', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },


        /**
        * @function toNativeRecord
        * @description Converts Capture Contact to native record. 
        * @memberOf captureApp.webServices.pipeliner
        * @param {captureContact} captureRecord - Capture Contact
        * @param {recordType} recordType - Record type. 
        * @return {object} - Native record
        */
        toNativeRecord: function (captureRecord, recordType) {
            recordType = recordType.toLowerCase();
            if (recordType === 'contact') { return toContact(captureRecord); }
            return null;
        },


        /**
        * @function fromNativeRecord
        * @description Converts native record to Capture Contact. 
        * @memberOf captureApp.webServices.pipeliner
        * @param {object} nativeRecord - Native record
        * @param {recordType} recordType - Record type. 
        * @return {captureContact} - Capture Contact
        */
        fromNativeRecord: function (nativeRecord, recordType) {
            recordType = recordType.toLowerCase();
            if (recordType === 'contact') { return fromContact(nativeRecord); }
            return null;
        },


        /**
        * @function findDuplicates
        * @description Returns an array of duplicate records of given type.
        * @memberOf captureApp.webServices.pipeliner
        * @param {captureContact} recordType - Record type. 
        * @param {captureContact} captureRecord - Source Capture Contact. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the resulting array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback  
        * @return {captureContact[]} - Array of Capture Contacts
        */
        findDuplicates: function (recordType, captureRecord, successCallback, failCallback) {

            if (debug) { console.log(debug + 'findcoDuplicates', recordType, captureRecord); }

            var dups = [];

            var reponseHandle = null;
            var returnResponse = function () {
                try {
                    if (debug) { console.log(debug + 'dups (final)', angular.copy(dups)); }

                    successCallback({ duplicates: dups });
                } catch (e) { }
            };

            var findRecords = function (filter, nativeRecordType) {

                if (debug) { console.log(debug + 'findRecords', angular.copy(captureRecord)); }


                if (debug) { console.log(debug + 'filter', filter); }

                var successCallback2 = function (successResponse, textStatus, xhr) {


                    if (debug) { console.log(debug + 'response', successResponse); }

                    for (var i = 0; i < successResponse.length; i++) {
                        var dup = {};
                        dup = fromContact(successResponse[i]);
                        dups.push(dup);
                    }

                    if (debug) { console.log(debug + 'dups', angular.copy(dups)); }

                    //try { successCallback({ duplicates: dups }); } catch (e) { }

                    if (reponseHandle) {
                        window.clearTimeout(reponseHandle);
                    }
                    reponseHandle = window.setTimeout(returnResponse, 2000);
                };

                var buildRequest2 = function (method, filter, successCallback, failCallback) {
                    return {
                        type: 'GET',
                        url: store.url + '/' + method + '?filter=' + filter,
                        contentType: 'application/json',
                        crossDomain: true,
                        beforeSend: function (xhr) {
                            xhr.setRequestHeader('Authorization', store.auth);
                        },
                        success: function (successResponse, textStatus, xhr) {
                            successCallback(successResponse, textStatus, xhr);
                        },
                        error: function (errorResponse) {
                            var response = handleErrorMessageText(errorResponse);
                            failCallback(response, errorResponse.status || 500);
                        }
                    };
                };

                var request = buildRequest2(nativeRecordType, filter, successCallback2, failCallback);

                jQuery.ajax(request);
            };

            var filter = '';
            var nativeRecordType = '';

            if (recordType.toUpperCase() === 'CONTACT') {

                nativeRecordType = 'Contacts';

                if (captureRecord.email) {
                    filter = 'EMAIL1::' + (captureRecord.email || '');
                    findRecords(filter, nativeRecordType);
                }

                if (captureRecord.last) {
                    filter = 'SURNAME::' + (captureRecord.last || '') + '|' + 'FIRST_NAME::' + (captureRecord.first || '');
                    findRecords(filter, nativeRecordType);
                }

                if (captureRecord.email2) {
                    filter = 'EMAIL1::' + (captureRecord.email2 || '');
                    findRecords(filter, nativeRecordType);
                }

                //} else if (recordType.toUpperCase() === 'LEAD') {

                //    nativeRecordType = 'Leads';

                //    if (captureRecord.email) {
                //        filter = 'EMAIL1::' + (captureRecord.email || '');
                //        findRecords(filter, nativeRecordType);
                //    }

                //    if (captureRecord.last) {
                //        filter = 'SURNAME::' + (captureRecord.last || '') + '|' + 'FIRST_NAME::' + (captureRecord.first || '');
                //        findRecords(filter, nativeRecordType);
                //    }

                //    if (captureRecord.email2) {
                //        filter = 'EMAIL1::' + (captureRecord.email2 || '');
                //        findRecords(filter, nativeRecordType);
                //    }


            } else {
                try { successCallback({ duplicates: [] }); } catch (e) { }
            }

        },


        /**
        * @function retrieveRecord
        * @description Returns single recor.
        * @memberOf captureApp.webServices.pipeliner
        * @param {string} recordId - Record ID 
        * @param {recordType} recordType - Record type
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the native record as a parameter
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback - Return error message
        */
        retrieveRecord: function (recordId, recordType, successCallback, failCallback) {

            if (recordType.toLowerCase() === 'lead') { recordType = 'Leads'; }
            if (recordType.toLowerCase() === 'contact') { recordType = 'Contacts'; }

            var buildRequest2 = function (method, id, successCallback, failCallback) {
                return {
                    type: 'GET',
                    url: store.url + '/' + method + '/' + id,
                    contentType: 'application/json',
                    crossDomain: true,
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader('Authorization', store.auth);
                    },
                    success: function (successResponse, textStatus, xhr) {
                        successCallback(successResponse, textStatus, xhr);
                    },
                    error: function (errorResponse) {
                        var response = handleErrorMessageText(errorResponse);
                        failCallback(response, errorResponse.status || 500);
                    }
                };
            };

            var successCallback2 = function (successResponse, textStatus, xhr) {

                if (debug) { console.log(debug + 'response', successResponse); }

                try { successCallback(successResponse); } catch (e) { }
            };

            var request = buildRequest2(recordType, recordId, successCallback2, failCallback);

            jQuery.ajax(request);
        },

        //-- Search --//
        //  Find a record using a query: { first:'', last:'', email:''} object
        //      successCallback: function(nativeRecords[])
        findRecord: function (recordType, query, fields, successCallback, failCallback) {

            if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

            try { failCallback('Not implemented: findRecord'); } catch (e) { }
        },

        /*
        * Returns JSON with all Team Pipeline Clients. Function is supposed to help obtain value for OWNER_ID field.
        * E.g.: {
        *   "Stefan Smihla (stefan.smihla@pipelinersales)": 12345,
        *   "Example User (example@user.com)": 56789
        * }
        */
        getClients: function (successCallback, failCallback) {

            if (debug) { console.log(debug + 'getClients'); }

            var successFunc = function (successResponse) {
                var clients = {};
                for (var i in successResponse) {
                    var item = successResponse[i];
                    var firstname = item.FIRSTNAME || '';
                    var surname = item.LASTNAME || '';
                    var fullname = firstname + ' ' + surname + ' (' + item.EMAIL + ')';
                    clients[fullname] = item.ID;
                }
                //successCallback(JSON.stringify(clients));
                successCallback(clients);
            };

            service.getEntities('Clients', successFunc, failCallback);
        },

        /* Sets Sales Unit ID. This value will be needed fpr required SALES_UNIT_ID. */
        setSalesUnit: function (salesUnit) {
            store.salesUnit = salesUnit;
        },

        getEntities: function (nativeRecordType, successCallback, failCallback) {

            if (debug) { console.log(debug + 'getEntities', nativeRecordType); }

            var request = buildRequest(nativeRecordType, successCallback, failCallback);
            request.success = successCallback;
            jQuery.ajax(request);
        },

    };

    return service;
}]);
/**
 * @class captureApp.webServices.zoho
 * @memberOf captureApp.webServices
 * @description This is Zoho CRM AngularJS service.
 */

'use strict';

/* global angular: false */
/* global jQuery: false */

//app
angular.module('webServices')
.factory('zoho', ['$http', '$q', 'endpoints', 'dialogs', function ($http, $q, endpoints, dialogs) {
    var debug = 'zoho.js->'; //debug = false;

    var store = {};

    var url = '';

    var encode = function (string) {
        if (typeof string === 'undefined') { string = ''; }
        string += '';
        if (!string) { return ''; }
        return string.replace(/\&/g, '&' + 'amp;').replace(/</g, '&' + 'lt;').replace(/>/g, '&' + 'gt;').replace(/\'/g, '&' + 'apos;').replace(/\"/g, '&' + 'quot;');
    };

    var mapFromField = function (target, targetKey, sourceAsFLArray, sourceKey) {

        var source = sourceAsFLArray.FL;

        for (var i = 0, l = source.length; i < l; i++) {
            if (source[i].val === sourceKey) {
                target[targetKey] = source[i].content;
            }
        }

    };

    var mapField = function (source, sourceKey, target, targetKey) {

        var value;
        var sourceKeyParts = sourceKey.split('.');
        if (sourceKeyParts.length === 2) {
            try {
                value = source[sourceKeyParts[0]][sourceKeyParts[1]];
            } catch (e) {
                value = null;
            }
        }
        else { value = source[sourceKey]; }

        target.FL.push({ content: value, val: targetKey });
    };


    var fromContact = function (nativeRecord) {

        if (debug) {
            console.log(debug + 'fromContact:in', nativeRecord);
        }

        var captureRecord = {};
        mapFromField(captureRecord, 'first', nativeRecord, 'First Name');
        mapFromField(captureRecord, 'last', nativeRecord, 'Last Name');
        mapFromField(captureRecord, 'jobtitle', nativeRecord, 'Designation');
        mapFromField(captureRecord, 'company', nativeRecord, 'Company');
        mapFromField(captureRecord, 'email', nativeRecord, 'Email');
        mapFromField(captureRecord, 'phone', nativeRecord, 'Phone');
        mapFromField(captureRecord, 'phone2', nativeRecord, 'Mobile');
        mapFromField(captureRecord, 'website', nativeRecord, 'Website');
        mapFromField(captureRecord, 'bio', nativeRecord, 'Description');
        mapFromField(captureRecord, 'address1', nativeRecord, 'Street');
        mapFromField(captureRecord, 'city', nativeRecord, 'City');
        mapFromField(captureRecord, 'state', nativeRecord, 'State');
        mapFromField(captureRecord, 'zip', nativeRecord, 'Zip Code');
        mapFromField(captureRecord, 'country', nativeRecord, 'Country');
        //mapFromField(captureRecord, 'sourceurl', nativeRecord, 'LinkedIn');

        mapFromField(captureRecord, '_id', nativeRecord, 'CONTACTID');
        captureRecord._link = 'https://crm.zoho.com/crm/EntityInfo.do?module=Contacts&id=' + captureRecord._id;
        captureRecord._type = 'Contact';

        if (debug) {
            console.log(debug + 'fromContact:out', captureRecord);
        }

        return captureRecord;
    };

    var fromLead = function (nativeRecord) {

        if (debug) {
            console.log(debug + 'fromLead:in', nativeRecord);
        }

        var captureRecord = {};
        mapFromField(captureRecord, 'first', nativeRecord, 'First Name');
        mapFromField(captureRecord, 'last', nativeRecord, 'Last Name');
        mapFromField(captureRecord, 'jobtitle', nativeRecord, 'Designation');
        mapFromField(captureRecord, 'company', nativeRecord, 'Company');
        mapFromField(captureRecord, 'email', nativeRecord, 'Email');
        mapFromField(captureRecord, 'phone', nativeRecord, 'Phone');
        mapFromField(captureRecord, 'phone2', nativeRecord, 'Mobile');
        mapFromField(captureRecord, 'website', nativeRecord, 'Website');
        mapFromField(captureRecord, 'bio', nativeRecord, 'Description');
        mapFromField(captureRecord, 'address1', nativeRecord, 'Street');
        mapFromField(captureRecord, 'city', nativeRecord, 'City');
        mapFromField(captureRecord, 'state', nativeRecord, 'State');
        mapFromField(captureRecord, 'zip', nativeRecord, 'Zip Code');
        mapFromField(captureRecord, 'country', nativeRecord, 'Country');
        //mapFromField(captureRecord, 'sourceurl', nativeRecord, 'LinkedIn');

        mapFromField(captureRecord, '_id', nativeRecord, 'LEADID');
        captureRecord._link = 'https://crm.zoho.com/crm/EntityInfo.do?module=Leads&id=' + captureRecord._id;
        captureRecord._type = 'Lead';

        if (debug) {
            console.log(debug + 'fromLead:out', captureRecord);
        }

        return captureRecord;
    };

    var fromAccount = function (nativeRecord) {

        if (debug) {
            console.log(debug + 'fromAccount:in', nativeRecord);
        }

        var captureRecord = {};
        //mapFromField(captureRecord, 'first', nativeRecord, 'First Name');
        //mapFromField(captureRecord, 'last', nativeRecord, 'Last Name');
        //mapFromField(captureRecord, 'jobtitle', nativeRecord, 'Designation');
        mapFromField(captureRecord, 'company', nativeRecord, 'Account Name');
        mapFromField(captureRecord, 'email', nativeRecord, 'E-mail');
        mapFromField(captureRecord, 'phone', nativeRecord, 'Phone');
        //mapFromField(captureRecord, 'phone2', nativeRecord, 'Mobile');
        mapFromField(captureRecord, 'website', nativeRecord, 'Website');
        mapFromField(captureRecord, 'bio', nativeRecord, 'Description');
        //mapFromField(captureRecord, 'address1', nativeRecord, 'Street');
        //mapFromField(captureRecord, 'city', nativeRecord, 'City');
        //mapFromField(captureRecord, 'state', nativeRecord, 'State');
        //mapFromField(captureRecord, 'zip', nativeRecord, 'Zip Code');
        //mapFromField(captureRecord, 'country', nativeRecord, 'Country');
        //mapFromField(captureRecord, 'sourceurl', nativeRecord, 'LinkedIn');

        mapFromField(captureRecord, '_id', nativeRecord, 'ACCOUNTID');
        captureRecord._link = 'https://crm.zoho.com/crm/EntityInfo.do?module=Accounts&id=' + captureRecord._id;
        captureRecord._type = 'Account';

        if (debug) {
            console.log(debug + 'fromAccount:out', captureRecord);
        }

        return captureRecord;
    };

    var toLead = function (captureRecord) {

        if (debug) {
            console.log(debug + 'toLead:in', captureRecord);
        }

        var nativeRecord = { FL: [] };
        mapField(captureRecord, 'first', nativeRecord, 'First Name');
        mapField(captureRecord, 'last', nativeRecord, 'Last Name');
        mapField(captureRecord, 'jobtitle', nativeRecord, 'Designation');
        mapField(captureRecord, 'company', nativeRecord, 'Company');
        mapField(captureRecord, 'email', nativeRecord, 'Email');
        mapField(captureRecord, 'phone', nativeRecord, 'Phone');
        mapField(captureRecord, 'phone2', nativeRecord, 'Mobile');
        mapField(captureRecord, 'website', nativeRecord, 'Website');
        mapField(captureRecord, 'bio', nativeRecord, 'Description');
        mapField(captureRecord, 'address1', nativeRecord, 'Street');
        mapField(captureRecord, 'city', nativeRecord, 'City');
        mapField(captureRecord, 'state', nativeRecord, 'State');
        mapField(captureRecord, 'zip', nativeRecord, 'Zip Code');
        mapField(captureRecord, 'country', nativeRecord, 'Country');


        if (debug) {
            console.log(debug + 'toLead:out', nativeRecord);
        }

        return nativeRecord;
    };

    var toContact = function (captureRecord) {

        if (debug) {
            console.log(debug + 'toContact:in', captureRecord);
        }

        var nativeRecord = { FL: [] };
        mapField(captureRecord, 'first', nativeRecord, 'First Name');
        mapField(captureRecord, 'last', nativeRecord, 'Last Name');
        mapField(captureRecord, 'jobtitle', nativeRecord, 'Designation');
        mapField(captureRecord, 'email', nativeRecord, 'Email');
        mapField(captureRecord, 'phone', nativeRecord, 'Phone');
        mapField(captureRecord, 'phone2', nativeRecord, 'Mobile');
        mapField(captureRecord, 'bio', nativeRecord, 'Description');
        mapField(captureRecord, 'address1', nativeRecord, 'Street');
        mapField(captureRecord, 'city', nativeRecord, 'City');
        mapField(captureRecord, 'state', nativeRecord, 'State');
        mapField(captureRecord, 'zip', nativeRecord, 'Zip Code');
        mapField(captureRecord, 'country', nativeRecord, 'Country');

        if (debug) {
            console.log(debug + 'toContact:out', nativeRecord);
        }

        return nativeRecord;
    };

    var service = {

        getName: function () {
            return 'Zoho CRM';
        },

        /* Sets user credentials */
        init: function (o) {

            if (debug) { console.log('ZOHO: init->token', o.token); }

            //store.username = o.username;
            store.token = o.token;
        },

        //  Log us in
        login: function (successCallback, failCallback) {

            var token = store.token;
            if (!token) {
                try { failCallback('Please open Settings, enter valid user credentials and obtain Authorization Token.'); } catch (e) { }
                return;
            }

            console.log('ZOHO: auth token is ', token);
            try { successCallback('Logged in successfully'); } catch (e) { }
        },

        createToken: function (username, password, successCallback, failCallback) {

            var url = 'https://accounts.zoho.com/apiauthtoken/nb/create?SCOPE=ZohoCRM/crmapi&EMAIL_ID=' + username + '&PASSWORD=' + password;

            console.log('createToken');

            jQuery.ajax({
                method: 'Get',
                url: url,
                failure: function (a, b) {
                    console.log('FAILED to create token', a, b);
                    try { failCallback('Please check your internet connection'); } catch (e) { }
                },
                success: function (response) {

                    try {

                        console.log('create token response', response);

                        var regExp = /\AUTHTOKEN=([^*]+)\RESULT/;
                        var matches = regExp.exec(response);

                        if (matches === null) {


                            console.log('FAILED to get token');

                            try {

                                // May fail as:
                                //CAUSE=API_ACCESS_REQUEST_BLOCKED
                                //RESULT = FALSE

                                var regExp2 = /\CAUSE=([^*]+)\RESULT/;
                                var matches2 = regExp2.exec(response);
                                var errorCode = matches2[1].trim();

                                //if (errorCode === 'EXCEEDED_MAXIMUM_ALLOWED_AUTHTOKENS') {
                                //    try { failCallback('Zoho API error: EXCEEDED_MAXIMUM_ALLOWED_AUTHTOKENS'); } catch (e) { }
                                //}
                                //else if (errorCode === 'API_ACCESS_REQUEST_BLOCKED') {
                                //    try { failCallback('Zoho API error: API_ACCESS_REQUEST_BLOCKED'); } catch (e) { }
                                //}
                                //else {
                                try { failCallback('Zoho API error: ' + errorCode); } catch (e) { }
                                //}

                            } catch (e) {
                                console.log('ERROR in createToken.success [no AUTHTOKEN]', e.message);
                                try { failCallback('Please enter valid user credentials'); } catch (e) { }
                            }

                        }
                        else {

                            var token = matches[1].trim();

                            store.token = token;
                            //store.username = username;

                            try { successCallback(token); } catch (e) { }
                        }

                    } catch (e) {
                        console.log('ERROR in createToken.success', e.message);
                        try { failCallback('Error. Please contact Capture! support.'); } catch (e) { }
                    }

                }

            });
        },
        //-------------------------------------------EDIT END-----------------------------------------

        logout: function () {

            if (debug) { console.log(debug + 'calling is loggedin'); }
            store = {};

            try {
                jQuery.cookie('token_number', '');
                jQuery.cookie('emailid', '');
            } catch (e) {
            }

        },


        isLoggedIn: function (successCallback, failCallback) {

            try {

                if (debug) { console.log('isLoggedIn->store', store); }

                if (store && store.token) {
                    try { successCallback(); } catch (e) { }
                    return;
                } else {
                    try { failCallback(); } catch (e) { }
                    return;
                }

            } catch (e) {
                console.log('ERROR in isLoggedIn', e.message);
                try { failCallback(); } catch (e) { }
            }

        },

        asyncIsLoggedIn: function () {
            var deferred = $q.defer();
            service.isLoggedIn(
                function () { deferred.resolve(true); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        getEntities: function (successCallback, failCallback) {

            try { failCallback('Not implemented: getEntities'); } catch (e) { }

            //var url = store.url + '/services/data/v29.0/sobjects';

            //jQuery.ajax({
            //    type: 'GET',
            //    url: url,
            //    contentType: 'application/json',
            //    beforeSend: function (xhr) {
            //        xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
            //        xhr.setRequestHeader('Accept', 'application/json');
            //    },
            //    success: function (successResponse) {
            //        console.log('successResponse=', successResponse.sobjects);
            //        var list = [];
            //        angular.forEach(successResponse.sobjects, function (sobject, index) {
            //            list.push({ name: sobject.name, label: sobject.label });
            //        });
            //        successCallback(list);
            //    },
            //    error: function (errorResponse) {
            //        console.log('errorResponse=', errorResponse);
            //        if (errorResponse && errorResponse.responseJSON && errorResponse.responseJSON.length > 0 && errorResponse.responseJSON[0].message) {
            //            failureCallback(errorResponse.responseJSON[0].message);
            //        }
            //        else { failureCallback(errorResponse); }
            //    }

            //});

        },

        getFields: function (entityType, successCallback, failCallback) {

            try { failCallback('Not implemented: getFields'); } catch (e) { }

            //var url = store.url + '/services/data/v29.0/sobjects/' + entityType + '/describe';
            //console.log('getFields=', url);
            //jQuery.ajax({
            //    type: 'GET',
            //    url: url,
            //    contentType: 'application/json',
            //    beforeSend: function (xhr) {
            //        xhr.setRequestHeader('Authorization', 'OAuth ' + store.id);
            //        xhr.setRequestHeader('Accept', 'application/json');
            //    },
            //    success: function (successResponse) {

            //        console.log('successResponse=', successResponse);

            //        var ff = [];
            //        angular.forEach(successResponse.fields, function (field, index) {

            //            var vv = [];
            //            if (field.picklistValues) {
            //                angular.forEach(field.picklistValues, function (pv, pvi) {
            //                    vv.push({ value: pv.value, label: pv.label });
            //                });
            //            }

            //            var f = { name: field.name, label: field.label };

            //            if (vv.length > 0) { f.values = vv; }

            //            ff.push(f);
            //        });

            //        successCallback(ff);
            //    },
            //    error: function (errorResponse) {

            //        console.log('errorResponse=', errorResponse);
            //        failureCallback(errorResponse);
            //    }

            //});
        },




        xmlData: function (captureRecord, nativeRecordType) {

            var sendto;
            var name;
            if (nativeRecordType === 'Accounts') {
                sendto = 'Account Name';
                name = captureRecord.company;
            }
            else {
                sendto = 'Company';
                name = captureRecord.company;
            }

            var xmlreq = '<' + nativeRecordType + '>';
            xmlreq += '<row no="1"><FL val="' + sendto + '">' + encode(name) + '</FL>';
            if (captureRecord.first) {
                xmlreq += '<FL val="First Name">' + encode(captureRecord.first) + '</FL>';
            }
            if (captureRecord.last) {
                xmlreq += '<FL val="Last Name">' + encode(captureRecord.last) + '</FL>';
            }
            if (captureRecord.email) {
                xmlreq += '<FL val="Email">' + encode(captureRecord.email) + '</FL>';
            }
            if (captureRecord.email2) {
                xmlreq += '<FL val="Secondary Email">' + encode(captureRecord.email2) + '</FL>';
            }
            if (captureRecord.jobtitle) {
                xmlreq += '<FL val="Title">' + encode(captureRecord.jobtitle) + '</FL>';
            }
            if (captureRecord.phone) {
                xmlreq += '<FL val="Phone">' + encode(captureRecord.phone) + '</FL>';
            }
            if (captureRecord.phone2) {
                xmlreq += '<FL val="Mobile">' + encode(captureRecord.phone2) + '</FL>';
            }
            if (captureRecord.website) {
                xmlreq += '<FL val="Website">' + encode(captureRecord.website) + '</FL>';
            }
            if (nativeRecordType === 'Leads') {
                if (captureRecord.address) {
                    xmlreq += '<FL val="Street">' + encode(captureRecord.address) + '</FL>'; // address1+address2
                }
                if (captureRecord.city) {
                    xmlreq += '<FL val="City">' + encode(captureRecord.city) + '</FL>';
                }
                if (captureRecord.state) {
                    xmlreq += '<FL val="State">' + encode(captureRecord.state) + '</FL>';
                }
                if (captureRecord.zip) {
                    xmlreq += '<FL val="Zip Code">' + encode(captureRecord.zip) + '</FL>';
                }
                if (captureRecord.country) {
                    xmlreq += '<FL val="Country">' + encode(captureRecord.country) + '</FL>';
                }

                if (captureRecord.company) {
                    xmlreq += '<FL val="Company">' + encode(captureRecord.company) + '</FL>';
                }

            } else if (nativeRecordType === 'Contacts') {
                if (captureRecord.address) {
                    xmlreq += '<FL val="Mailing Street">' + encode(captureRecord.address) + '</FL>'; // address1+address2
                }
                if (captureRecord.city) {
                    xmlreq += '<FL val="Mailing City">' + encode(captureRecord.city) + '</FL>';
                }
                if (captureRecord.state) {
                    xmlreq += '<FL val="Mailing State">' + encode(captureRecord.state) + '</FL>';
                }
                if (captureRecord.zip) {
                    xmlreq += '<FL val="Mailing Zip">' + encode(captureRecord.zip) + '</FL>'; // yep... 
                }
                if (captureRecord.country) {
                    xmlreq += '<FL val="Mailing Country">' + encode(captureRecord.country) + '</FL>';
                }

                if (captureRecord.company) {
                    xmlreq += '<FL val="Account Name">' + encode(captureRecord.company) + '</FL>';
                }
            }

            if (captureRecord.bio) {
                xmlreq += '<FL val="Description">' + encode(captureRecord.bio) + '</FL>';
            }
            xmlreq += '</row></' + nativeRecordType + '>';
            return xmlreq;

        },

        /**
        * @function toNativeRecord
        * @description Converts Capture Contact to native record. 
        * @memberOf captureApp.webServices.zoho
        * @param {captureContact} captureRecord - Capture Contact
        * @param {recordType} recordType - Record type. 
        * @return {object} - Native record
        */
        toNativeRecord: function (captureRecord, recordType) {
            recordType = recordType.toLowerCase();
            if (recordType === 'contacts' || recordType === 'contact') { return toContact(captureRecord); }
            else if (recordType === 'leads' || recordType === 'lead') { return toLead(captureRecord); }
            return null;
        },

        /**
        * @function fromNativeRecord
        * @description Converts native record to Capture Contact. 
        * @memberOf captureApp.webServices.zoho
        * @param {object} nativeRecord - Native record
        * @param {recordType} recordType - Record type. 
        * @return {captureContact} - Capture Contact
        */
        fromNativeRecord: function (nativeRecord, recordType) {
            recordType = recordType.toLowerCase();
            if (recordType === 'contacts' || recordType === 'contact') { return fromContact(nativeRecord); }
            else if (recordType === 'leads' || recordType === 'lead') { return fromLead(nativeRecord); }
            return null;
        },

        //  From CRM object to lookup object (each object is defined as {label: '', link: ''})
        toLookupObject: function (crmObject, entityType) {

            if (debug) { console.log(debug + 'toLookupObject->entityType', entityType, '->crmObject', crmObject); }

            entityType = entityType.toLowerCase();
            var lookupObject = { label: '', link: '' };
            var appObject = null;
            if (entityType === 'contact') { appObject = fromContact(crmObject); }
            if (entityType === 'lead') { appObject = fromLead(crmObject); }
            if (entityType === 'account') {
                appObject = fromAccount(crmObject);
                var cityState = '';
                if (appObject.city) { cityState = appObject.city; }
                if (appObject.state) {
                    if (cityState) { cityState = cityState + ', ' + appObject.state; }
                    else { cityState = appObject.state; }
                }
                if (cityState) { cityState = ' (' + cityState + ')'; }
                lookupObject.label = (appObject.company || '(no name)') + cityState;
                lookupObject.link = appObject._link;
                lookupObject.id = appObject._id;
            }
            if (entityType === 'systemuser') {
                lookupObject.label = crmObject.FullName;
                lookupObject.link = crmObject.__metadata.uri;
                lookupObject.id = crmObject.SystemUserId;
            }

            return lookupObject;
        },

        /**
        * @function getRequiredLookups
        * @description Returns an array of lookups required prior to saving a record .
        * @memberOf captureApp.webServices.zoho
        * @param {string} entityType - 'lead', 'contact' or 'account'. 
        * @return {captureApp.webServices.exportTargetVer1~lookup[]}
        */
        getRequiredLookups: function (entityType) {

            entityType = entityType.toLowerCase();
            if (entityType === 'contact') {
                return [{ crmProperty: 'company', appProperty: 'company', message: 'Select parent account', type: 'Account', required: false, allowNew: false }
                ];
            }
            return [];
        },

        /**
        * @function getDefaultExportMaps
        * @description (Reserved for future use) Return an empty array. 
        * maps: [ {captureField: { name: '', label: '' }, crmField: { name: '', label: '' } } ]
        * @memberOf captureApp.webServices.zoho
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
        */
        getDefaultExportMaps: function (successCallback, failureCallback) {

            var maps = [];

            //maps.push({ name: 'contact', label: 'Contact', map: null });

            successCallback(maps);
        },

        /**
                * @function getDefinition
                * @description Returns configuration for Multi-Merge dialog. 
                * How to modify:
                * 1. Put native field names in def.fields.map.{Field}.id
                * 2. Remove lines that do not have corresponding native fields, or where fields are read-only
                * @memberOf captureApp.webServices.zoho
                * @param {string} recordType - 'lead', 'contact' or 'account'. 
                * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback  - pass the empty array
                * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback 
                */
        getDefinition: function (recordType, successCallback, failureCallback) {


            if (debug) { console.log(debug + 'getDefinition', recordType); }


            var def = {};
            recordType = recordType.toLowerCase();
            if (recordType === 'lead') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'First Name', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'Last Name', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'Title', display: 'Position', group: 'G1' },
                            'Company': { id: 'Account Name', display: 'Company', group: 'G1' },
                            'Email': { id: 'Email', display: 'Email 1', group: 'G1' },
                            //Email2?
                            'Phone': { id: 'Phone', display: 'Phone 1', group: 'G1' },
                            'MobilePhone': { id: 'Mobile', display: 'Phone 2', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Description': { id: 'Description', display: 'Comments', group: 'G1' },

                            'Street': { id: '"Street', display: 'Address', group: 'G2' },
                            'City': { id: 'City', display: 'City', group: 'G2' },
                            'State': { id: 'State', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'Zip Code', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Country', display: 'Country', group: 'G2' }
                        }
                    }
                };

            } else if (recordType === 'contact') {
                def = {
                    groups: {
                        list: ['G1', 'G2'],
                        map: {
                            'G1': { display: 'General', fields: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Description'] },
                            'G2': { display: 'Address', fields: ['Street', 'City', 'State', 'PostalCode', 'Country'] }
                        }
                    },
                    fields: {
                        list: ['FirstName', 'LastName', 'Title', 'Company', 'Email', 'Phone', 'MobilePhone', 'Description', 'Street', 'City', 'State', 'PostalCode', 'Country'],
                        map: {
                            'FirstName': { id: 'First Name', display: 'First Name', group: 'G1' },
                            'LastName': { id: 'Last Name', display: 'Last Name', group: 'G1' },
                            'Title': { id: 'Title', display: 'Position', group: 'G1' },
                            //'Company': { id: 'Account Name', display: 'Company', group: 'G1' },
                            'Email': { id: 'Email', display: 'Email 1', group: 'G1' },
                            //Email2?
                            'Phone': { id: 'Phone', display: 'Phone 1', group: 'G1' },
                            'MobilePhone': { id: 'Mobile', display: 'Phone 2', group: 'G1' },
                            //'Website': { id: 'Website', display: 'Website', group: 'G1' },
                            'Description': { id: 'Description', display: 'Comments', group: 'G1' },

                            'Street': { id: '"Mailing Street', display: 'Address', group: 'G2' },
                            'City': { id: 'Mailing City', display: 'City', group: 'G2' },
                            'State': { id: 'Mailing State', display: 'State/Province', group: 'G2' },
                            'PostalCode': { id: 'Mailing Zip', display: 'Zip/Postal Code', group: 'G2' },
                            'Country': { id: 'Mailing Country', display: 'Country', group: 'G2' }
                        }
                    }
                };
            } else {
                failureCallback('Invalid record type');
            }
            successCallback(def);
        },

        asyncGetDefinition: function (entityType) {
            var deferred = $q.defer();
            service.getDefinition(entityType,
                function (def) { deferred.resolve(def); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        //-- CRUD --//
        //  Create a record with data provided
        //      successCallback: function(recordId)
        //      data: { 
        //          type: 'lead' /* lead|contact|account */,
        //          record: { first: '', last: '', jobtitle: '', company: '', email: '', phone: '', phone2: '', website: '', bio: '', address1: '', address2: '', city: '', state: '', zip: '', country: '',  } /* capture record object */
        //      }
        //createRecord: function (data, successCallback, failCallback) {
        /**
        * @function createRecord
        * @description Creates record.
        * @memberOf captureApp.webServices.zoho
        * @param {recordType} recordType - Destination Record Type
        * @param {captureContact} captureRecord - Source Capture Record.
        * @param {object} createOptions - Options (For future use)
        * @param {captureApp.webServices.exportTargetVer1~createRecordSuccessCallback} successCallback 
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback
        */
        createRecord: function (recordType, captureRecord, createOptions, successCallback, failCallback) {

            var xmlreq = null;

            if (debug) { console.log(debug + 'createRecord', recordType, captureRecord, createOptions); }

            try {

                captureRecord.address = ((captureRecord.address1 ? captureRecord.address1 : '') +
                    (captureRecord.address2 ? ' ' + captureRecord.address2 : '')).trim();

                if (recordType.toUpperCase() === 'LEAD') {
                    if (captureRecord.last && captureRecord.company) {
                        xmlreq = service.xmlData(captureRecord, 'Leads');
                    }
                    else {
                        failCallback('Data must contain last and company name');
                        return;
                    }

                }
                if (recordType.toUpperCase() === 'ACCOUNT') {
                    if (captureRecord.company) {
                        xmlreq = service.xmlData(captureRecord, 'Accounts');
                    }
                    else {
                        failCallback('Data must contain Account name');
                        return;
                    }

                }
                if (recordType.toUpperCase() === 'CONTACT') {
                    if (captureRecord.last) {
                        var record = angular.copy(captureRecord);
                        // Set Account Name as in dialog
                        if (createOptions && createOptions.mappedProperties) {
                            var j = createOptions.mappedProperties.length;
                            while (j--)
                            { record[createOptions.mappedProperties[j].name] = createOptions.mappedProperties[j].label; }
                        }
                        xmlreq = service.xmlData(record, 'Contacts');
                    }
                    else {
                        failCallback('Data must contain last name');
                        return;
                    }

                }

                var token = store.token;

                //-----------------------edit-------------------------------------------------------------

                if (recordType.toUpperCase() === 'LEAD') {
                    service.createLead(xmlreq, token, successCallback);
                }
                else if (recordType.toUpperCase() === 'ACCOUNT') {
                    service.createAccount(xmlreq, token, successCallback);
                }
                else if (recordType.toUpperCase() === 'CONTACT')
                { service.createContact(xmlreq, token, successCallback); }


            } catch (e) { }
            //-----------------------edit [1]end-------------------------------------------------------------

        },


        createLead: function (xmlreq, token, successCallback, failCallback) {
            var url = 'https://crm.zoho.com/crm/private/xml/Leads/insertRecords?newFormat=1&authtoken=' + token + '&scope=crmapi';
            service.insertRecord(url, xmlreq, 'Leads', successCallback, failCallback);
        },

        createContact: function (xmlreq, token, successCallback, failCallback) {
            var url = 'https://crm.zoho.com/crm/private/xml/Contacts/insertRecords?newFormat=1&authtoken=' + token + '&scope=crmapi';
            service.insertRecord(url, xmlreq, 'Contacts', successCallback, failCallback);
        },

        createAccount: function (xmlreq, token, successCallback, failCallback) {
            var url = 'https://crm.zoho.com/crm/private/xml/Accounts/insertRecords?newFormat=1&authtoken=' + token + '&scope=crmapi';
            service.insertRecord(url, xmlreq, 'Accounts', successCallback, failCallback);
        },

        insertRecord: function (inserturl, xmlreq, nativeRecordType, successCallback, failCallback) {
            jQuery.ajax({
                method: 'post',
                url: inserturl,
                data: { xmlData: xmlreq },
                failure: function () {
                    failCallback('Please check your internet connection');
                },
                success: function (response) {
                    console.log(response);
                    var xmlText = new XMLSerializer().serializeToString(response),
                    xmlDoc = jQuery.parseXML(xmlText),
                    $xmldataresponse = jQuery(xmlDoc),
                    $message = $xmldataresponse.find('message').text();
                    if ($message.indexOf('successfully') > -1) {
                        var id = $xmldataresponse.find('recorddetail').children().first().text();
                        console.log('ZOHO ID', id);
                        var link = 'https://crm.zoho.com/crm/EntityInfo.do?module=' + nativeRecordType + '&id=' + id;
                        successCallback(link);
                    }
                    else {
                        failCallback('Record inserting Failled due to some technical problem');
                    }
                }
            });

        },

        //  Update an existing record with data
        //      successCallback: function(recordId)
        updateRecord: function (recordId, recordType, data, successCallback, failCallback) {

            try {

                var token = store.token;

                if (recordType.toUpperCase() === 'LEAD') {
                    recordType = 'Leads';
                } else if (recordType.toUpperCase() === 'ACCOUNT') {
                    recordType = 'Accounts';
                } else if (recordType.toUpperCase() === 'CONTACT') {
                    recordType = 'Contacts';
                }

                var captureRecord = service.fromNativeRecord(data, recordType);

                var xmlreq = service.xmlData(captureRecord, recordType);

                jQuery.ajax({
                    method: 'POST',
                    url: 'https://crm.zoho.com/crm/private/xml/' + recordType + '/updateRecords?authtoken=' + token + '&scope=crmapi&id=' + recordId,
                    data: { xmlData: xmlreq },
                    failure: function () {
                        failCallback('Please check your internet connection');
                    },
                    success: function (response) {

                        var xmlText = new XMLSerializer().serializeToString(response),
                        xmlDoc = jQuery.parseXML(xmlText),
                        $xmldataresponse = jQuery(xmlDoc),
                        $message = $xmldataresponse.find('message').text();
                        if ($message.indexOf('successfully') > -1) {
                            successCallback();
                        }
                        else {
                            console.log('ERROR returned by Zoho API', $message);
                            failCallback('Record does not exist');
                        }
                    }
                });

            } catch (e) {
                console.log('ERROR in updateRecord' + e.error);
                try { failCallback('Cannot update this record'); } catch (e) { }
            }

        },

        //  Retrieve record from service
        //      successCallback: function(recordId, data)
        retrieveRecord: function (recordId, recordType, successCallback, failCallback) {

            var token = store.token;

            var f = function (id, nativeRecordType) {

                jQuery.ajax({
                    method: 'POST',
                    url: 'https://crm.zoho.com/crm/private/json/' + nativeRecordType + '/getRecordById?newFormat=1&authtoken=' + token + '&scope=crmapi&id=' + id,
                    failure: function () {
                        try { failCallback('Please check your internet connection'); } catch (e) { }
                    },
                    success: function (response) {
                        try {
                            successCallback(response.response.result[nativeRecordType].row);
                        } catch (e) {
                            console.log('ERROR in retrieveRecord->POST' + e.error);
                            try { failCallback('Cannot retrieve this record'); } catch (e) { }
                        }
                    }
                });

            };

            try {

                if (recordType.toUpperCase() === 'LEAD') {
                    f(recordId, 'Leads');
                } else if (recordType.toUpperCase() === 'CONTACT') {
                    f(recordId, 'Contacts');
                }

            } catch (e) {
                console.log('ERROR in retrieveRecord' + e.error);
                try { failCallback('Cannot retrieve this record'); } catch (e) { }
            }

        },

        asyncRetrieveRecord: function (recordId, recordType) {
            var deferred = $q.defer();
            service.retrieveRecord(recordId, recordType,
                function (response) { deferred.resolve(response); },
                function (msg) { deferred.reject(msg); }
            );
            return deferred.promise;
        },

        //  Delete record from service
        //      successCallback: function(recordId)
        deleteRecord: function (recordId, successCallback, failCallback) {
            try { failCallback('Not implemented: deleteRecord'); } catch (e) { }
        },
        //-- /CRUD --//


        //-- Search --//
        //  Find a record using a query: { first:'', last:'', email:''} object
        //      successCallback: function(nativeRecords[])
        findRecord: function (recordType, query, fields, successCallback, failCallback) {

            if (debug) { console.log(debug + 'findRecord->type:', recordType, '->query:', query, '->fields:', fields); }

            
            var nativeRecordType = '';
            recordType = (recordType || '').toLowerCase();
            if (recordType === 'account') { nativeRecordType = 'Accounts'; }
            if (recordType === 'lead') { nativeRecordType = 'Leads'; }
            if (recordType === 'contact') { nativeRecordType = 'Contacts'; }
   


            var criteria = '';
            if (recordType === 'account') {

                if (query.company) {
                    criteria = '(Account Name:' + encode(query.company) + ')&selectColumns=Accounts(Account%20Name)';
                }
            }


            if (debug) { console.log(debug + 'findRecords->type:', nativeRecordType, '->criteria:', criteria); }
            var token = store.token;
            jQuery.ajax({
                method: 'POST',
                url: 'https://crm.zoho.com/crm/private/json/' + nativeRecordType + '/searchRecords?newFormat=1&authtoken=' + token + '&scope=crmapi&criteria=' + criteria,
                failure: function () {
                    try { failCallback('Please check your internet connection'); } catch (e) { }
                },
                success: function (response) {

                    try {

                        if (debug) { console.log(debug + 'findRecord->response:', response); }

                        if (response.response.error && response.response.error.message) {
                            try { failCallback(response.response.error.message); } catch (e) { }
                            return;
                        }

                        if (!response.response.nodata) {

                            var rows = response.response.result[nativeRecordType].row;

                            // single record?
                            if (!Array.isArray(rows)) {
                                rows = [rows];
                            }

                            try { successCallback(rows); } catch (e) { }

                        } else {

                            try { successCallback([]); } catch (e) { }

                        }

                    } catch (e) {
                        console.log('ERROR in findRecord', e);
                        try { failCallback('Record search failled'); } catch (e) { }
                    }

                }
            });

        },
        //-- /Search --//


        //-- Auth --//
        //  Authenticate with the service
        //      successCallback: function(authId)
        authenticate: function (credentials, successCallback, failCallback) {
            try {

                //--------------------EDIT------------------------------------------------------------
                jQuery.ajax({
                    method: 'Get',
                    url: url,
                    success: function (response) {
                        var regExp = /\AUTHTOKEN=([^*]+)\RESULT/;
                        var matches = regExp.exec(response);
                        if (matches === null) {
                            failCallback('Please open Settings and enter your valid user credentials or check Is user loggedIn into http://zoho.com/crm');
                        }
                        else {
                            successCallback();


                        }
                    }
                });
                //-------------------- END EDIT-----------------------------------------------------------------
            } catch (e) { }

        },

        //  is this client currently authenticated?
        //      return true/false
        isAuthenticated: function () {

        },
        //-- /Auth --//


        //-- Define --//
        //  Get a list of all available entities (lead, contact, account, etc)
        //      successCallback: function(entityList)
        listEntities: function (successCallback, failCallback) {
            try { failCallback('Not implemented: listEntities'); } catch (e) { }
        },

        //  Get the definition for an entity (field names of a lead or contact)
        //      successCallback: function(entityDefinition)
        defineEntity: function (entity, successCallback, failCallback) {
            try { failCallback('Not implemented: defineEntity'); } catch (e) { }
        },
        //-- /Define --//

        /**
        * @function findDuplicates
        * @description Returns an array of duplicate records of given type.
        * @memberOf captureApp.webServices.zoho
        * @param {captureContact} recordType - Record type. 
        * @param {captureContact} captureRecord - Source Capture Contact. 
        * @param {captureApp.webServices.exportTargetVer1~successCallback} successCallback - Pass the resulting array
        * @param {captureApp.webServices.exportTargetVer1~failCallback} failCallback  
        * @return {captureContact[]} - Array of Capture Contacts
        */
        findDuplicates: function (recordType, captureRecord, successCallback, failCallback) {

            var dups = [];

            var reponseHandle = null;
            var returnResponse = function () {
                try {
                    successCallback({ duplicates: dups });
                } catch (e) { }
            };

            var findRecords = function (criteria, nativeRecordType) {

                var token = store.token;

                if (debug) { console.log(debug + 'findRecords->type:', nativeRecordType, '->criteria:', criteria); }

                jQuery.ajax({
                    method: 'POST',
                    url: 'https://crm.zoho.com/crm/private/json/' + nativeRecordType + '/searchRecords?newFormat=1&authtoken=' + token + '&scope=crmapi&criteria=' + criteria,
                    failure: function () {
                        try { failCallback('Please check your internet connection'); } catch (e) { }
                    },
                    success: function (response) {

                        try {
                            if (debug) { console.log(debug + 'findRecords->response:', response); }

                            if (!response.response.nodata) {

                                var rows = response.response.result[nativeRecordType].row;

                                // single record?
                                if (!Array.isArray(rows)) {
                                    rows = [rows];
                                }

                                for (var i = 0, l = rows.length; i < l; i++) {

                                    var row = rows[i];

                                    var dup = service.fromNativeRecord(row, nativeRecordType);

                                    if (dup) {
                                        dups.push(dup);
                                    }
                                }
                            }

                            //try { successCallback({ duplicates: dups }); } catch (e) { }

                            if (reponseHandle) {
                                window.clearTimeout(reponseHandle);
                            }
                            reponseHandle = window.setTimeout(returnResponse, 2000);

                        } catch (e) {
                            console.log('ERROR in findRecords', e);
                            failCallback('Record search failled');
                        }

                    }
                });

            };

            var criteria = '';
            if (recordType.toUpperCase() === 'LEAD') {

                if (captureRecord.email) {
                    criteria = '(Email:' + encode(captureRecord.email) + ')';
                    findRecords(criteria, 'Leads');
                }

                if (captureRecord.last) {
                    criteria = '((Last Name:' + encode(captureRecord.last) + ')AND(First Name:' + encode(captureRecord.first) + '))';
                    findRecords(criteria, 'Leads');
                }

                if (captureRecord.email2) {
                    criteria = '(Email:' + encode(captureRecord.email2) + ')';
                    findRecords(criteria, 'Leads');
                }


            } else if (recordType.toUpperCase() === 'CONTACT') {

                if (captureRecord.email) {
                    criteria = '(Email:' + encode(captureRecord.email) + ')';
                    findRecords(criteria, 'Contacts');
                }

                if (captureRecord.last) {
                    criteria = '((Last Name:' + encode(captureRecord.last) + ')AND(First Name:' + encode(captureRecord.first) + '))';
                    findRecords(criteria, 'Contacts');
                }

                if (captureRecord.email2) {
                    criteria = '(Email:' + encode(captureRecord.email2) + ')';
                    findRecords(criteria, 'Contacts');
                }

            }



        }

    };
    return service;
}]);
'use strict';

/* global angular: false */

/**
 * @class captureApp.webServices.exportWrapperService
 * @memberOf captureApp.webServices  
 * @description This service wraps all other export services and is consumed by the client application.
 */

angular.module('webServices')
    .factory('exportWrapperService', [

        'salesforce', 'salesloft', 'dynamicsCrm', 'pipeliner', 'zoho', 'pcrecruiter', 'marketo', 'jobscience',

        function (salesforceService, salesloftService, dynamicsService, pipelinerService, zohoService, pcrecruiterService, marketoService, jobscienceService) {
            return {

                /**
                  * @function getService
                  * @description Return name of export target.
                  * @memberOf captureApp.webServices.exportWrapperService
                  * @param {serviceCode} serviceCode - Export service code.
                  */
                getService: function (serviceCode) {

                    //console.log('*** get service', serviceCode);

                    var exportService = null;

                    if (serviceCode === 'sf') { exportService = salesforceService; }
                    else if (serviceCode === 'sl') { exportService = salesloftService; }
                    else if (serviceCode === 'ms') { exportService = dynamicsService; }
                    else if (serviceCode === 'mk') { exportService = marketoService; }
                    else if (serviceCode === 'pc') { exportService = pcrecruiterService; }
                    else if (serviceCode === 'pp') { exportService = pipelinerService; }
                    else if (serviceCode === 'zh') { exportService = zohoService; }
                    else if (serviceCode === 'js') { exportService = jobscienceService; }


                    return exportService;
                },

                getServicesList: function (isProduction, licenseType) {

                    //console.log('*** get services list');

                    var crms = [];
                    //crms.push({ label: '- CSV Only -', value: 'no' });
                    crms.push({ label: marketoService.getName(), value: 'mk' });
                    crms.push({ label: dynamicsService.getName(), value: 'ms' });
                    if (licenseType && licenseType !== 'Free') {
                        crms.push({ label: pcrecruiterService.getName(), value: 'pc' });
                    }
                    //if (licenseType && licenseType !== 'Free') {
                    crms.push({ label: pipelinerService.getName(), value: 'pp' });
                    //}
                    if (!isProduction) {
                        crms.push({ label: salesloftService.getName(), value: 'sl' });
                    }
                    crms.push({ label: salesforceService.getName(), value: 'sf' });
                    crms.push({ label: zohoService.getName(), value: 'zh' });
                    if (licenseType && licenseType !== 'Free') {
                        crms.push({ label: jobscienceService.getName(), value: 'js' });
                    }
                    crms.push({ label: 'Other / No CRM', value: 'no' });

                    return crms;

                },

                validateService: function (service) {

                    console.log('Validating service');

                    var errors = [];

                    try {

                        if (!service) {
                            errors.push('Service object is required');
                        } else {

                            if (typeof service.getName !== 'function') { errors.push('Function "getName" is not implemented'); }
                            if (typeof service.login !== 'function') { errors.push('Function "login" is not implemented'); }
                            if (typeof service.init !== 'function') { errors.push('Function "init" is not implemented'); }
                            if (typeof service.logout !== 'function') { errors.push('Function "logout" is not implemented'); }
                            if (typeof service.isLoggedIn !== 'function') { errors.push('Function "isLoggedIn" is not implemented'); }
                            if (typeof service.createRecord !== 'function') { errors.push('Function "createRecord" is not implemented'); }
                            if (typeof service.updateRecord !== 'function') { errors.push('Function "updateRecord" is not implemented'); }
                            if (typeof service.getRequiredLookups !== 'function') { errors.push('Function "getRequiredLookups" is not implemented'); }
                            if (typeof service.getDefaultExportMaps !== 'function') { errors.push('Function "getDefaultExportMaps" is not implemented'); }
                            if (typeof service.getDefinition !== 'function') { errors.push('Function "getDefinition" is not implemented'); }
                            if (typeof service.toNativeRecord !== 'function') { errors.push('Function "toNativeRecord" is not implemented'); }
                            if (typeof service.fromNativeRecord !== 'function') { errors.push('Function "fromNativeRecord" is not implemented'); }
                            if (typeof service.findDuplicates !== 'function') { errors.push('Function "findDuplicates" is not implemented'); }
                            if (typeof service.retrieveRecord !== 'function') { errors.push('Function "retrieveRecord" is not implemented'); }
                            if (typeof service.validateRecord !== 'function') { errors.push('Function "validateRecord" is not implemented'); }

                        }

                    } catch (e) {
                        errors.push('Validation code failed: ' + e.message);
                    }

                    if (errors.length === 0) {
                        console.log('Service is valid');
                    } else {
                        console.log('Service is not valid!');
                        console.log('Errors:');
                        var i = errors.length;
                        while (i--) {
                            console.log('* ' + errors[i]);
                        }
                    }

                    return errors.length === 0;
                }

            };
        }

    ]);


'use strict';

/* global angular: false */

angular.module('webServices')
.factory('totangoService', ['$http','endpoints', 'userInfoStore',  function ($http, endpoints, userInfoStore) {
    var debug = false;

    var serviceUrl = endpoints.totangoService();
    //  Event IDs
    var eventMap = {
        login: { action:'login', module:'login' },
        capture: { action:'capture', module:'capture' },
        research: { action:'research', module:'research' },
        export: { action:'export', module:'export' },
        merge: { action:'merge', module:'merge' },
        search: { action: 'search', module: 'search' }
    };

    var statusMap = {
        Trial: { name:'Trial' },
        Standard: { name: 'Paid' },
        Bulk: { name: 'PaidBulk' },
        Canceled: { name:'Canceled' }
    };

    endpoints.onReady(function(){
            serviceUrl = endpoints.totangoService();
        });

    var service = {
        sendEvent: function(eventId, repeat){
            var eventObj = eventMap[eventId];
            if(!eventObj) {return;}

            var query = '?';
            //  API Key
            query += 'sdr_s=SP-7586-01';
            //  User account ID (unique)
            query += '&sdr_o=' + userInfoStore.getProfileEmail();
            //  User name
            query += '&sdr_odn=' + userInfoStore.getProfileName();
            //  User login
            query += '&sdr_u=' + userInfoStore.getProfileEmail();
            //  Action
            query += '&sdr_a=' + eventObj.action;
            //  Module
            query += '&sdr_m=' + eventObj.module;

            if (!repeat || repeat === 1) {
                if (debug) { console.log('totangoService.sendEvent...', (serviceUrl + query)); }
                $http.get(serviceUrl + query).success(function (response) {
                    if (debug) { console.log('totangoService.sendEvent:', response); }
                }).error(function (response, status) {
                    if (debug) { console.log('totangoService.sendEvent:', { response: response, status: status }); }
                });
            }
            else {
                if (debug) { console.log('totangoServiceProxy.sendEvent...', (serviceUrl + query)); }
                $http.get('http://account-staging.broadlook.com/api/v1/service/totango?n=' + repeat + '&e=' + encodeURIComponent(query)).success(function (response) {
                    if (debug) { console.log('totangoServiceProxy.sendEvent:', response); }
                }).error(function (response, status) {
                    if (debug) { console.log('totangoServiceProxy.sendEvent:', { response: response, status: status }); }
                });
            }
        },
        sendStatus: function(statusId){
            var statusObj = statusMap[statusId];
            if(!statusObj) {return;}

            var query = '?';
            //  API Key
            query += 'sdr_s=SP-7586-01';
            //  User account ID (unique)
            query += '&sdr_o=' + userInfoStore.getProfileEmail();
            //  Status
            query += '&sdr_o.Status=' + statusObj.name;
            if(debug){ console.log('totangoService.sendStatus...', (serviceUrl + query)); }
            $http.get(serviceUrl + query).success(function(response){
                if(debug){ console.log('totangoService.sendStatus:', response); }
            }).error( function(response, status){
                if(debug){ console.log('totangoService.sendStatus:', {response:response, status:status}); }
            });
        }
    };
    
    return service;
}]);
'use strict';

/* global angular: false */

angular.module('webServices')
.factory('linkedinService', ['xmlUtility', 'contactUtility', function (xmlUtility, contactUtility) {
     return {
          isProfile: function (html) {

               var res = false;

               if (html && html.length > 0) {

                  var s = '' + html;

                  var score = 0;

                  if (s.indexOf(' class="full-name') > 0) { score++; }
                  else if (s.indexOf(' class=\'full-name') > 0) { score++; }

                  if (s.indexOf(' class="given-name') > 0) { score++; }
                  else if (s.indexOf(' class=\'given-name') > 0) { score++; }

                  if (s.indexOf(' class="family-name') > 0) { score++; }
                  else if (s.indexOf(' class=\'family-name') > 0) { score++; }

                  if (s.indexOf(' class="locality') > 0) { score++; }
                  else if (s.indexOf(' class=\'locality') > 0) { score++; }

                  if (s.indexOf(' id="overview-summary-current-title') > 0) { score++; }
                  else if (s.indexOf(' id=\'overview-summary-current-title') > 0) { score++; }

                  if (score >= 2) { res = true; }
               }


               return res;
          },

          parseProfile: function (html, url) {
               var contacts = [];
               var c, ci, ctop;

               if (!html || html.length === 0) { return contacts; }
               var contact = contactUtility.createNewContact();


               contact.sourceurl = url;
               contact._diveable = true;

               var s = xmlUtility.getTagValue(html, 'div', 'profile', ' id=');
               //console.log('s-1', s.length, s.substring(0, 50));

               if (!s || s.length < 10000) {
                   s = html;
               }

               var topArea = xmlUtility.getTagValue(s, 'div', 'top-card');
               if (!topArea) { topArea = xmlUtility.getTagValue(html, 'div', 'top-card'); }
               //console.log('top-1', topArea.length, topArea.substring(0, 50));
               if (!topArea) { topArea = s; }

               var nameContainer = xmlUtility.getTagValue(html, 'div', 'name-container', ' id=');
               if (!nameContainer) { nameContainer = topArea; }

               contact.first = xmlUtility.getTagValue(nameContainer, 'span', 'given-name');
               //console.log('fn: ' + contact.first);
               contact.last = xmlUtility.getTagValue(nameContainer, 'span', 'family-name');
               //console.log('ln: ' + contact.last);

               if (!contact.last) {
                   var full = xmlUtility.getTagValue(nameContainer, 'span', 'full-name');
                  //console.log('full: ' + full);
                  if (full) {
                      var fullParts = full.split(' ');
                      if (fullParts.length > 0) {
                          contact.last = fullParts.pop();
                          contact.first = fullParts.join(' ');

                          //console.log('fn: ' + contact.first);
                          //console.log('ln: ' + contact.last);
                      }
                  }
               }

               contact.full = contactUtility.fixFullName(contact.full, contact.first, contact.last, contact.middle);
               var fixedName = contactUtility.splitFullName(contact.full);
               //console.log('fixedName', fixedName);
               if (fixedName) {
                  contact.first = fixedName.first;
                  contact.last = fixedName.last;
                  contact.middle = fixedName.middle;
               }




               var titles = [];

               if (!contact.jobtitle) {
                  c = xmlUtility.getTagValueWithPosition(s, 'a', 'title', 'name=');
                  if (c.value && contactUtility.isTitle(c.value)) {
                       titles.push(c);
                       //console.log('jt-a-title-name', c);
                  }
               }

               if (!contact.jobtitle) {
                  c = xmlUtility.getTagValueWithPosition(s, 'span', 'title');
                  if (c.value && contactUtility.isTitle(c.value)) {
                       titles.push(c);
                       //console.log('jt-span-title', c);
                  }
               }

               if (!contact.jobtitle) { // main title under name
                  c = xmlUtility.getTagValueWithPosition(s, 'p', 'title');
                  if (c.value && contactUtility.isTitle(c.value)) {
                       titles.push(c);
                       //console.log('jt-p-title', c);
                  }
               }

               if (!contact.jobtitle) {
                  c = xmlUtility.getTagValueWithPosition(s, 'p', 'headline-title');
                  if (c.value && contactUtility.isTitle(c.value)) {
                       titles.push(c);
                       //console.log('jt-p-headline-title', c);
                  }
               }

               // pick a winner
               {
                  //console.log('titles', titles);
                  ci = titles.length;
                  ctop = { value: '', position: -1 };
                  var ctop2 = { value: '', position: -1 };
                  while (ci--) {
                      if (titles[ci].value !== 'Relationship' && titles[ci].value.length > 0 && titles[ci].value.length < 100) {
                           if (ctop.position < 0 || ctop.position > titles[ci].position) {
                               ctop = titles[ci];
                           }
                           else if (ctop2.position < 0 || ctop2.position > titles[ci].position) {
                               ctop2 = titles[ci];
                           }
                       }
                  }
                  ctop.value = xmlUtility.removeTags(ctop.value);
                  ctop2.value = xmlUtility.removeTags(ctop2.value);
                  if (ctop2.value.length > 2 && ctop.value.length > 30) {
                      ctop = ctop2;
                  }
                  contact.jobtitle = ctop.value;
                  //console.log('jt-winner: ' + contact.jobtitle);
               }

               if (contact.last && contact.last.indexOf('(') >= 0) {
                  if (!contact.jobtitle) {
                       var jt = contact.last.substring(contact.last.indexOf('(') + 1);
                       jt = jt.replace(')', '').trim();
                       if (contactUtility.isTitle(jt)) {
                           contact.jobtitle = jt;
                           //console.log('jt-from-name: ' + contact.jobtitle);
                       }
                  }
                  contact.last = contact.last.substring(0, contact.last.indexOf('(') - 1).trim();
               }

               contact.city = xmlUtility.removeTags(xmlUtility.getTagValue(s, 'span', 'locality'));
               //console.log('city: ' + contact.city);

               var companies = [];

               var backgroundArea = xmlUtility.getTagValue(s, 'div', 'profile-background');
               //console.log('SS = ' + backgroundArea.length);

               var cutoffPos = backgroundArea.indexOf('<div id="aux"');
               if (cutoffPos > 0) {
                   backgroundArea = backgroundArea.substring(0, cutoffPos);
                   //console.log('SS = ' + backgroundArea.length);
               }
               //console.log(backgroundArea.substring(0, 100));
               //console.log(backgroundArea);
               if (!backgroundArea) { backgroundArea = s; }

               c = xmlUtility.getTagValueWithPosition(backgroundArea, 'a', 'company-profile-public');
               
               if (c.value) {
                   var puburl = backgroundArea.substring(c.position - 200, c.position);
                   if (puburl.indexOf('href=') >= 0) {
                       //console.log('COMPANY URL-1', puburl);
                       puburl = puburl.substring(puburl.indexOf('href=') + 6);
                       //console.log('COMPANY URL-2', puburl);
                       puburl = puburl.substring(0, puburl.indexOf('"'));
                       //console.log('COMPANY URL-3', puburl);

                       if (puburl.indexOf('/company/') > 0 || puburl.indexOf('/companies/') > 0) {
                           if (!contact.venues)
                           { contact.venues = []; }
                           contact.venues.push({ website: puburl, type: 'linkedin' });
                           //console.log('COMPANY URL FOUND', contact.venues);
                       }
                   }
                   //console.log('COMPANY URL', puburl, c);
               }

               c = xmlUtility.getTagValueWithPosition(backgroundArea, 'span', 'org summary');
               c.value = xmlUtility.removeTags(c.value);
               if (c.value) {
                  companies.push(c);
                  //console.log('c-span-org-summary', c);
               }

               c = xmlUtility.getTagValueWithPosition(backgroundArea, 'a', 'company', 'href=');
               c.value = xmlUtility.removeTags(c.value);
               if (c.value) {
                  companies.push(c);
                  //console.log('c-a-company-href', c);
               }

               c = xmlUtility.getTagValueWithPosition(backgroundArea, 'a', 'company', 'name=');
               c.value = xmlUtility.removeTags(c.value);
               if (c.value) {
                  companies.push(c);
                  //console.log('c-a-company-name', c);
               }

               {
                    var backgroundExpArea = xmlUtility.getTagValue(backgroundArea, 'div', 'background-experience-container', ' id=');
                    if (!backgroundExpArea) { backgroundExpArea = backgroundArea; }

                    var cc = xmlUtility.getTagValues(backgroundExpArea, 'span', 'miniprofile-container');
                    ci = cc.length;
                    while (ci--) {
                        c = cc[ci];
                        c.value = xmlUtility.removeTags(c.value);
                        if (c.value) {
                            companies.push(c);
                            //console.log('c-span-miniprofile-container', c);
                        }
                    }
               }


               var titleParts;


               if (contact.jobtitle.indexOf(' @ ') > 0) { //  Chairman at XYZ Company Limited @ john.doe@gmail.com
                  titleParts = contact.jobtitle.split(' @ ');
                  if (titleParts.length > 1) {
                       contact.jobtitle = titleParts[0];
                       // so far only email is expected after " @ "
                       if (titleParts[1].indexOf('@') > 0) {
                           if (contact.email === null || contact.email.length < titleParts[1].length) {
                               contact.email = titleParts[1];
                           }
                       }
                  }
               }


               var companyInTitle = null;

               if (contact.jobtitle.indexOf(' at ') > 0) {
                  titleParts = contact.jobtitle.split(' at ');
                  if (titleParts.length > 1) {
                       contact.jobtitle = titleParts[0];
                       companyInTitle = titleParts[1];
                       //console.log('companyInTitle: ' + companyInTitle);
                  }

               }

               // pick a winner
               {
                  //console.log('companies', companies);

                  if (companyInTitle) {
                       ci = companies.length;
                       while (ci--) {
                           if (companies[ci].value === companyInTitle) {
                               contact.company = companies[ci].value;
                               //console.log('c-winner-as-in-title: ' + contact.company);
                           }
                       }
                  }

                  if (!contact.company) {
                       ci = companies.length;
                       ctop = { value: '', position: -1 };
                       while (ci--) {
                           if (ctop.position < 0 || ctop.position > companies[ci].position) {
                               ctop = companies[ci];
                           }
                       }
                       contact.company = ctop.value;
                       //console.log('c-winner: ' + contact.company);
                  }
               }

               // validation
               contact.company = contactUtility.fixCompany(contact.company);
               contact.jobtitle = contactUtility.fixTitle(contact.jobtitle, contact.company);

               // get source url

               var x = xmlUtility.getTagValue(topArea, 'dl', 'public-profile');
               //console.log('SOURCE URL 1-0', contact.sourceurl, x);
               if (x) {
                  x = xmlUtility.getTagValue(x, 'dd');
                  if (x) {
                      if (x.indexOf('</a>') > 0)
                      { x = x.substring(0, x.indexOf('</a>') + 4); }
                       x = xmlUtility.removeTags(x);
                       if (x && x.indexOf('.com') >= 0) {
                           contact.sourceurl = x;
                           //console.log('SOURCE URL 1-1', contact.sourceurl);
                       }
                  }
               }

               var contactArea = xmlUtility.getTagValue(html, 'div', 'contact-container');
               
               if (!contact.sourceurl || !this.isIndividualPublicProfile(contact.sourceurl)) {
                   x = xmlUtility.getTagValue(contactArea, 'li', 'relationship-public-profile-link', 'id=');
                   //console.log('SOURCE URL 2-0', x);
                   if (x) {
                       contact.sourceurl = xmlUtility.getAttrValue(x, 'a', 'href');
                       //console.log('SOURCE URL 2-1', contact.sourceurl);
                   }
               }

               //if (!contact.sourceurl) {
               //    var x = xmlUtility.getTagValue(topArea, 'dl', 'public-profile');
               //    if (x) {
               //        x = xmlUtility.getTagValue(x, 'dd');
               //        if (x) {
               //            x = xmlUtility.removeTags(x);
               //            if (x && x.indexOf('.com') >= 0) {
               //                contact.sourceurl = x;
               //            }
               //        }
               //    }
               //}

              // get website from Company website
               
               x = xmlUtility.getTagValue(contactArea, 'li', 'relationship-site-Company', 'id=');
               //console.log('WEBSITE', x);
               if (x) {
                   contact.website = xmlUtility.getAttrValue(x, 'a', 'href');
               }


               // get email from summary

               var email = contactUtility.getEmail(backgroundArea, contact.first, contact.last, contact.company);
               if (email) {
                  //console.log('email: ' + email);
                  contact.email = email;

                  if (!contact.website) {
                       var d = contactUtility.getDomain(contact.email);
                       if (d && !contactUtility.isFreeEmailDomain(d)) {
                           contact.website = d;
                       }
                  }
               }

               // get phone number
               var phoneStr = contactUtility.getPhone(backgroundArea);
               if (phoneStr) {
                   //console.log('phoneStr: ' + phoneStr);
                   if (!contact.phone) { contact.phone = contactUtility.formatPhone(phoneStr); }
                   else if (!contact.phone2) { contact.phone2 = contactUtility.formatPhone(phoneStr); }
               }

               console.log('Parsed from linkedin:', contact);
               //     bug with our linkedin showing raw html in items and maxing out storage for the 4,096 bytes per item rule.  Do some stripping here
               for(var fieldKey in contact){
                    if((typeof contact[fieldKey]) !== 'string') { continue; }
                    if(contact[fieldKey].length <= 200) { continue; }
                    contact[fieldKey] = contact[fieldKey].substring(0,199);
               }

               contacts.push(contact);



               return contacts;
          },

          isIndividualProfile: function (url) {
               // Is this source URL an indinividual profile
               if (!url) { return false; }
               if (url.indexOf('#SELECTION') > 0) { return false; }
               if (url.indexOf('inkedin.com/in/') > 0) { return true; }
               if (url.indexOf('inkedin.com/pub/') > 0) { return true; }
               if (url.indexOf('inkedin.com/profile/') > 0) { return true; }
               return false;
          },

          isIndividualPublicProfile: function (url) {
              // Is this source URL an indinividual profile
              if (!url) { return false; }
              if (url.indexOf('#SELECTION') > 0) { return false; }
              if (url.indexOf('inkedin.com/in/') > 0) { return true; }
              if (url.indexOf('inkedin.com/pub/') > 0) { return true; }
              return false;
          }

     };
}]);

'use strict';

/* global angular: false */

angular.module('webServices')
.factory('googleService', ['$http', 'endpoints', 'xmlUtility', 'contactUtility', function ($http, endpoints, xmlUtility, contactUtility) {
    return {
        //  Key to use
        key: {
            production: 'AIzaSyBBbtTewu8t0jQCGbJJtCAWVPuO7gF9lPE',
            current: function(){ return this.production; }
        },

        //  Debugging level
        debug: true,

        //  successCallback: function(profile)
        //  failureCallback: function(errorMessage)
        getProfile: function (token, successCallback, failureCallback) {
            var debug = this.debug;
            var url = endpoints.googlePlusService() + '?key=' + this.key.current();
            var config = {
                headers: {'Authorization': 'Bearer ' + token }
            };
            var profile = {};

            if(debug) {console.log('googleService.getProfile...', {url:url, config:config});}


            $http.get(url, config)
                .success(function(response){
                    if(debug) { console.log('google getProfile():', response); }
                    if( response.displayName ){
                        profile.name = response.displayName;
                    }
                    if (response.emails && response.emails.length > 0) {
                        profile.email = response.emails[0].value;
                    }
                    if (response.occupation) {
                        profile.title = response.occupation;
                    }
                    if (response.organizations && response.organizations.length > 0) {
                        profile.company = response.organizations[0].name;
                        profile.title = response.organizations[0].title;
                    }
                    try{ successCallback(profile); } catch(e){}
                })
                .error(function(data, status, headers, config){
                    if(debug) { console.log('google getProfile() error:' + status, data ); }
                    // TODO: Catch individual status codes here
                    try{ failureCallback('(' + status + ')' + data); } catch(e){}
                });
        },



        //  Legacy
          isGoogle: function (html) {

               var res = false;
               var score = 0;

               if (html && html.length > 0) {

                  var s = '' + html;



                  //if (s.indexOf('<cite class="_Fe') > 0) score++;
                  //else if (s.indexOf("<cite class='_Fe") > 0) score++;
                  var p = 0;
                  while (p >= 0) {
                       p = s.indexOf('<cite class=', p + 1);
                       if (p > 0) {
                           var l = s.indexOf('inkedin.com', p + 1);
                           if (l - p < 40) { score += 1; }
                       }
                  }

                  if (score >= 1){ res = true; }
               }

               console.log('google score: ' + score);
               return res;
          },

          parseGoogle: function (html, sourceUrl) {

               var pairs;
               var contacts = [];


               if (!html || html.length === 0) { return contacts; }

               var p1 = 0;

               p1 = html.indexOf('<div class="g"', p1);

               console.log('GOOGLE> html len', html.length);
               while (p1 >= 0) {

                  var p2 = html.indexOf('<div class="g"', p1 + 1);
                  var s = html.substring(p1, p2 < 0 ? html.length : p2);
                  var h3 = xmlUtility.getTagValue(s, 'h3', 'r');
                  var divlocttl = xmlUtility.getTagValue(s, 'div', 'f slp');

                  var full = xmlUtility.removeTags(xmlUtility.getTagValue(h3, 'a'));
                  var url1 = xmlUtility.removeTags(xmlUtility.getAttrValue(h3, 'a', 'href')); // link URL - with "http://"
                  var url2 = xmlUtility.removeTags(xmlUtility.getTagValue(s, 'cite', '')); // displayed URL - without "http://"

                  //contact.website = url;

                  var contact = contactUtility.createNewContact();
                  contact.sourceurl = sourceUrl;
                   contact.sourcetitle = full;
                  //console.log('divlocttl');
                  //console.log(divlocttl);

                  var locttl = xmlUtility.removeTags(divlocttl);

                  var loc = locttl;
                  var ttl = '';
                  var company = '';

                  if (locttl && locttl.indexOf(' - ') > 0) {

                       pairs = locttl.split(' - ');
                       // console.log(pairs);
                       if (pairs.length > 0) { loc = pairs[0]; }
                       if (pairs.length > 1) { ttl = pairs[1]; }
                       if (pairs.length > 2) { company = pairs[2]; }

                       if (ttl && ttl.indexOf(' at ') > 0) {

                           pairs = ttl.split(' at ');
                           if (pairs.length > 0) { ttl = pairs[0]; }
                           if (pairs.length > 1) { company = pairs[1]; }
                           console.log('ttl-1', ttl, 'company', company);
                       }


                       if (ttl && ttl.indexOf(' @ ') > 0) {

                           pairs = ttl.split(' @ ');
                           if (pairs.length > 0) { ttl = pairs[0]; }
                           if (pairs.length > 1) { company = pairs[1]; }
                           console.log('ttl-2', ttl, 'company', company);
                       }

                      /* jshint -W100 */

                       if (ttl && ttl.indexOf(' ' + String.fromCharCode(8211) + ' ') > 0) { // use this dash: "�" is \u8211
                           pairs = ttl.split(' ' + String.fromCharCode(8211) + ' ');
                           if (pairs.length > 0) { ttl = pairs[0]; }
                           console.log('ttl-3', ttl);
                       }

                      /* jshint +W100 */

                       console.log('ttl', ttl, ttl.indexOf('&#8211;'));

                  }
                  //console.log(loc, ttl, company);

                  contact.city = loc;
                  contact.jobtitle = ttl;
                  contact.company = company;

                  contact.last = '';
                  contact.first = '';


                  if (full) {
                       if (full.indexOf('|') > 0) {
                           full = full.split('|')[0].trim();
                       }

                       if (full.indexOf(',') > 0) {
                           full = full.split(',')[0].trim();
                       }

                       if (full.indexOf(' - ') > 0) {
                           full = full.split(' - ')[0].trim();
                       }


                       if (full.indexOf(' ') > 0) {
                           var parts = full.split(' ');

                           contact.last = parts.pop();
                           contact.first = parts.join(' ');
                       }
                  }

                  if (!contact.last) {
                       contact.last = full;
                       contact.frist = '';
                  }

                  contact.sourceurl = url2; // redirect?
                  contact._diveable = true;

                  // validation
                  contact.company = contactUtility.fixCompany(contact.company);
                  contact.jobtitle = contactUtility.fixTitle(contact.jobtitle, contact.company);

                  contacts.push(contact);
                  p1 = p2;
               }


               return contacts;
          }

     };
}]);

'use strict';

/* global angular: false */
/* global $: false */

angular.module('webServices')
.factory('captureService', ['linkedinService', 'googleService', 'parsingService', 'chromeUtility', 'contactUtility', function (linkedinService, googleService, parsingService, chromeUtility, contactUtility) {
    return {

        //     Auto detect input source and parsing type
        autoCapture: function (options, successCallback, failureCallback) {
            chromeUtility.getCaptureInput(options, function (response) {
                console.log('Input:', response);
                var html = response.data;
                var url = response.url;
                if (linkedinService.isProfile(html)) {
                    console.log('Parsing linkedin....');
                    successCallback(linkedinService.parseProfile(html, url));

                } else if (googleService.isGoogle(html, url)) {
                    console.log('Parsing google....');
                    successCallback(googleService.parseGoogle(html));

                } else {
                    console.log('Calling parsing service...');
                    parsingService.capture(html, url, 'text/html', successCallback, failureCallback);
                }

            }, function (error) {

                console.log('Input Error:', error);
                failureCallback(error);
            });

        },

        //patternCapture: function (patterns, successCallback, failureCallback, precapturedData, sourceUrl) {
        patternCapture: function (options, successCallback, failureCallback) {
            options = options || {};
            var patterns = options.patterns;
            var precapturedData = options.precapturedData;
            var sourceUrl = options.sourceUrl;
            var selection = options.selection;

            var debug = 'webServices->capture.js->'; debug = false;

            var bb = [];

            var processContact = function (Data) {

                if (debug) { console.log(debug + 'Processing contact', angular.copy(Data)); }

                var b = contactUtility.createNewContact();

                contactUtility.readPatternRecord(Data, b);

                if (sourceUrl) {
                    if (!b.sourceurl) { b.sourceurl = sourceUrl; }
                }


                // treat Handle as Name
                if (b.handle && (!b.last || !b.first)) {
                    if (debug) { console.log(debug + 'handle', b.handle, 'last', b.last, 'first', b.first); }
                    b.full = contactUtility.fixFullName(b.handle);

                    var nameObject = contactUtility.splitFullName(b.full);

                    b.last = nameObject.last;
                    b.first = nameObject.first || ' ';
                    //b.middle = nameObject.middle;
                    if (debug) { console.log(debug + 'handle', b.handle, 'last', b.last, 'first', b.first); }
                }

                if (!b.handle && b.last && !b.first) { // remove this code once handle is implemented
                    if (debug) { console.log(debug + 'handle-temp', 'last', b.last, 'first', b.first); }
                    b.first = ' ';
                }

                if (debug) { console.log(debug + 'adding contact', angular.copy(b)); }

                bb.push(b);
            };


            var processPatternResults = function (aa) {

                var i, j;

                if (debug) { console.log(debug + 'processPatternResults->', angular.copy(aa)); }

                if (aa.Name) {

                    if (aa.Name === 'Search Results Page') {
                        for (j = 0; j < aa.Data[0].Data.length; j++) {
                            processContact(aa.Data[0].Data[j].Data);
                        }
                    }
                    else {
                        processContact(aa.Data);
                    }
                }
                else {
                    for (i = 0; i < aa.length; i++) {
                        var a = aa[i];

                        //if (debug) { console.log(debug + 'Received contact ' + i, angular.copy(a)); }

                        if (a.Name === 'Profiles') {
                            for (j = 0; j < a.Data.length; j++) {
                                processContact(a.Data[j].Data);
                            }
                        } else if (a.Name === 'root' || a.Name === 'IFrame') {
                            processPatternResults(a.Data);
                        } else if (a.Name === 'Search Results Page') {
                            for (j = 0; j < a.Data[0].Data.length; j++) {
                                processContact(a.Data[0].Data[j].Data);
                            }
                        } else {
                            processContact(a.Data);
                        }
                    }
                }

            };

            if (precapturedData) {

                if (debug) { console.log(debug + 'Processing pre-captured data:', precapturedData, sourceUrl); }

                if (precapturedData.length) {
                    for (var i = 0; i < precapturedData.length; i++) {
                        processPatternResults(precapturedData[i].Data, i < (precapturedData.length - 1));
                    }
                }
                else {
                    processPatternResults(precapturedData.Data);
                }
                successCallback(bb);
                return;
            }

            if (debug) { console.log(debug + 'Attempting pattern capture:', patterns); }
            chromeUtility.doPatternCapture(patterns, function (response) {
                if (debug) { console.log(debug + 'Pattern Capture response:', angular.copy(response)); }

                var aa = angular.copy(response.data.Values.Data);

                sourceUrl = response.data.Url;

                processPatternResults(aa);
                successCallback(bb);

            }, function (error) {
                console.log('Pattern Capture Error:', error);
                failureCallback(error);
            });

        },

        //     Manually provide the data and type
        manualCapture: function (data, format, successCallback, failureCallback) {
            if (format === undefined || format === 'auto') {
                //     Auto detect formatting
                console.log('Auto detecting formatting...');
                format = 'text/plain';
                if (this.isTSV(data)) {
                    console.log('TSV detected, converting to CSV!');
                    data = this.convertTsvToCsv(data);
                }
                if (this.isCSV(data)) {
                    console.log('CSV detected!');
                    format = 'text/csv';
                }
            }

            console.log('Calling parsing service...');
            parsingService.capture(data, undefined, format, successCallback, failureCallback);

        },

        isCSV: function (data) {
            var lines = data.split(/\r?\n|\r/);
            if (lines.length <= 1) { return false; }
            for (var lineIndex in lines) {
                if (lines[lineIndex].split(',').length <= 1) {
                    return false;
                }
            }
            return true;

        },

        isTSV: function (data) {
            var lines = data.split(/\r?\n|\r/);
            if (lines.length <= 1) { return false; }
            for (var lineIndex in lines) {
                if (lines[lineIndex].split('\t').length <= 1) {
                    return false;
                }
            }
            return true;
        },
        convertTsvToCsv: function (data) {
            var lines = data.split(/\r?\n|\r/);
            var result = '';
            for (var lineIndex in lines) {
                var line = lines[lineIndex];
                var newLine = '';
                var values = line.split('\t');
                for (var valueIndex in values) {
                    if (newLine.length > 0) { newLine += ','; }
                    newLine += '"' + values[valueIndex] + '"';
                }
                if (result.length > 0) { result += '\r\n'; }
                result += newLine;


            }
            return result;
        }





    };
}]);

'use strict';

/* global angular: false */

angular.module('captureApp')
.controller('header', ['$scope', '$location', 'salesforce',
    function ($scope, $location, salesforce) {

        $scope.exportTarget = 'Salesforce';
        $scope.exportTargetState = false;

        $scope.refresh = function(){
            if (!$scope.$$phase) { $scope.$apply(); }
        };

        salesforce.isLoggedIn(function(){
            $scope.exportTargetState = true;
            $scope.refresh();
        });

        $scope.configureExportTarget = function(){
            salesforce.login();
        };

        $scope.signOut = function(){
            //  With auto signin, no need to sign out
        };

        $scope.register = function(){
            $location.path('/register');
        };

        $scope.subscription = function(){

        };

        $scope.settings = function(){

        };


    }]);
'use strict';

/* global angular: false */

angular.module('captureApp')
.controller('home', ['$scope', '$location', 'docSize', 'dialogs', 'environmentUtility',
    function ($scope, $location, docSize, dialogs, environmentUtility) {
        //docSize.setSize(480, 500);

        environmentUtility.onLoaded(function(){
                $scope.isLocal = environmentUtility.isRelease('local');
            });

        //  Testing buttons
        $scope.TESTA = function(){
            dialogs.confirm.show('This is a local test button...').confirm(function(){console.log('confirm');}).cancel(function(){console.log('cancel');});
        };
        $scope.TESTB = function(){

        };
        $scope.TESTC = function(){

        };
        $scope.TESTD = function(){

        };

        $scope.global = { version: null, license: null };

        $scope.subscription = function () {
            $location.path('/subscription');
        };

    }]);

'use strict';

/* global angular: false */

angular.module('captureApp')
.controller('register', ['$scope', '$q', '$location', 'docSize', '$http', 'registrationService', 'chromeUtility', 'googleService', 'userInfoStore', 'totangoService', 'exportWrapperService', 'modals',
    function ($scope, $q, $location, docSize, $http, registrationService, chromeUtility, googleService, userInfoStore, totangoService, exportWrapperService, modals) {
        $scope.debug = 'register.js->';

        //docSize.setWidth(480);
        docSize.setSize(600, 500);

        $scope.profile = {};
        $scope.errorMsg = undefined;
        $scope.registering = false;
        $scope.emailLocked = false;

        $scope.refresh = function () {
            if (!$scope.$$phase) { $scope.$apply(); }
        };

        //  Get google profile info for registration

        $scope.profile.name = userInfoStore.getProfileName();
        $scope.profile.title = userInfoStore.getProfileTitle();
        $scope.profile.company = userInfoStore.getProfileCompany();
        $scope.profile.phone = userInfoStore.getProfilePhone();
        $scope.profile.target = userInfoStore.getProfileTarget();

        if (userInfoStore.getProfileEmail()) {
            $scope.profile.email = userInfoStore.getProfileEmail();
            $scope.emailLocked = true;
        } else {
            if ($scope.debug) { console.log('Retrieveing google+ profile...'); }
            googleService.getProfile(chromeUtility.getAuthToken(), function (profile) {
                if ($scope.debug) { console.log('Google profile retrieved', profile); }
                $scope.profile.email = profile.email;
                $scope.profile.name = profile.name;
                $scope.profile.company = profile.company;
                $scope.profile.title = profile.title;

                if (profile.email) { $scope.emailLocked = true; }
                //$scope.profile = profile;
                $scope.refresh();

                // already registered and new installation on this computer?
                const functionName = 'Registration > Me';
                registrationService.me({ email: $scope.profile.email }, function (response) {

                    console.log(functionName, response);

                    if (!response || !response.sitekey) {
                        return;
                    }

                    $scope.profile.company = response.company;
                    $scope.profile.phone = response.phone;
                    $scope.profile.title = response.title;
                    $scope.profile.target = response.target;

                    $scope.refresh();

                }, function (error) {
                    console.error(functionName + ' > Me', error);
                });

            });
        }

        $scope.targets = exportWrapperService.getServicesList();
        /*
        Never bypass registration if it is requested
        //  check our registration status
        registrationService.isRegistered(function(){
            $location.path('/home');
            $scope.refresh();
        }, function(){
            //  Get our profile data to pre-populate form for them

        });
        */

        $scope.accept = function () {

            $q.when({})
                .then(modals.eulaSelector({ title: 'License Agreement' }))
                .then(function (result) {
                    console.log('EULA Acceptance > ', result);
                    if (result) {
                        $scope.register();
                    }
                });


        };

        $scope.register = function () {
            //  Validate
            if (!$scope.profile.name) { return 'You must include all required fields!'; }
            if (!$scope.profile.email) { return 'You must include all required fields!'; }
            if (!$scope.profile.title) { return 'You must include all required fields!'; }
            if (!$scope.profile.company) { return 'You must include all required fields!'; }
            if (!$scope.profile.phone) { return 'You must include all required fields!'; }
            if (!$scope.profile.target) { return 'You must include all required fields!'; }

            userInfoStore.setProfileName($scope.profile.name);
            userInfoStore.setProfileEmail($scope.profile.email);
            userInfoStore.setProfileTitle($scope.profile.title);
            userInfoStore.setProfileCompany($scope.profile.company);
            userInfoStore.setProfilePhone($scope.profile.phone);
            userInfoStore.setProfileTarget($scope.profile.target);

            $scope.errorMsg = undefined;
            $scope.registering = true;

            //  Finish
            registrationService.register($scope.profile, function () {
                if ($scope.debug) { console.log('Registration successful!'); }
                totangoService.sendEvent('login');
                console.log('***** KEY = ', $scope.profile.key);
                if ($scope.profile.key) {
                    // update license
                    console.log('***** RELOAD LICENSE');
                    chromeUtility.setField('license', null);
                    //mySharedService.broadcast('refreshLicense');
                }
                $location.path('/home');
                $scope.refresh();


            }, function (errorMessage) {
                console.error('Registration failure!', errorMessage);
                $scope.errorMsg = errorMessage;
                $scope.registering = false;
            });

        };


        $scope.back = function () {
            $location.path('/home');
        };

    }]);
'use strict';

/* global angular: false */

angular.module('captureApp')
.controller('subscription', ['$scope', '$location', 'registrationService', 'totangoService', 'mySharedService', 'storeService', 'docSize', 'dialogs', 'chromeUtility',
    function ($scope, $location, registrationService, totangoService, mySharedService, storeService, docSize, dialogs, chromeUtility) {

        var debug = 'subscription.js->';
        $scope.loading = false;

        //docSize.setWidth(480);
        docSize.setSize(600, 500);

        if (debug) { console.log(debug + 'init'); }

        $scope.license = {
            date: null, subscribed: false, subStatus: 'No license', exp: null,
            limits: [],
            pageTokens: 0, listTokens: 0, companyTokens: 0, contactTokens: 0
        };

        $scope.back = function () {
            $location.path('/home');
        };

        $scope.refreshAccount = function () {

            $scope.refreshingAccount = true;
            $scope.loading = true;
            $scope.license = {};

            registrationService.getLimits(function (license) {

                $scope.license = angular.copy(license);

                console.log('saving license to storage', $scope.license);

                //chrome.storage.sync.set({ 'license': $scope.license }, function () {
                //    //NOTE: Dates(=objects) will be lost, that why we need ...MS properties
                //    var error = chrome.runtime.lastError;
                //    if (!error) {
                //        if (debug) { console.log('license was saved to storage'); }
                //    }
                //    else {
                //        console.log('ERROR: license was not saved to storage', error);
                //    }
                //});

                chromeUtility.setField('license', $scope.license,

                     function () {
                         if (debug) { console.log('license was saved to storage'); }
                     },

                     function (error) {
                         console.log('ERROR: license was not saved to storage', error);
                     }

                 );

                totangoService.sendStatus($scope.license.licenseType);

                $scope.applyLicense();
                $scope.loading = false;

            }, function (error) {
                $scope.loading = false;
                dialogs.alert.show(error || 'Cannot retrieve data. Please try again later. Error code: SB-53.');
            });
        };

        $scope.applyLicense = function () {

            if ($scope.license.subscribed) {
                mySharedService.broadcast('pageTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.pageTokens));
                mySharedService.broadcast('listTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.listTokens));
                mySharedService.broadcast('companyTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.companyTokens));
                mySharedService.broadcast('contactTokens:' + (!$scope.license.subscribed ? 0 : $scope.license.contactTokens));
            }
            else {
                //$scope.showTab('moremenu', 'status');
                $scope.openStore();
            }

            if (!$scope.$$phase) { $scope.$apply(); }
        };


        $scope.openStore = function () {
            storeService.open();
        };

        $scope.register = function () {
            $location.path('/register');
        };

        $scope.manageChildren = function () {
            $location.path('/subaccounts');
        };

        $scope.refreshAccount();


    }]);
'use strict';

/* global angular: false */
/* global _: false */

angular.module('captureApp')
    .controller('settings', [
        '$scope', '$q', '$location', '$timeout', 'mySharedService', 'storeService', 'storageService', 'docSize', 'userInfoStore', 'shieldService',
        //'salesforce', 'dynamicsCrm', 'pipeliner', 'zoho',
        'exportWrapperService',
        'dialogs', 'environmentUtility', 'bgService', 'settingsUtility', 'chromeUtility',
        function ($scope, $q, $location, $timeout, mySharedService, storeService, storageService, docSize, userInfoStore, shieldService,
            //salesforceService, dynamicsService, pipelinerService, zohoService,
            exportWrapperService,
            dialogs, environmentUtility, bgService, settingsUtility, chromeUtility) {

            var debug = 'settings.js->';
            //console.error(debug);
            //$scope.settings = {};

            var getExportService = function () {
                var exportService = exportWrapperService.getService($scope.settings.target);
                return exportService;
            };

            var getMapEntities = function () {

                if (!$scope.settings.targetMap || Array.isArray($scope.settings.targetMap)) {
                    $scope.settings.targetMap = {};
                }

                if (!$scope.settings.targetMap[$scope.settings.target]) {
                    $scope.settings.targetMap[$scope.settings.target] = { entities: [] };
                }

                var mapEntities = $scope.settings.targetMap[$scope.settings.target].entities;

                return mapEntities;

            };

            var errorHandler = function (error, status) {
                var errorMsg;

                if (_.isObject(error) && error.Message) {
                    errorMsg = error.Message + '\n' + (error.MessageDetail || '');
                } else if (_.isObject(error) && error.message) {
                    errorMsg = error.message;
                } else {
                    errorMsg = error;
                }
                console.error(status, error);
                dialogs.alert.show((errorMsg ? errorMsg : '"Error! See logs for details'));
            };

            $scope.settings = { autoCapture: false, autoCaptureDomains: [] };
            $scope.shieldStatus = 'Unknown';
            $scope.shieldUpdated = 'Unknown';
            $scope.allEntities = [];
            $scope.loading = false;

            $scope.back = function () {
                $location.path('/home');
            };

            $scope.loadSettings = function () {
                console.log('**** loadSettings');
                $scope.loading = true;
                //$scope.settings = userInfoStore.getSettings(); // outdated
                //console.log('***** READ settings from info store', angular.copy($scope.settings));
                storageService.get(
                    ['settings'],
                    function (value) {
                        console.log('***** READ settings from storage', angular.copy(value));
                        try {

                            if (debug) {
                                console.log(debug + 'loaded settings (from Broadlook storage)', angular.copy(value));
                            }

                            $scope.settings = settingsUtility.readSettings(value.settings);

                            try {
                                $scope.settings.managed = value.settings_managed === true;
                            } catch (e) {
                                console.log('ERROR in set managed', e.message);
                            }

                            $scope.loading = false;
                            $scope.saveSettings(true, true);

                            mySharedService.broadcast('settings:', $scope.settings);

                            var scheme = userInfoStore.getShieldScheme();
                            if (typeof scheme === 'undefined') {
                                console.log('ERROR! No Shield scheme found in local cache!');
                                $scope.checkNormalizationStatus();
                            } else {
                                $scope.shieldStatus = scheme ? 'ON' : 'OFF';
                                $scope.shieldUpdated = ($scope.settings.shield ? $scope.settings.shield.updatedOn : '') || 'Unknown';
                                $scope.settings.shield = $scope.settings.shield || {};
                                $scope.settings.shield.scheme = scheme;
                            }

                            $scope.setShowMap();

                        } catch (e) {
                            console.log('ERROR in loadSettings.storageService.get.success', e.message);
                        }

                    },

                    // failed to load
                    function (msg) {
                        $scope.loading = false;
                        dialogs.alert.show(msg);
                    }

                );

                //if (!$scope.$$phase) { $scope.$apply(); }

            };

            // All settings are stored using storageService
            // Settings that content script need are stored to chrome.stoarge.sync as well
            $scope.saveSettings = function (doNotSwitch, doNotBroadcast) {

                if (debug) {
                    console.log(debug + 'saving settings...', angular.copy($scope.settings), 'doNotSwitch=', doNotSwitch, 'doNotBroadcast=', doNotBroadcast);
                }

                $scope.editingTargets = false;

                var o = {};
                o.settings = angular.copy($scope.settings);

                storageService.set(o, function () {
                    if (debug) {
                        console.log(debug + 'saved settings');
                    }
                }, function (error) {
                    console.log('settings were not saved', error);
                });

                var contentSettings = {
                    notification: o.settings.notifications,
                    notificationsRestrictedDomain: o.settings.notificationsRestrictedDomain,
                    target: o.settings.target,
                    //targetMap: o.settings.targetMap,
                    targetParams: o.settings.targetParams
                };

                console.log('contentSettings', angular.copy(contentSettings));

                //chrome.storage.sync.set({ 'contentSettings': contentSettings }, function () {
                chromeUtility.setField('contentSettings', contentSettings,

                    function () {
                        // success
                    },

                    function (error) {
                        console.log('ERROR! contentSettings were not saved to chrome.storage.sync.', error);
                    }

                );

                bgService.setValue('settings', o.settings);

                if (!doNotSwitch) {
                    $scope.back();
                }
                if (!doNotBroadcast) {
                    mySharedService.broadcast('settings:', $scope.settings);
                }
            };

            $scope.toggleDeleteAfterExport = function () {

                if (!$scope.settings.deleteAfterExport) {
                    $scope.settings.deleteAfterExport = 'Prompt';
                } else {
                    if ($scope.settings.deleteAfterExport === 'Prompt') {
                        $scope.settings.deleteAfterExport = 'Always';
                    } else if ($scope.settings.deleteAfterExport === 'Always') {
                        $scope.settings.deleteAfterExport = 'Never';
                    } else {
                        $scope.settings.deleteAfterExport = 'Prompt';
                    }
                }
            };

            $scope.toggleOpenAfterExport = function () {

                if (!$scope.settings.openAfterExport) {
                    $scope.settings.openAfterExport = 'Always';
                } else {
                    if ($scope.settings.openAfterExport === 'Never') {
                        $scope.settings.openAfterExport = 'Always';
                    } else {
                        $scope.settings.openAfterExport = 'Never';
                    }
                }
            };

            $scope.changeTarget = function () {
                //$scope.editingTargets = true;

                if (!$scope.settings) {
                    $scope.settings = {};
                }

                if (!$scope.settings.target) {
                    $scope.settings.target = 'no';
                }

                var crms = exportWrapperService.getServicesList($scope.isProduction, $scope.licenseType);

                var msg = '';
                if ($scope.licenseType === 'Free') {
                    msg = 'Job Science and PCRecruiter are not available in Free version'; // and Pipeliner
                }


                dialogs.lookup
                    .show({ value: $scope.settings.target, lookup: { type: 'CRM', message: 'Select Export Target', required: true, allowNew: false, fixedlist: crms, selectButtonLabel: 'Select', message2: msg } })
                    .select(function (value) {

                        try {

                            console.log('SELECTED VALUE: ', value);
                            $scope.settings.target = value.id;
                            $scope.allEntities = [];

                            // check that targets are set. otherwise, reset.

                            if (!$scope.settings.targetMap ||
                                !$scope.settings.targetMap[$scope.settings.target] ||
                                !$scope.settings.targetMap[$scope.settings.target].entites) {
                                console.log('resetting');
                                $scope.resetMaps(true);
                            } else {
                                console.log('not resetting');
                            }

                            $scope.setShowMap();

                            var es = exportWrapperService.getService($scope.settings.target);
                            exportWrapperService.validateService(es);

                            $scope.refresh();

                        } catch (e) {
                            console.log('ERROR in changeTarget.lookup.success', e.message);
                        }


                    });

            };

            $scope.resetMaps = function (silent) {

                // init objects
                if (!$scope.settings.targetMap || Array.isArray($scope.settings.targetMap))
                { $scope.settings.targetMap = {}; }
                if (!$scope.settings.targetMap[$scope.settings.target])
                { $scope.settings.targetMap[$scope.settings.target] = { entities: [] }; }

                var exportService = getExportService();
                if (!exportService) { return; }

                var f = function () {

                    if (typeof exportService.getDefaultExportMaps !== 'function') {
                        console.log('not supported: getDefaultExportMaps');
                        return;
                    }

                    exportService.getDefaultExportMaps(function (maps) {
                        console.log('getDefaultExportMaps', maps);
                        $scope.settings.targetMap[$scope.settings.target].entities = maps;
                        if (!$scope.$$phase) { $scope.$apply(); }
                    });

                };

                if (silent) {
                    f();
                } else {
                    dialogs.confirm.show('Load default ' + exportService.getName() + ' export targets? All customizations will be lost.')
                        .confirm(f)
                        .cancel();
                }
            };

            $scope.showMap = false;

            $scope.setShowMap = function () {

                $scope.showMap = false;
                var exportService = getExportService();
                if (exportService) {
                    console.log('export service name: ', exportService.getName());
                    if (typeof exportService.getInterfaceVersion === 'function') {
                        console.log('export service version: ', exportService.getInterfaceVersion());
                        if (exportService.getInterfaceVersion() === 2) {
                            $scope.showMap = true;
                        }
                    }
                }
            };

            $scope.editMap = function (entity) {

                console.log('entity', entity);

                var exportService = getExportService();
                if (!exportService) {
                    return;
                }

                var gotEntitiesAction = function () {

                    exportService.getFields(entity.name, function (fields) {

                        console.log('getFields response', angular.copy(fields));

                        dialogs.map
                            .show({ entity: entity, availableFields: fields, availableEntities: $scope.allEntities })
                            .save(function (mappedFields) {

                                if (!entity.map) {
                                    entity.map = {};
                                }

                                entity.map.fields = mappedFields;

                                console.log('entity', entity);

                                if (!$scope.$$phase) {
                                    $scope.$apply();
                                }

                            });

                    }, function (error) {
                        console.log('getFields error', error);
                        dialogs.alert.show(error);
                    });

                };

                var isLoggedInAction = function () {

                    if ($scope.allEntities.length > 0) {
                        gotEntitiesAction();
                    } else {
                        exportService.getEntities(function (entities) {

                            console.log('getEntities response', angular.copy(entities));

                            $scope.allEntities = entities;

                            if ($scope.allEntities.length > 0) {
                                gotEntitiesAction();
                            } else {
                                dialogs.alert.show('Cannot load object descriptions');
                            }

                        }, function (error) {
                            console.log('getEntities error', error);
                            dialogs.alert.show(error);
                        });
                    }

                };

                var isNotLoggedInAction = function () {
                    var login = function () {

                        $scope.saveSettings(true);

                        exportService.login(isLoggedInAction);
                    };
                    dialogs.alert.show('Please login to ' + exportService.getName() + ' first.').ok(login);
                    return;
                };

                var checkLogin = function (params) {
                    console.log('checkLogin', params);
                    exportService.isLoggedIn(isLoggedInAction, isNotLoggedInAction);
                };

                //var loadEntities = function (params) {
                //    console.log('loadEntities', params);
                //    return { isLoggedIn: false };
                //};

                checkLogin();

            };

            $scope.removeMap = function (entity) {

                if (!entity || !entity.name || !$scope.settings.target) {
                    return;
                }

                var mapEntities = getMapEntities();

                var done = false;
                angular.forEach(mapEntities, function (existingEntity, index) {
                    if (done) {
                        return;
                    }
                    if (existingEntity.name === entity.name) {
                        mapEntities.splice(index, 1);
                        done = true;
                    }
                });

            };

            $scope.loadEntities = function () {

                $scope.allEntities = [];

                $scope.showAvailable = true;

                //console.log('settings', angular.copy($scope.settings));

                var exportService = getExportService();

                if (!exportService) {
                    return;
                }

                var isLoggedInAction = function () {
                    console.log('isLoggedInAction');
                    exportService.getEntities(function (list) {

                        console.log('getEntities response', angular.copy(list));
                        $scope.allEntities = list;
                        if (!$scope.$$phase) {
                            $scope.$apply();
                        }

                    }, function (error) {
                        console.log('getEntities error', error);
                        try {
                            dialogs.alert.show(error);
                        } catch (e) {
                            console.log('dialogs.alert error', e.message);
                        }

                    });

                };

                var isNotLoggedInAction = function () {
                    console.log('isNotLoggedInAction');
                    var login = function () {

                        $scope.saveSettings(true);

                        exportService.login(isLoggedInAction);
                    };
                    dialogs.alert.show('Please login to ' + exportService.getName() + ' first.').ok(login);
                };

                exportService.isLoggedIn(isLoggedInAction, isNotLoggedInAction);

            };




            $scope.checkNormalizationStatus = function () {
                $scope.shieldStatus = 'Checking...';
                $scope.loading = true;
                shieldService.getNormalizationScheme(function (scheme) {
                    console.log('SCHEME (2)', scheme);
                    $scope.shieldStatus = scheme ? 'ON' : 'OFF';
                    $scope.settings.shield = $scope.settings.shield || {};
                    $scope.settings.shield.updatedOn = new Date();
                    $scope.settings.shield.scheme = scheme;
                    userInfoStore.setShieldScheme(scheme);
                    $scope.loading = false;
                    //var scheme4 = userInfoStore.getShieldScheme();
                    //console.log('SCHEME4', scheme4);

                    if (!$scope.$$phase) {
                        $scope.$apply();
                    }

                }, function (error) {
                    $scope.loading = false;
                    console.error('ERROR in getNormalizationScheme', error);
                });
            };

            $scope.formatScheme = function (scheme) {
                var result = [];
                const functionName = 'Format Scheme';
                try {
                    if (!scheme) {
                        result = ['Not set'];
                    } else {
                        var rules = scheme.split(';');
                        angular.forEach(rules, function (rule) {
                            var parts = rule.split('=');
                            result.push(parts[0] + ' set to ' + parts[1]);
                        });
                    }
                } catch (e) {
                    var error = functionName + ' > ' + (e ? e.message : '');
                    console.error(error);
                }
                return result;
            };

            $scope.openNormalizationSettings = function () {

                shieldService.openUI(function (url) {
                    $scope.openPage(url);
                }, function (error) {
                    dialogs.alert.show(error);
                });

            };

            $scope.openPage = function (url, newTab) {

                var props = { url: url };
                var callback = function () {
                };
                var f = function (tabs) {
                    if (!tabs || tabs.length === 0) {
                        chrome.tabs.create(props, callback);
                    } else {
                        chrome.tabs.update(tabs[0].id, props, callback);
                    }
                };

                if (newTab) {
                    chrome.tabs.create(props, callback);
                }
                else {
                    chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT }, f);
                }
            };

            $scope.getExportServiceName = function () {

                var name = '';

                if (!$scope.settings || !$scope.settings.target) {
                    name = 'Not selected';
                } else {
                    if ($scope.settings.target === 'no') {
                        name = '- CSV Only -';
                    } else {
                        var exportService = getExportService();
                        if (exportService) {
                            name = exportService.getName();
                        }
                    }
                }

                return name;
            };

            $scope.addEntity = function (newEntity) {

                console.log('adding entity', newEntity);

                if (!newEntity || !newEntity.name || !$scope.settings.target) {
                    return;
                }

                var mapEntities = getMapEntities();

                var exists = false;
                angular.forEach(mapEntities, function (existingEntity, index) {
                    if (existingEntity.name === newEntity.name) {
                        exists = true;
                    }
                });

                if (exists) {
                    return;
                }

                mapEntities.push(newEntity);

            };

            $scope.showFields = function (entity) {

                //if (typeof entity.showFields === 'undefined')
                //    entity.showFields = true;
                //else
                //    
                entity.showFields = !entity.showFields;

                if (!entity.showFields) {
                    return;
                }

                var exportService = getExportService();

                if (!exportService) {
                    return;
                }

                exportService.getFields(entity.name, function (list) {

                    console.log('getFields response', angular.copy(list));
                    entity.fields = list;

                    if (!$scope.$$phase) {
                        $scope.$apply();
                    }

                }, function (error) {
                    console.log('getFields error', error);
                    dialogs.alert.show(error);
                });

            };

            $scope.selectPipelinerOwnerId = function () {

                var exportService = getExportService();

                var f = function () {
                    exportService.getClients(function (list) {

                        var l = [];
                        for (var value in list) {
                            l.push({ label: value, value: list[value] });
                        }

                        dialogs.lookup
                            .show({ value: $scope.settings.targetParams.pp.ownerId, lookup: { type: 'User', message: 'Select New Record Owner', required: true, allowNew: false, fixedlist: l, selectButtonLabel: 'Select' } })
                            .select(function (selectedValue) {
                                console.log('SELECTED VALUE: ', selectedValue);
                                $scope.settings.targetParams.pp.ownerId = selectedValue.id;
                                exportService.init($scope.settings.targetParams.pp);
                            });

                    }, function (error) {
                        dialogs.alert.show(error);
                    });

                };

                exportService.init($scope.settings.targetParams.pp);

                exportService.isLoggedIn(function () {
                    f();
                }, function () {
                    exportService.login(f, function (error) {
                        dialogs.alert.show(error);
                    });
                });

            };

            $scope.getZohoToken = function () {

                var exportService = getExportService();

                if (!$scope.settings.targetParams.zh ||
                    !$scope.settings.targetParams.zh.username ||
                    !$scope.zh_password) {
                    dialogs.alert.show('Please enter your Zoho username and password');
                    return;
                }

                // delete password value from settings
                try {
                    if ($scope.settings.targetParams.zh.password) {
                        $scope.settings.targetParams.zh.password = null;
                        delete $scope.settings.targetParams.zh.password;
                    }
                } catch (e) {
                }

                exportService.createToken($scope.settings.targetParams.zh.username, $scope.zh_password,

                    //success
                    function (token) {
                        $scope.settings.targetParams.zh.token = token;
                        $scope.zh_password = null;
                        $scope.refresh();
                    },

                    // error
                    function (error) {
                        dialogs.alert.show(error);
                    }
                );

            };

            $scope.refresh = function () {
                if (!$scope.$$phase) {
                    $scope.$apply();
                }
            };

            $scope.doOAuth = function (target) {

                if (typeof $scope.settings.targetParams[target] === 'undefined') {
                    $scope.settings.targetParams[target] = {};
                }

                //var sitekey = userInfoStore.getSiteKey();
                //var refreshToken = $scope.settings.targetParams[target].refreshToken || '';
                //var server = 'https://account-staging.broadlook.com';
                //if ($scope.isLocal) {
                //    server = 'http://localhost:52000';
                //}
                //var url = server + '/Capture/Auth/?sitekey=' + sitekey + '&target=' + target + '&refreshToken=' + refreshToken;

                $scope.saveSettings(true, true);

                //// reset local settings
                //bgService.setValue('settings', null);

                //$scope.openPage(url, true);

                var exportService = getExportService();
                if (exportService) {
                    exportService.login(null, null, false, { enableOAuth: true });
                }

                //$timeout(function () {
                //    $scope.getOAuth(target);
                //}, 3000);

            };

            $scope.clearOAuth = function (target) {

                if (typeof $scope.settings.targetParams[target] === 'undefined') {
                    $scope.settings.targetParams[target] = {};
                }

                $scope.settings.targetParams[target].accessToken = null;
                $scope.settings.targetParams[target].refreshToken = null;
                $scope.settings.targetParams[target].connectedAs = null;

                var exportService = getExportService();
                if (exportService) {
                    exportService.logout();
                }

                $scope.saveSettings(true, true);
            };

            $scope.getOAuth = function (target) {

                var requestCallback = function (response) {
                    console.log('OAuth > ', response);
                    if (response && (response.refreshToken || response.accessToken)) {

                        if (typeof $scope.settings.targetParams[target] === 'undefined') {
                            $scope.settings.targetParams[target] = {};
                        }

                        $scope.settings.targetParams[target].accessToken = response.accessToken;
                        $scope.settings.targetParams[target].refreshToken = response.refreshToken;

                        if (!$scope.$$phase) { $scope.$apply(); }
                        var exportService = getExportService();
                        if (exportService) {
                            exportService.init($scope.settings.targetParams[target]);
                        }
                    }
                };

                var tabsCallback = function (tabs) {
                    if (!tabs || tabs.length === 0) {
                        return;
                    }
                    var tab = tabs[0];
                    chrome.tabs.sendRequest(tab.id, { method: 'getOAuth' }, requestCallback);
                };

                chrome.tabs.query({ active: true, windowId: chrome.windows.WINDOW_ID_CURRENT }, tabsCallback);
            };

            if (debug) {
                console.log(debug + 'init');
            }

            //docSize.setWidth(580); // 480
            //docSize.setSize(800, 600);

            //$scope.loadSettings();

            environmentUtility.onLoaded(function () {
                $scope.isLocal = environmentUtility.isRelease('local');
                $scope.isAlpha = environmentUtility.isRelease('alpha');
                $scope.isBeta = environmentUtility.isRelease('beta');
                $scope.isProduction = environmentUtility.isRelease('production');

                if (debug) {
                    console.log(debug + 'release', $scope.isLocal, $scope.isAlpha, $scope.isBeta, $scope.isProduction);
                }

                $scope.loadSettings();
            });

            $scope.$on('handleBroadcast', function () {

                var msg = mySharedService.message;

                if (msg === 'settings:') {
                    $scope.settings = angular.copy(mySharedService.params);
                    console.log('Settings > ', $scope.settings);
                } else if (msg.indexOf('licenseType:') === 0) {
                    $scope.licenseType = msg.substring(msg.indexOf(':') + 1);
                    console.log('License Type > ', $scope.licenseType);
                }

            });

        }
    ]);
'use strict';

/* global angular: false */

angular.module('captureApp')
.controller('signIn', ['$scope', '$location', 'docSize', 'chromeUtility', 'registrationService', 'userInfoStore', 'environmentUtility', 'totangoService', //'bgService',
    function ($scope, $location, docSize, chromeUtility, registrationService, userInfoStore, environmentUtility, totangoService) { //, bgService) {
        var debug = 'signin.js->'; //debug = false;
        $scope.signInFailure = false;
        $scope.signInFailureDescription = null;
        $scope.credentials = { email: null, sitekey: null };
        docSize.setWidth(600);
        //docSize.setSize(480, 250);
        //docSize.setSize(600, 500);

        //  Private methods
        var onLoggedIn = function (token) {
            if (debug) { console.log(debug + 'Logged into chrome!'); }
            $scope.interactive = false;
            userInfoStore.load();
            //  Wait for user info to be loaded
            userInfoStore.onLoaded(onInfoLoaded);
        };

        var onInfoLoaded = function () {
            const functionName = 'On User Info Loaded';

            if (debug) { console.log(functionName); }

            if (registrationService.isRegistered()) {
                onRegistered();
            } else {
                onUnregistered();
            }
        };

        var onNotLoggedIn = function (msg) {
            console.error('Sign In > OnNotLoggedIn > ', msg);
            $scope.signInFailure = true;
            $scope.signInFailureDescription = msg;
            $scope.refresh();

            // Attempt alternative login
            userInfoStore.load();
            userInfoStore.onLoaded(function () {
                var email = userInfoStore.getProfileEmail();
                console.log('Attempt to load user email', email);
                if (email) {
                    $scope.credentials.email = email;
                    $scope.manualSignIn();
                }
            });

        };

        var onRegistered = function () {
            totangoService.sendEvent('login');
            $location.path('/home');
            $scope.refresh();
        };

        var onUnregistered = function () {
            $location.path('/register');
            $scope.refresh();
        };
        //  /Private methods


        $scope.refresh = function () {
            if (!$scope.$$phase) { $scope.$apply(); }
        };

        $scope.interactive = false;

        //  Do sign in
        $scope.signIn = function () {
            $scope.signInFailure = false;
            $scope.interactive = true;
            $scope.refresh();
            if (debug) { console.log(debug + 'Logging into chrome (interactively)...'); }
            chromeUtility.login($scope.interactive, onLoggedIn, onNotLoggedIn);
        };

        // Opens a tab with Chrome Sign In
        $scope.signInToChrome = function () {
            try {
                if (debug) { console.log(debug + 'Navigating to chrome signin page...'); }
                chromeUtility.openLink('chrome://chrome-signin/', false);
            } catch (e) {
                console.log('ERROR in signInToChrome', e.message);
            }
        };

        $scope.manualSignIn = function () {
            const functionName = 'Manual Sign In';
            try {
                registrationService.me($scope.credentials, function (response) {
                    console.log(functionName, response);

                    $scope.credentials.sitekey = response.sitekey;

                    userInfoStore.loadManual({
                        siteKey: response.sitekey,
                        crmId: 'chrome-sf:' + $scope.credentials.email,
                        ShieldAuth: response.auth,
                        ShieldId: response.uid,
                        ShieldScheme: null,
                        ProfileName: response.name || '',
                        ProfileTitle: response.title,
                        ProfileCompany: response.company,
                        ProfilePhone: response.phone,
                        ProfileTarget: null,
                        ProfileEmail: $scope.credentials.email,
                        Settings: null,
                        Target: null,
                        TargetUrl: null
                    });

                    onLoggedIn();

                }, function (error) {
                    console.error(functionName + ' > Me', error);
                });
            } catch (e) {
                console.error(functionName, e.message);
            }
        };

        //  Don't begin auto-sign-in until after the environment is loaded
        environmentUtility.onLoaded(function () {
            $scope.signInFailure = false;
            if (debug) { console.log(debug + 'Logging into chrome (silently)...'); }
          
            chromeUtility.login($scope.interactive, onLoggedIn, function (msg) {
                $scope.signIn();
            });

        });


    }]);
'use strict';

/* global angular: false */

angular.module('captureApp')
.controller('subaccounts', ['$scope', '$location', 'limitService', 'mySharedService', 'storeService', 'docSize', 'dialogs', 'environmentUtility',
    function ($scope, $location, limitService, mySharedService, storeService, docSize, dialogs, environmentUtility) {

        var debug = 'children.js->';

        //docSize.setWidth(480);
        docSize.setSize(600, 500);

        //if (debug) { console.log(debug + 'init'); }

        environmentUtility.onLoaded(function () {
            $scope.isLocal = environmentUtility.isRelease('local');
            $scope.isAlpha = environmentUtility.isRelease('alpha');
            $scope.isBeta = environmentUtility.isRelease('beta');
            $scope.isProduction = environmentUtility.isRelease('production');
        });

        $scope.back = function () {
            $location.path('/home');
        };

        $scope.accounts = {
            list: [],
            selected: '',

            connect: function () {
                dialogs.text.show({ message: 'Enter a sub-account email', required: 'An email must be provided', placeholder: 'example: john.doe@gmail.com' })
               .confirm(function (email) {
                   dialogs.busy.show('Connecting sub-account...');
                   limitService.connectSubaccount(email, function () {
                       dialogs.busy.hide();
                       dialogs.alert.show('Sub-account successfully connected!');
                       $scope.accounts.retrieve();
                   }, function (error) {
                       dialogs.busy.hide();
                       if (error)
                       { dialogs.alert.show(error); }
                       else
                       { dialogs.alert.show('No such account. User has to install and register Capture! first.'); }
                   });
               });


            },

            disconnect: function (email) {
                console.log('disconnect', email);
                dialogs.confirm.show('Are you sure you want to disconnect ' + email + '?')
                    .confirm(function () {
                        limitService.disconnectSubaccount(email, function () {
                            dialogs.busy.hide();
                            $scope.accounts.retrieve();
                        }, function (error) {
                            dialogs.busy.hide();
                            if (error)
                            { dialogs.alert.show(error); }
                            else
                            { dialogs.alert.show('Failed to disconnect this account. Please try again later. Error code: SA-55.'); }
                        });
                    });
            },

            retrieve: function () {
                limitService.retrieveSubaccounts(function (_list) {
                    $scope.accounts.list = _list;
                    if (!$scope.$$phase) { $scope.$apply(); }
                }, function (error) {
                    $scope.accounts.list = [];
                    if (!$scope.$$phase) { $scope.$apply(); }
                });
            },

            setLimit: function (email, currentLimit) {
                dialogs.text.show({ message: 'Enter new monthly limit', required: 'A limit must be provided', placeholder: currentLimit })
               .confirm(function (limit) {
                   dialogs.busy.show('Updating sub-account...');
                   limitService.setSubaccountLimit(limit, email, function () {
                       dialogs.busy.hide();
                       dialogs.alert.show('Sub-account limit was updated!');
                       $scope.accounts.retrieve();
                   }, function (error) {
                       dialogs.busy.hide();
                       if (error)
                       { dialogs.alert.show(error); }
                       else
                       { dialogs.alert.show('Cannot set this limit.'); }
                   });
               });


            },

            // Expiremental! Usage report
            getLimit: function (year, month) {
                limitService.retrieveSubaccounts(function (_list) {
                    $scope.accounts.list = _list;
                    if (!$scope.$$phase) { $scope.$apply(); }
                }, function (error) {
                    $scope.accounts.list = [];
                    if (!$scope.$$phase) { $scope.$apply(); }
                });
            },

        };

        $scope.accounts.retrieve();

    }]);
'use strict';

/* global angular: false */
/* global $: false */
angular.module('captureApp')
.controller('pattern', ['$scope', '$location', 'docSize', 'dialogs', 'environmentUtility', 'patternStore', 'chromeUtility',
    function ($scope, $location, docSize, dialogs, environmentUtility, patternStore, chromeUtility) {
        docSize.setSize(600, 500);
        var debug = 'view/pattern/controller.js->';
        var refresh = function () {
            if (!$scope.$$phase) { $scope.$apply(); }
        };
        var save = function () {
            if (debug) { console.log(debug + 'Saved patterns', $scope.patterns); }
            patternStore.setPatterns($scope.patterns);
            refresh();
        };
        var isValidPattern = function (pattern) {

            if (!pattern)
            { return false; }

            var v = pattern.SchemaVersion;
            if (!v || !(v.length >= 2 && v[0] === '1' && v[1] === '.' && v[2] === '0'))
            { return false; }

            return true;
        };
        $scope.modal = {};

        environmentUtility.onLoaded(function () {
            $scope.isLocal = environmentUtility.isRelease('local');
            $scope.isAlpha = environmentUtility.isRelease('alpha');
            $scope.isBeta = environmentUtility.isRelease('beta');
        });

        patternStore.getPatterns(function (patterns, ts) {
            $scope.patterns = patterns;
            try {
                $scope.patterns_days = 'Unknown';
                if (ts > 0) {
                    var date1 = new Date();
                    var date2 = ts;
                    var timeDiff = Math.abs(date2.getTime() - date1.getTime());
                    var daysOld = Math.ceil(timeDiff / (1000 * 3600 * 24));
                    if (daysOld > 1) {
                        $scope.patterns_days = '' + daysOld + ' days ago';
                    } else if (daysOld === 1) {
                        $scope.patterns_days = '' + daysOld + ' day ago';
                    } else if (daysOld === 0) {
                        $scope.patterns_days = 'Today';
                    }
                }
            } catch (e) {
                console.error('Cannot read a timestamp > ', e.message);
            }

        });


        $scope.back = function () {
            $location.path('/home');
        };



        $scope.moveUp = function (index) {
            if (index === ($scope.patterns.length - 1)) { return; }
            var pattern = $scope.patterns.splice(index, 1);
            $scope.patterns.splice(index + 1, 0, pattern[0]);
            save();
        };

        $scope.moveDown = function (index) {
            if (index === 0) { return; }
            var pattern = $scope.patterns.splice(index, 1);
            $scope.patterns.splice(index - 1, 0, pattern[0]);
            save();
        };

        $scope.loadPatterns = function () {

            console.log('Loading patterns. Sources > ', $scope.sources);

            if (!$scope.patterns) { $scope.patterns = []; }

            if (!$scope.sources || $scope.sources.length === 0) {
                $scope.loadFactorySources();
            }

            var messages = [];
            var wrongSchemaCount = 0;

            angular.forEach($scope.sources, function (source, key) {

                patternStore.getFactoryPatterns(source, function (patterns) {

                    // delete all patterns from this source
                    var deletedCount = 0;
                    var i;

                    if (source.Name) {
                        i = $scope.patterns.length;
                        while (i--) {
                            if ($scope.patterns[i].SourceName === source.Name) { $scope.patterns.splice(i, 1); deletedCount++; }
                        }
                    }
                    if (debug) { console.log(debug + 'Deleted patterns', deletedCount); }

                    if (patterns) {

                        if (!patterns.length) // Fix single pattern
                        { patterns = [patterns]; }

                        i = patterns.length;
                        while (i--) {
                            if (!patterns[i].SourceName) { patterns[i].SourceName = source.Name; }
                        }

                        //check pattern schema version
                        i = patterns.length;
                        while (i--) {
                            if (!isValidPattern(patterns[i])) {
                                patterns.splice(i, 1);
                                wrongSchemaCount++;
                                console.log('schema is invalid ', patterns[i]);
                            }
                        }

                        $scope.patterns = $scope.patterns.concat(patterns);
                    }
                    if (debug) { console.log(debug + 'Added patterns', patterns); }

                    save();

                    messages.push('Loaded ' + patterns.length + ' patterns from ' + source.Url);

                    if (wrongSchemaCount > 0) {
                        var ending = wrongSchemaCount === 1 ? '' : 's';
                        messages.push(wrongSchemaCount + ' pattern' + ending + ' are not compatible and were not loaded.\n Invalid SchemaVersion value. ');
                    }


                    if (key === ($scope.sources.length - 1)) {
                        console.log('pre!');
                        dialogs.alert.show({ text: messages.join('\n\n'), pre: true });
                    }

                }, function (errorDetails) {
                    var s = '';
                    if (errorDetails)
                    { s = '\n\nDetails: ' + errorDetails; }
                    dialogs.alert.show({ text: 'Cannot load patterns from ' + source.Url + s, pre: true });
                });
            });

        };

        $scope.remove = function (index) {
            dialogs.confirm.show('Are you sure you want to delete this pattern?')
                .confirm(function () {
                    $scope.patterns.splice(index, 1);
                    save();
                });

        };

        $scope.removeAll = function () {
            dialogs.confirm.show('Are you sure you want to delete all patterns?')
                .confirm(function () {
                    $scope.patterns = [];
                    save();
                });
        };

        $scope.restoreFactory = function () {
            dialogs.confirm.show('Are you sure you want to delete all patterns?')
                .confirm(function () {
                    $scope.patterns = [];
                    $scope.loadFactorySources();
                    $scope.loadPatterns();
                });
        };

        $scope.create = function () {
            $scope.modal.editIndex = -1;
            $scope.modal.text = '';
            $($scope.modal.selector).modal('show');
        };
        $scope.edit = function (index) {
            $scope.modal.editIndex = index;
            $scope.modal.text = JSON.stringify($scope.patterns[index]);
            $($scope.modal.selector).modal('show');
        };
        $scope.save = function () {
            $($scope.modal.selector).modal('hide');
            var pattern = null;
            try {
                pattern = JSON.parse($scope.modal.text);
                if (!pattern.SourceName) { pattern.SourceName = 'Custom'; }
            } catch (e) {
                dialogs.alert.show('An error occurred parsing this pattern.')
                    .ok(function () { $($scope.modal.selector).modal('show'); });
                return;
            }

            if (!isValidPattern(pattern)) {
                dialogs.alert.show('The pattern is not compatible and was not loaded. Invalid SchemaVersion value.')
                    .ok(function () { $($scope.modal.selector).modal('show'); });
                return;
            }

            if ($scope.modal.editIndex >= 0) {
                $scope.patterns[$scope.modal.editIndex] = pattern;
            } else {
                $scope.patterns.push(pattern);
            }
            save();

        };
        $scope.cancel = function () {
            $($scope.modal.selector).modal('hide');
        };

        $scope.openLink = function (link) {
            chromeUtility.openLink(link);
        };

        // Sources

        patternStore.getSources(function (sources) {
            $scope.sources = sources;
            if (!$scope.sources)
            { $scope.sources = []; }
        });
        var saveSources = function () {
            patternStore.setSources($scope.sources);
            refresh();
        };


        $scope.modalSource = {};

        $scope.moveSourceUp = function (index) {
            if (index === ($scope.sources.length - 1)) { return; }
            var source = $scope.sources.splice(index, 1);
            $scope.sources.splice(index + 1, 0, source[0]);
            save();
        };
        $scope.moveSourceDown = function (index) {
            if (index === 0) { return; }
            var source = $scope.sources.splice(index, 1);
            $scope.sources.splice(index - 1, 0, source[0]);
            save();
        };
        $scope.editSource = function (index) {
            $scope.modalSource.editIndex = index;
            $scope.modalSource.Name = $scope.sources[index].Name;
            $scope.modalSource.Url = $scope.sources[index].Url;
            $($scope.modalSource.selector).modal('show');
        };
        $scope.createSource = function () {
            $scope.modalSource.editIndex = -1;
            $scope.modalSource.Url = 'http://';
            $($scope.modalSource.selector).modal('show');
        };
        $scope.removeSource = function (index) {
            dialogs.confirm.show('Are you sure you want to delete this source?')
                .confirm(function () {
                    $scope.sources.splice(index, 1);
                    saveSources();
                });

        };
        $scope.saveSource = function () {
            $($scope.modalSource.selector).modal('hide');
            var source = null;
            try {
                source = { Url: $scope.modalSource.Url, Name: $scope.modalSource.Name };
            } catch (e) {
                dialogs.alert.show('An error occurred parsing this source.')
                    .ok(function () { $($scope.modalSource.selector).modal('show'); });
                return;
            }

            if ($scope.modalSource.editIndex >= 0) {
                $scope.sources[$scope.modalSource.editIndex] = source;
            } else {
                $scope.sources.push(source);
            }
            saveSources();

        };
        $scope.cancelSource = function () {
            $($scope.modalSource.selector).modal('hide');
        };

        $scope.loadFactorySources = function () {
            $scope.sources = patternStore.getDefaultSources();
            saveSources();
        };

    }]);
'use strict';

/* global angular: false */
/* global jQuery: false */

angular.module('captureApp')
.controller('contacts', ['$scope', 'dialogs',
    function ($scope, dialogs) {

        //  Expose dialogs to UI so we can load templates we need
        $scope.dialogs = dialogs;


    }]);
'use strict';

/* global angular: false */
/* global jQuery: false */

angular.module('captureApp')
.controller('searches', ['$scope', 'searchesService', 'dialogs',
    function ($scope, searchesService, dialogs) {
        $scope.templates = {
            tab: 'components/views/searches/tab.html'
        };
        searchesService.teams.retrieve();
    }]);



'use strict';

/* global angular: false */


angular.module('captureApp')
.controller('searchTab', ['$scope', '$location', 'searchesService', 'dialogs',
    function ($scope, $location, searchesService, dialogs) {
        var failureCallback = function(response){
            console.log('SearchTab failure:', response);
        };

        var scopes = [
            'favorites',
            'person',
            'team',
            'community'
        ];

        $scope.targetScope = 'community';


        $scope.searches = {
            list: [],
            map: searchesService.getMap(),
            keywords: '',
            create: function(){
                dialogs.searches.edit.show({})
                    .confirm(searchesService.reload)
                    .cancel(failureCallback);
            },
            find: function(allowCache){
                var keywords = $scope.searches.keywords;
                var targetId = ( $scope.targetScope === 'team' ? $scope.teams.selected : '');
                if (!keywords) { keywords = ''; }
                if ($scope.debug) { console.log('RETRIEVE SEARCHES', allowCache, $scope.targetScope, targetId, keywords.split(' ')); }
                searchesService.searches.retrieve(allowCache, $scope.targetScope, targetId, keywords.split(' '), function (idList) {
                        console.log('Search Tab > Find > ', idList);
                        $scope.searches.list = idList;
                        if (!$scope.$$phase) { $scope.$apply(); }
                    });
            }
        };

        //  Anytime a reload is requested, we want to respond to it.
        searchesService.setReloadCallback($scope.searches.find);

        $scope.search = {
            edit: function(searchId){
                dialogs.searches.edit.show(angular.copy($scope.searches.map[searchId]))
                    .confirm(searchesService.reload)
                    .cancel(failureCallback);
            },
            run: function(searchId){
                dialogs.searches.run.show($scope.searches.map[searchId]);
            },
            favorite: function(searchId){
                searchesService.searches.share(searchId, 'favorites', '', '', function(){
                        searchesService.reload();
                        dialogs.alert.show('Added successfully!');
                    }, failureCallback);
            },
            defavorite: function(searchId){
                searchesService.searches.unShare(searchId, 'favorites', '', '', function(){
                        searchesService.reload();
                        //dialogUtility.alert('Added successfully!');
                    }, failureCallback);
            },
            share: function(searchId, targetScope, targetId){
                searchesService.searches.share(searchId, targetScope, targetId, '',function(){
                        searchesService.reload();
                        dialogs.alert.show('Shared successfully!');
                    }, failureCallback);
            },
            unshare: function (searchId) {
                dialogs.confirm.show('Are you sure you want to stop sharing this search?')
                    .confirm( function(){
                        searchesService.searches.unShare(searchId, $scope.targetScope,( $scope.targetScope === 'team' ? $scope.teams.selected : ''), '',function(){
                                searchesService.reload();
                                //dialogUtility.alert('Unshared successfully!');
                            }, failureCallback);
                    });
            },
            remove: function(searchId){

                dialogs.confirm.show('Are you sure you want to remove this search?')
                    .confirm( function(){
                        if($scope.targetScope==='person'){
                            searchesService.searches.remove(searchId, $scope.searches.find, failureCallback);
                        }else{
                            searchesService.searches.unShare(searchId, $scope.targetScope, '', '', $scope.searches.find, failureCallback);
                        }

                    });
            },
            rate: function(searchId, direction){
                searchesService.searches.ratings.create(searchId, direction);
            },

            comments: {
                toggle: function(searchId){
                    $scope.searches.map[searchId].showComments = !$scope.searches.map[searchId].showComments;
                    if($scope.searches.map[searchId].showComments && !$scope.searches.map[searchId].commentsLoaded){
                        searchesService.searches.comments.retrieve(searchId);
                    }
                },
                add: function(searchId, comment){
                    searchesService.comments.create(searchId, comment, function(response){
                        $scope.searches.map[searchId].newComment = '';
                        searchesService.searches.comments.retrieve(searchId);
                    }, function(response){
                        console.log('error posting comment', response);
                        $scope.searches.map[searchId].newComment = '';
                    });
                }
            },

            team: {
                add: function(searchId, teamCode){
                    searchesService.linkToTeam(searchId, teamCode, function(){
                            searchesService.reload();
                            dialogs.alert.show('Search was pinned to team.');
                        }, function(response){
                            if(response) { dialogs.alert.show('Error pinning team:' + response); }
                        });
                }
            }

        };

        $scope.init = function (myScope) {
            console.log('Search Tab > Init > ', myScope);
            $scope.targetScope = myScope;
            var allowCache = true;
            $scope.searches.find(allowCache);
        };

        $scope.teams = {
            list: [],
            selected: '',
            retrieve: function () {
                searchesService.teams.retrieve(true, function (teams) {
                    console.log('teams retrieved', angular.copy(teams));
                    $scope.teams.list = teams.list;
                }, function (error) {
                    console.log('teams not retrieved', error);
                });
            },
            create: function(){
                dialogs.text.show({message:'Enter a team name', required:'A team name must be provided', placeholder:'example: The Sharks'})
                    .confirm(function(name){
                        dialogs.busy.show('Creating team...');
                        searchesService.teams.create(name, function(teams){
                                dialogs.busy.hide();
                                dialogs.alert.show('Team successfully created!  You may now share your to your team!').ok($scope.searches.find);
                                console.log('team created', angular.copy(teams));
                                //$scope.teams.list = teams.list;
                                searchesService.teams.retrieve(true);
                            }, function(error){
                                dialogs.busy.hide();
                                dialogs.alert.show(error).ok($scope.teams.create);
                            });
                    });
            },
            join: function(){
                dialogs.text.show({message:'Enter a team code', required:'A team code must be provided', placeholder:'example: 234993284'})
                    .confirm(function(code){
                        dialogs.busy.show('Joining team...');
                        searchesService.teams.join(code, function(teams){
                                dialogs.busy.hide();
                                //$scope.teams.list = teams.list;
                                searchesService.reload();
                                searchesService.teams.retrieve(true);
                            }, function(error){
                                dialogs.busy.hide();
                                dialogs.alert.show(error)
                                    .ok($scope.teams.join);
                            });
                    });
            },
            share: function(){
                dialogs.text.show({message:'Copy this code and share it with your team members:', value: $scope.teams.selected, readOnly: true});
            },
            leave: function(){
                dialogs.confirm.show('Are you sure you want to leave this team?')
                    .confirm(function(){
                        searchesService.teams.leave($scope.teams.selected, function(teams){
                                dialogs.busy.hide();
                                //$scope.teams.list = teams.list;
                                searchesService.reload();
                                searchesService.teams.retrieve(true);
                            }, function(error){
                                dialogs.busy.hide();
                                dialogs.alert.show(error)
                                    .ok($scope.teams.join);
                            });
                    });
            },
            change: function(){
                $scope.searches.find();
            }
        };

        searchesService.onTeamsChanged = function(teams){
            $scope.teams.list = teams;
            $scope.teams.selected = (teams.length ? teams[0].teamcode : '');
            var alloweCache = true;
            if ($scope.targetScope === 'team') { $scope.searches.find(alloweCache); }
        };

        //$scope.init($scope.targetScope);

    }]);
'use strict';

/* global angular: false */
/* global jQuery: false */

var blmm = angular.module('broadlook.multimerge', []);

/*
    Definition: {
        groups: {
            list: ['g1', 'g2'],
            map: {
                g1: {display:'Group 1', fields:['fName'] },
                g2: {display:'Group 2', fields:['lName'] },
            }
        },
        fields: {
            list: [ 'fName', 'lName' ],
            map: {
                fName: {display: 'First Name'},
                lName: {display: 'Last Name'}
            }
        }
    }

    Candidate:{
        display: 'Name to display in column header',
        id: 'Unique identifier',
        fieldValues: {
            fName: 'Example',
            lName: 'Example
        }
    }

*/

//  Multimerge Utility
blmm.factory('multimerge.service', [function () {
        var debug = true;

        var utility = {
            onShow: function(){},

            merge: function(definition, candidates, confirmCallback, cancelCallback){
                this.onShow(definition, candidates, confirmCallback, cancelCallback);
            }
        };
        return utility;
    }]);


//	MultiMerge View Controller
blmm.controller('multimerge.controller', ['$scope', 'multimerge.service',
    function ($scope, service) {
        var refresh = function(){
            console.log('refreshing interface');
            if (!$scope.$$phase) { $scope.$apply(); }
        };

        var callbacks = {};

        var show = function(){
            console.log('showing interface');
            if (!$scope.$$phase) { $scope.$apply(); }
            jQuery( $scope.modalSelector ).modal('show');
        };
        var hide = function(){
            jQuery( $scope.modalSelector ).modal('hide');
        };

        var buildWinner = function(){
            console.log('building winner');
            var definition = $scope.definition;
            var candidates = $scope.candidates;
            var winner = {fieldValues:{}};
            for(var fieldKey in definition.fields.map){
                for(var candidateIndex in candidates){
                    if(candidates[candidateIndex].fieldValues[fieldKey]) {
                        winner.fieldValues[fieldKey] = candidates[candidateIndex].fieldValues[fieldKey];
                        break;
                    }
                }
            }
            $scope.winner = winner;
        };



        //  Register with service
        service.onShow = function (definition, candidates, confirmCallback, cancelCallback) {

            console.log('Definition', definition);
            console.log('Candidates', candidates);

            $scope.definition = definition;
            $scope.candidates = candidates;

            callbacks.confirm = confirmCallback;
            callbacks.cancel = cancelCallback;

            //  Build winner
            buildWinner();
            show();

        };

        $scope.modalSelector = '';
        $scope.winner = {fieldValues:{}};

        $scope.definition = {
            groups: {
                list: ['g1', 'g2'],
                map: {
                    g1: {display:'Group 1', fields:['fName'] },
                    g2: {display:'Group 2', fields:['lName'] },
                }
            },
            fields: {
                list: [ 'fName', 'lName' ],
                map: {
                    fName: {display: 'First Name'},
                    lName: {display: 'Last Name'}
                }
            }
        };
        $scope.candidates = [
            {
                display: 'Candidate 1',
                id: '1',
                fieldValues: {
                    fName: 'Casey',
                    lName: 'K'
                }
            },
            {
                display: 'Candidate 2',
                id: '2',
                fieldValues: {
                    fName: 'Alex',
                    lName: 'K'
                }
            }

        ];

        $scope.confirm = function(){
            hide();
            try{ callbacks.confirm(angular.copy($scope.winner)); }catch(e){}
        };
        $scope.cancel = function(){
            hide();
            try{ callbacks.cancel(); }catch(e){}
        };

        //  Select all fields for a particular candidate
        $scope.selectCandidate = function(candidate){
            for(var fieldKey in $scope.definition.fields.map){
                $scope.winner.fieldValues[fieldKey] = candidate.fieldValues[fieldKey];
            }
        };

        //  Select all fields for a particular candidate group
        $scope.selectCandidateFields = function(candidate, fields){
            for(var fieldIndex in fields){
                var fieldKey = fields[fieldIndex];
                $scope.winner.fieldValues[fieldKey] = candidate.fieldValues[fieldKey];
            }
        };


    }]);
